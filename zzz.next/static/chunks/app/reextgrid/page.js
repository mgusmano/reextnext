/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["app/reextgrid/page"],{

/***/ "(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Fmarcgusmano%2F%40%2Fwebinars%2FReExtNext%2Freextnext%2Fapp%2Freextgrid%2Fpage.js%22%2C%22ids%22%3A%5B%5D%7D&server=false!":
/*!************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Fmarcgusmano%2F%40%2Fwebinars%2FReExtNext%2Freextnext%2Fapp%2Freextgrid%2Fpage.js%22%2C%22ids%22%3A%5B%5D%7D&server=false! ***!
  \************************************************************************************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./app/reextgrid/page.js */ \"(app-pages-browser)/./app/reextgrid/page.js\"));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtZmxpZ2h0LWNsaWVudC1lbnRyeS1sb2FkZXIuanM/bW9kdWxlcz0lN0IlMjJyZXF1ZXN0JTIyJTNBJTIyJTJGVXNlcnMlMkZtYXJjZ3VzbWFubyUyRiU0MCUyRndlYmluYXJzJTJGUmVFeHROZXh0JTJGcmVleHRuZXh0JTJGYXBwJTJGcmVleHRncmlkJTJGcGFnZS5qcyUyMiUyQyUyMmlkcyUyMiUzQSU1QiU1RCU3RCZzZXJ2ZXI9ZmFsc2UhIiwibWFwcGluZ3MiOiJBQUFBLHdLQUE0RyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvPzVhZWEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0KC8qIHdlYnBhY2tNb2RlOiBcImVhZ2VyXCIgKi8gXCIvVXNlcnMvbWFyY2d1c21hbm8vQC93ZWJpbmFycy9SZUV4dE5leHQvcmVleHRuZXh0L2FwcC9yZWV4dGdyaWQvcGFnZS5qc1wiKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Fmarcgusmano%2F%40%2Fwebinars%2FReExtNext%2Freextnext%2Fapp%2Freextgrid%2Fpage.js%22%2C%22ids%22%3A%5B%5D%7D&server=false!\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@gusmano/reext/dist/reext.es.js":
/*!******************************************************!*\
  !*** ./node_modules/@gusmano/reext/dist/reext.es.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Ext_define: function() { return /* binding */ dp; },\n/* harmony export */   Fill: function() { return /* binding */ ap; },\n/* harmony export */   ReExtLoader: function() { return /* binding */ Bn; },\n/* harmony export */   ReExtProvider: function() { return /* binding */ lp; },\n/* harmony export */   ReExtReferences: function() { return /* binding */ fp; },\n/* harmony export */   ReExtSplash: function() { return /* binding */ tp; },\n/* harmony export */   Test: function() { return /* binding */ cp; },\n/* harmony export */   \"default\": function() { return /* binding */ np; },\n/* harmony export */   useReExtState: function() { return /* binding */ up; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react-dom/index.js\");\n\n\nfunction sa(e) {\n  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, \"default\") ? e.default : e;\n}\nvar sn = { exports: {} }, J = sn.exports = {}, he, be;\nfunction Lr() {\n  throw new Error(\"setTimeout has not been defined\");\n}\nfunction Fr() {\n  throw new Error(\"clearTimeout has not been defined\");\n}\n(function() {\n  try {\n    typeof setTimeout == \"function\" ? he = setTimeout : he = Lr;\n  } catch {\n    he = Lr;\n  }\n  try {\n    typeof clearTimeout == \"function\" ? be = clearTimeout : be = Fr;\n  } catch {\n    be = Fr;\n  }\n})();\nfunction cn(e) {\n  if (he === setTimeout)\n    return setTimeout(e, 0);\n  if ((he === Lr || !he) && setTimeout)\n    return he = setTimeout, setTimeout(e, 0);\n  try {\n    return he(e, 0);\n  } catch {\n    try {\n      return he.call(null, e, 0);\n    } catch {\n      return he.call(this, e, 0);\n    }\n  }\n}\nfunction ca(e) {\n  if (be === clearTimeout)\n    return clearTimeout(e);\n  if ((be === Fr || !be) && clearTimeout)\n    return be = clearTimeout, clearTimeout(e);\n  try {\n    return be(e);\n  } catch {\n    try {\n      return be.call(null, e);\n    } catch {\n      return be.call(this, e);\n    }\n  }\n}\nvar Ee = [], Me = !1, Pe, ar = -1;\nfunction la() {\n  !Me || !Pe || (Me = !1, Pe.length ? Ee = Pe.concat(Ee) : ar = -1, Ee.length && ln());\n}\nfunction ln() {\n  if (!Me) {\n    var e = cn(la);\n    Me = !0;\n    for (var r = Ee.length; r; ) {\n      for (Pe = Ee, Ee = []; ++ar < r; )\n        Pe && Pe[ar].run();\n      ar = -1, r = Ee.length;\n    }\n    Pe = null, Me = !1, ca(e);\n  }\n}\nJ.nextTick = function(e) {\n  var r = new Array(arguments.length - 1);\n  if (arguments.length > 1)\n    for (var t = 1; t < arguments.length; t++)\n      r[t - 1] = arguments[t];\n  Ee.push(new un(e, r)), Ee.length === 1 && !Me && cn(ln);\n};\nfunction un(e, r) {\n  this.fun = e, this.array = r;\n}\nun.prototype.run = function() {\n  this.fun.apply(null, this.array);\n};\nJ.title = \"browser\";\nJ.browser = !0;\nJ.env = {};\nJ.argv = [];\nJ.version = \"\";\nJ.versions = {};\nfunction we() {\n}\nJ.on = we;\nJ.addListener = we;\nJ.once = we;\nJ.off = we;\nJ.removeListener = we;\nJ.removeAllListeners = we;\nJ.emit = we;\nJ.prependListener = we;\nJ.prependOnceListener = we;\nJ.listeners = function(e) {\n  return [];\n};\nJ.binding = function(e) {\n  throw new Error(\"process.binding is not supported\");\n};\nJ.cwd = function() {\n  return \"/\";\n};\nJ.chdir = function(e) {\n  throw new Error(\"process.chdir is not supported\");\n};\nJ.umask = function() {\n  return 0;\n};\nvar ua = sn.exports;\nconst se = /* @__PURE__ */ sa(ua);\nvar rr = typeof globalThis < \"u\" ? globalThis : typeof window < \"u\" ? window : typeof __webpack_require__.g < \"u\" ? __webpack_require__.g : typeof self < \"u\" ? self : {};\nfunction kr(e) {\n  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, \"default\") ? e.default : e;\n}\nvar Nr = { exports: {} }, We = {}, ft;\nfunction fa() {\n  return ft || (ft = 1, se.env.NODE_ENV !== \"production\" && function() {\n    var e = (react__WEBPACK_IMPORTED_MODULE_0___default()), r = Symbol.for(\"react.element\"), t = Symbol.for(\"react.portal\"), n = Symbol.for(\"react.fragment\"), c = Symbol.for(\"react.strict_mode\"), i = Symbol.for(\"react.profiler\"), l = Symbol.for(\"react.provider\"), o = Symbol.for(\"react.consumer\"), p = Symbol.for(\"react.context\"), u = Symbol.for(\"react.forward_ref\"), f = Symbol.for(\"react.suspense\"), h = Symbol.for(\"react.suspense_list\"), _ = Symbol.for(\"react.memo\"), M = Symbol.for(\"react.lazy\"), F = Symbol.for(\"react.offscreen\"), A = Symbol.for(\"react.cache\"), d = Symbol.iterator, Y = \"@@iterator\";\n    function Q(a) {\n      if (a === null || typeof a != \"object\")\n        return null;\n      var $ = d && a[d] || a[Y];\n      return typeof $ == \"function\" ? $ : null;\n    }\n    var w = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n    function N(a) {\n      {\n        for (var $ = arguments.length, S = new Array($ > 1 ? $ - 1 : 0), q = 1; q < $; q++)\n          S[q - 1] = arguments[q];\n        y(\"error\", a, S);\n      }\n    }\n    function y(a, $, S) {\n      {\n        var q = w.ReactDebugCurrentFrame, V = q.getStackAddendum();\n        V !== \"\" && ($ += \"%s\", S = S.concat([V]));\n        var X = S.map(function(te) {\n          return String(te);\n        });\n        X.unshift(\"Warning: \" + $), Function.prototype.apply.call(console[a], console, X);\n      }\n    }\n    var ve = !1, pe = !1, me = !1, ye = !1, xe = !0, _e = xe, ge = !1;\n    function Te(a, $, S) {\n      var q = a.displayName;\n      if (q)\n        return q;\n      var V = $.displayName || $.name || \"\";\n      return V !== \"\" ? S + \"(\" + V + \")\" : S;\n    }\n    function g(a) {\n      return a.displayName || \"Context\";\n    }\n    var E = Symbol.for(\"react.client.reference\");\n    function x(a) {\n      if (a == null)\n        return null;\n      if (typeof a == \"function\")\n        return a.$$typeof === E ? null : a.displayName || a.name || null;\n      if (typeof a == \"string\")\n        return a;\n      switch (a) {\n        case n:\n          return \"Fragment\";\n        case t:\n          return \"Portal\";\n        case i:\n          return \"Profiler\";\n        case c:\n          return \"StrictMode\";\n        case f:\n          return \"Suspense\";\n        case h:\n          return \"SuspenseList\";\n        case A:\n          return \"Cache\";\n      }\n      if (typeof a == \"object\")\n        switch (typeof a.tag == \"number\" && N(\"Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.\"), a.$$typeof) {\n          case l: {\n            var $ = a;\n            return g($._context) + \".Provider\";\n          }\n          case p:\n            var S = a;\n            return g(S) + \".Consumer\";\n          case o:\n            return null;\n          case u:\n            return Te(a, a.render, \"ForwardRef\");\n          case _:\n            var q = a.displayName || null;\n            return q !== null ? q : x(a.type) || \"Memo\";\n          case M: {\n            var V = a, X = V._payload, te = V._init;\n            try {\n              return x(te(X));\n            } catch {\n              return null;\n            }\n          }\n        }\n      return null;\n    }\n    var T = Object.prototype.hasOwnProperty, m = Object.assign;\n    function L(a) {\n      {\n        var $ = typeof Symbol == \"function\" && Symbol.toStringTag, S = $ && a[Symbol.toStringTag] || a.constructor.name || \"Object\";\n        return S;\n      }\n    }\n    function s(a) {\n      try {\n        return v(a), !1;\n      } catch {\n        return !0;\n      }\n    }\n    function v(a) {\n      return \"\" + a;\n    }\n    function C(a) {\n      if (s(a))\n        return N(\"The provided key is an unsupported type %s. This value must be coerced to a string before using it here.\", L(a)), v(a);\n    }\n    var O = Symbol.for(\"react.client.reference\");\n    function R(a) {\n      return !!(typeof a == \"string\" || typeof a == \"function\" || a === n || a === i || ge || a === c || a === f || a === h || me || a === F || ve || a === A || pe || typeof a == \"object\" && a !== null && (a.$$typeof === M || a.$$typeof === _ || a.$$typeof === p || a.$$typeof === l || ye || a.$$typeof === u || // This needs to include all possible module reference object\n      // types supported by any Flight configuration anywhere since\n      // we don't know which Flight build this will end up being used\n      // with.\n      a.$$typeof === O || a.getModuleId !== void 0));\n    }\n    var P = Array.isArray;\n    function D(a) {\n      return P(a);\n    }\n    var I = 0, U, G, B, re, b, ie, Oe;\n    function Ye() {\n    }\n    Ye.__reactDisabledLog = !0;\n    function qn() {\n      {\n        if (I === 0) {\n          U = console.log, G = console.info, B = console.warn, re = console.error, b = console.group, ie = console.groupCollapsed, Oe = console.groupEnd;\n          var a = {\n            configurable: !0,\n            enumerable: !0,\n            value: Ye,\n            writable: !0\n          };\n          Object.defineProperties(console, {\n            info: a,\n            log: a,\n            warn: a,\n            error: a,\n            group: a,\n            groupCollapsed: a,\n            groupEnd: a\n          });\n        }\n        I++;\n      }\n    }\n    function Yn() {\n      {\n        if (I--, I === 0) {\n          var a = {\n            configurable: !0,\n            enumerable: !0,\n            writable: !0\n          };\n          Object.defineProperties(console, {\n            log: m({}, a, {\n              value: U\n            }),\n            info: m({}, a, {\n              value: G\n            }),\n            warn: m({}, a, {\n              value: B\n            }),\n            error: m({}, a, {\n              value: re\n            }),\n            group: m({}, a, {\n              value: b\n            }),\n            groupCollapsed: m({}, a, {\n              value: ie\n            }),\n            groupEnd: m({}, a, {\n              value: Oe\n            })\n          });\n        }\n        I < 0 && N(\"disabledDepth fell below zero. This is a bug in React. Please file an issue.\");\n      }\n    }\n    var xr = w.ReactCurrentDispatcher, _r;\n    function Je(a, $) {\n      {\n        if (_r === void 0)\n          try {\n            throw Error();\n          } catch (q) {\n            var S = q.stack.trim().match(/\\n( *(at )?)/);\n            _r = S && S[1] || \"\";\n          }\n        return `\n` + _r + a;\n      }\n    }\n    var Er = !1, Xe;\n    {\n      var Gn = typeof WeakMap == \"function\" ? WeakMap : Map;\n      Xe = new Gn();\n    }\n    function nt(a, $) {\n      if (!a || Er)\n        return \"\";\n      {\n        var S = Xe.get(a);\n        if (S !== void 0)\n          return S;\n      }\n      Er = !0;\n      var q = Error.prepareStackTrace;\n      Error.prepareStackTrace = void 0;\n      var V;\n      V = xr.current, xr.current = null, qn();\n      var X = {\n        DetermineComponentFrameRoot: function() {\n          var Ae;\n          try {\n            if ($) {\n              var Re = function() {\n                throw Error();\n              };\n              if (Object.defineProperty(Re.prototype, \"props\", {\n                set: function() {\n                  throw Error();\n                }\n              }), typeof Reflect == \"object\" && Reflect.construct) {\n                try {\n                  Reflect.construct(Re, []);\n                } catch (fe) {\n                  Ae = fe;\n                }\n                Reflect.construct(a, [], Re);\n              } else {\n                try {\n                  Re.call();\n                } catch (fe) {\n                  Ae = fe;\n                }\n                a.call(Re.prototype);\n              }\n            } else {\n              try {\n                throw Error();\n              } catch (fe) {\n                Ae = fe;\n              }\n              var Ge = a();\n              Ge && typeof Ge.catch == \"function\" && Ge.catch(function() {\n              });\n            }\n          } catch (fe) {\n            if (fe && Ae && typeof fe.stack == \"string\")\n              return [fe.stack, Ae.stack];\n          }\n          return [null, null];\n        }\n      };\n      X.DetermineComponentFrameRoot.displayName = \"DetermineComponentFrameRoot\";\n      var te = Object.getOwnPropertyDescriptor(X.DetermineComponentFrameRoot, \"name\");\n      te && te.configurable && Object.defineProperty(\n        X.DetermineComponentFrameRoot,\n        // Configurable properties can be updated even if its writable descriptor\n        // is set to `false`.\n        // $FlowFixMe[cannot-write]\n        \"name\",\n        {\n          value: \"DetermineComponentFrameRoot\"\n        }\n      );\n      try {\n        var ce = X.DetermineComponentFrameRoot(), le = ce[0], ne = ce[1];\n        if (le && ne) {\n          for (var oe = le.split(`\n`), ue = ne.split(`\n`), Z = 0, ee = 0; Z < oe.length && !oe[Z].includes(\"DetermineComponentFrameRoot\"); )\n            Z++;\n          for (; ee < ue.length && !ue[ee].includes(\"DetermineComponentFrameRoot\"); )\n            ee++;\n          if (Z === oe.length || ee === ue.length)\n            for (Z = oe.length - 1, ee = ue.length - 1; Z >= 1 && ee >= 0 && oe[Z] !== ue[ee]; )\n              ee--;\n          for (; Z >= 1 && ee >= 0; Z--, ee--)\n            if (oe[Z] !== ue[ee]) {\n              if (Z !== 1 || ee !== 1)\n                do\n                  if (Z--, ee--, ee < 0 || oe[Z] !== ue[ee]) {\n                    var ae = `\n` + oe[Z].replace(\" at new \", \" at \");\n                    return a.displayName && ae.includes(\"<anonymous>\") && (ae = ae.replace(\"<anonymous>\", a.displayName)), typeof a == \"function\" && Xe.set(a, ae), ae;\n                  }\n                while (Z >= 1 && ee >= 0);\n              break;\n            }\n        }\n      } finally {\n        Er = !1, xr.current = V, Yn(), Error.prepareStackTrace = q;\n      }\n      var Ce = a ? a.displayName || a.name : \"\", Se = Ce ? Je(Ce) : \"\";\n      return typeof a == \"function\" && Xe.set(a, Se), Se;\n    }\n    function Wn(a, $) {\n      return nt(a, !1);\n    }\n    function kn(a) {\n      var $ = a.prototype;\n      return !!($ && $.isReactComponent);\n    }\n    function wr(a, $) {\n      if (a == null)\n        return \"\";\n      if (typeof a == \"function\")\n        return nt(a, kn(a));\n      if (typeof a == \"string\")\n        return Je(a);\n      switch (a) {\n        case f:\n          return Je(\"Suspense\");\n        case h:\n          return Je(\"SuspenseList\");\n      }\n      if (typeof a == \"object\")\n        switch (a.$$typeof) {\n          case u:\n            return Wn(a.render);\n          case _:\n            return wr(a.type, $);\n          case M: {\n            var S = a, q = S._payload, V = S._init;\n            try {\n              return wr(V(q), $);\n            } catch {\n            }\n          }\n        }\n      return \"\";\n    }\n    var Ze = w.ReactCurrentOwner, at = w.ReactDebugCurrentFrame, zn = Symbol.for(\"react.client.reference\"), it, Tr;\n    Tr = {};\n    function Kn(a) {\n      if (T.call(a, \"ref\")) {\n        var $ = Object.getOwnPropertyDescriptor(a, \"ref\").get;\n        if ($ && $.isReactWarning)\n          return !1;\n      }\n      return a.ref !== void 0;\n    }\n    function Hn(a) {\n      if (T.call(a, \"key\")) {\n        var $ = Object.getOwnPropertyDescriptor(a, \"key\").get;\n        if ($ && $.isReactWarning)\n          return !1;\n      }\n      return a.key !== void 0;\n    }\n    function Vn(a, $) {\n      {\n        var S = function() {\n          it || (it = !0, N(\"%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)\", $));\n        };\n        S.isReactWarning = !0, Object.defineProperty(a, \"key\", {\n          get: S,\n          configurable: !0\n        });\n      }\n    }\n    function Jn() {\n      {\n        var a = x(this.type);\n        Tr[a] || (Tr[a] = !0, N(\"Accessing element.ref is no longer supported. ref is now a regular prop. It will be removed from the JSX Element type in a future release.\"));\n        var $ = this.props.ref;\n        return $ !== void 0 ? $ : null;\n      }\n    }\n    function Xn(a, $, S, q, V, X, te) {\n      var ce;\n      {\n        var le = te.ref;\n        ce = le !== void 0 ? le : null;\n      }\n      var ne;\n      return ne = {\n        // This tag allows us to uniquely identify this as a React Element\n        $$typeof: r,\n        // Built-in properties that belong on the element\n        type: a,\n        key: $,\n        props: te,\n        // Record the component responsible for creating this element.\n        _owner: X\n      }, ce !== null ? Object.defineProperty(ne, \"ref\", {\n        enumerable: !1,\n        get: Jn\n      }) : Object.defineProperty(ne, \"ref\", {\n        enumerable: !1,\n        value: null\n      }), ne._store = {}, Object.defineProperty(ne._store, \"validated\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: !1\n      }), Object.defineProperty(ne, \"_debugInfo\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: null\n      }), Object.freeze && (Object.freeze(ne.props), Object.freeze(ne)), ne;\n    }\n    function Zn(a, $, S, q, V) {\n      {\n        var X = !1;\n        return st(a, $, S, X, q, V);\n      }\n    }\n    function Qn(a, $, S, q, V) {\n      {\n        var X = !0;\n        return st(a, $, S, X, q, V);\n      }\n    }\n    var ot = {};\n    function st(a, $, S, q, V, X) {\n      {\n        if (R(a)) {\n          var le = $.children;\n          if (le !== void 0)\n            if (q)\n              if (D(le)) {\n                for (var ne = 0; ne < le.length; ne++)\n                  ct(le[ne], a);\n                Object.freeze && Object.freeze(le);\n              } else\n                N(\"React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.\");\n            else\n              ct(le, a);\n        } else {\n          var te = \"\";\n          (a === void 0 || typeof a == \"object\" && a !== null && Object.keys(a).length === 0) && (te += \" You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.\");\n          var ce;\n          a === null ? ce = \"null\" : D(a) ? ce = \"array\" : a !== void 0 && a.$$typeof === r ? (ce = \"<\" + (x(a.type) || \"Unknown\") + \" />\", te = \" Did you accidentally export a JSX literal instead of a component?\") : ce = typeof a, N(\"React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s\", ce, te);\n        }\n        if (T.call($, \"key\")) {\n          var oe = x(a), ue = Object.keys($).filter(function(ia) {\n            return ia !== \"key\";\n          }), Z = ue.length > 0 ? \"{key: someKey, \" + ue.join(\": ..., \") + \": ...}\" : \"{key: someKey}\";\n          if (!ot[oe + Z]) {\n            var ee = ue.length > 0 ? \"{\" + ue.join(\": ..., \") + \": ...}\" : \"{}\";\n            N(`A props object containing a \"key\" prop is being spread into JSX:\n  let props = %s;\n  <%s {...props} />\nReact keys must be passed directly to JSX without using spread:\n  let props = %s;\n  <%s key={someKey} {...props} />`, Z, oe, ee, oe), ot[oe + Z] = !0;\n          }\n        }\n        var ae, Ce = {}, Se = null, Ae = null;\n        S !== void 0 && (C(S), Se = \"\" + S), Hn($) && (C($.key), Se = \"\" + $.key), Kn($);\n        for (ae in $)\n          T.call($, ae) && // Skip over reserved prop names\n          ae !== \"key\" && _e && (Ce[ae] = $[ae]);\n        if (a && a.defaultProps) {\n          var Re = a.defaultProps;\n          for (ae in Re)\n            Ce[ae] === void 0 && (Ce[ae] = Re[ae]);\n        }\n        if (Se || !_e) {\n          var Ge = typeof a == \"function\" ? a.displayName || a.name || \"Unknown\" : a;\n          Se && Vn(Ce, Ge);\n        }\n        var fe = Xn(a, Se, Ae, X, V, Ze.current, Ce);\n        return a === n && ta(fe), fe;\n      }\n    }\n    function ea() {\n      {\n        if (Ze.current) {\n          var a = x(Ze.current.type);\n          if (a)\n            return `\n\nCheck the render method of \\`` + a + \"`.\";\n        }\n        return \"\";\n      }\n    }\n    function ct(a, $) {\n      {\n        if (typeof a != \"object\" || !a)\n          return;\n        if (a.$$typeof !== zn)\n          if (D(a))\n            for (var S = 0; S < a.length; S++) {\n              var q = a[S];\n              Cr(q) && ut(q, $);\n            }\n          else if (Cr(a))\n            a._store && (a._store.validated = !0);\n          else {\n            var V = Q(a);\n            if (typeof V == \"function\" && V !== a.entries)\n              for (var X = V.call(a), te; !(te = X.next()).done; )\n                Cr(te.value) && ut(te.value, $);\n          }\n      }\n    }\n    function Cr(a) {\n      return typeof a == \"object\" && a !== null && a.$$typeof === r;\n    }\n    var lt = {};\n    function ut(a, $) {\n      {\n        if (!a._store || a._store.validated || a.key != null)\n          return;\n        a._store.validated = !0;\n        var S = ra($);\n        if (lt[S])\n          return;\n        lt[S] = !0;\n        var q = \"\";\n        a && a._owner && a._owner !== Ze.current && (q = \" It was passed a child from \" + x(a._owner.type) + \".\"), Qe(a), N('Each child in a list should have a unique \"key\" prop.%s%s See https://react.dev/link/warning-keys for more information.', S, q), Qe(null);\n      }\n    }\n    function Qe(a) {\n      if (a) {\n        var $ = a._owner, S = wr(a.type, $ ? $.type : null);\n        at.setExtraStackFrame(S);\n      } else\n        at.setExtraStackFrame(null);\n    }\n    function ra(a) {\n      {\n        var $ = ea();\n        if (!$) {\n          var S = x(a);\n          S && ($ = `\n\nCheck the top-level render call using <` + S + \">.\");\n        }\n        return $;\n      }\n    }\n    function ta(a) {\n      for (var $ = Object.keys(a.props), S = 0; S < $.length; S++) {\n        var q = $[S];\n        if (q !== \"children\" && q !== \"key\") {\n          Qe(a), N(\"Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.\", q), Qe(null);\n          break;\n        }\n      }\n    }\n    var na = Zn, aa = Qn;\n    We.Fragment = n, We.jsx = na, We.jsxs = aa;\n  }()), We;\n}\nvar ke = {}, dt;\nfunction da() {\n  if (dt)\n    return ke;\n  dt = 1;\n  var e = (react__WEBPACK_IMPORTED_MODULE_0___default()), r = Symbol.for(\"react.element\"), t = Symbol.for(\"react.fragment\"), n = Object.prototype.hasOwnProperty, c = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner;\n  function i(l, o, p) {\n    var u = {}, f = null;\n    p !== void 0 && (f = \"\" + p), o.key !== void 0 && (f = \"\" + o.key);\n    for (h in o)\n      n.call(o, h) && h !== \"key\" && (u[h] = o[h]);\n    if (l && l.defaultProps)\n      for (h in o = l.defaultProps, o)\n        u[h] === void 0 && (u[h] = o[h]);\n    var h = u.ref;\n    return { $$typeof: r, type: l, key: f, ref: h !== void 0 ? h : null, props: u, _owner: c.current };\n  }\n  return ke.Fragment = t, ke.jsx = i, ke.jsxs = i, ke;\n}\nse.env.NODE_ENV === \"production\" ? Nr.exports = da() : Nr.exports = fa();\nvar j = Nr.exports, Ur = { exports: {} }, Sr, vt;\nfunction zr() {\n  if (vt)\n    return Sr;\n  vt = 1;\n  var e = \"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED\";\n  return Sr = e, Sr;\n}\nvar Rr, pt;\nfunction va() {\n  if (pt)\n    return Rr;\n  pt = 1;\n  var e = zr();\n  function r() {\n  }\n  function t() {\n  }\n  return t.resetWarningCache = r, Rr = function() {\n    function n(l, o, p, u, f, h) {\n      if (h !== e) {\n        var _ = new Error(\n          \"Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types\"\n        );\n        throw _.name = \"Invariant Violation\", _;\n      }\n    }\n    n.isRequired = n;\n    function c() {\n      return n;\n    }\n    var i = {\n      array: n,\n      bigint: n,\n      bool: n,\n      func: n,\n      number: n,\n      object: n,\n      string: n,\n      symbol: n,\n      any: n,\n      arrayOf: c,\n      element: n,\n      elementType: n,\n      instanceOf: c,\n      node: n,\n      objectOf: c,\n      oneOf: c,\n      oneOfType: c,\n      shape: c,\n      exact: c,\n      checkPropTypes: t,\n      resetWarningCache: r\n    };\n    return i.PropTypes = i, i;\n  }, Rr;\n}\nvar tr = { exports: {} }, W = {}, yt;\nfunction pa() {\n  return yt || (yt = 1, se.env.NODE_ENV !== \"production\" && function() {\n    var e = typeof Symbol == \"function\" && Symbol.for, r = e ? Symbol.for(\"react.element\") : 60103, t = e ? Symbol.for(\"react.portal\") : 60106, n = e ? Symbol.for(\"react.fragment\") : 60107, c = e ? Symbol.for(\"react.strict_mode\") : 60108, i = e ? Symbol.for(\"react.profiler\") : 60114, l = e ? Symbol.for(\"react.provider\") : 60109, o = e ? Symbol.for(\"react.context\") : 60110, p = e ? Symbol.for(\"react.async_mode\") : 60111, u = e ? Symbol.for(\"react.concurrent_mode\") : 60111, f = e ? Symbol.for(\"react.forward_ref\") : 60112, h = e ? Symbol.for(\"react.suspense\") : 60113, _ = e ? Symbol.for(\"react.suspense_list\") : 60120, M = e ? Symbol.for(\"react.memo\") : 60115, F = e ? Symbol.for(\"react.lazy\") : 60116, A = e ? Symbol.for(\"react.block\") : 60121, d = e ? Symbol.for(\"react.fundamental\") : 60117, Y = e ? Symbol.for(\"react.responder\") : 60118, Q = e ? Symbol.for(\"react.scope\") : 60119;\n    function w(b) {\n      return typeof b == \"string\" || typeof b == \"function\" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.\n      b === n || b === u || b === i || b === c || b === h || b === _ || typeof b == \"object\" && b !== null && (b.$$typeof === F || b.$$typeof === M || b.$$typeof === l || b.$$typeof === o || b.$$typeof === f || b.$$typeof === d || b.$$typeof === Y || b.$$typeof === Q || b.$$typeof === A);\n    }\n    function N(b) {\n      if (typeof b == \"object\" && b !== null) {\n        var ie = b.$$typeof;\n        switch (ie) {\n          case r:\n            var Oe = b.type;\n            switch (Oe) {\n              case p:\n              case u:\n              case n:\n              case i:\n              case c:\n              case h:\n                return Oe;\n              default:\n                var Ye = Oe && Oe.$$typeof;\n                switch (Ye) {\n                  case o:\n                  case f:\n                  case F:\n                  case M:\n                  case l:\n                    return Ye;\n                  default:\n                    return ie;\n                }\n            }\n          case t:\n            return ie;\n        }\n      }\n    }\n    var y = p, ve = u, pe = o, me = l, ye = r, xe = f, _e = n, ge = F, Te = M, g = t, E = i, x = c, T = h, m = !1;\n    function L(b) {\n      return m || (m = !0, console.warn(\"The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.\")), s(b) || N(b) === p;\n    }\n    function s(b) {\n      return N(b) === u;\n    }\n    function v(b) {\n      return N(b) === o;\n    }\n    function C(b) {\n      return N(b) === l;\n    }\n    function O(b) {\n      return typeof b == \"object\" && b !== null && b.$$typeof === r;\n    }\n    function R(b) {\n      return N(b) === f;\n    }\n    function P(b) {\n      return N(b) === n;\n    }\n    function D(b) {\n      return N(b) === F;\n    }\n    function I(b) {\n      return N(b) === M;\n    }\n    function U(b) {\n      return N(b) === t;\n    }\n    function G(b) {\n      return N(b) === i;\n    }\n    function B(b) {\n      return N(b) === c;\n    }\n    function re(b) {\n      return N(b) === h;\n    }\n    W.AsyncMode = y, W.ConcurrentMode = ve, W.ContextConsumer = pe, W.ContextProvider = me, W.Element = ye, W.ForwardRef = xe, W.Fragment = _e, W.Lazy = ge, W.Memo = Te, W.Portal = g, W.Profiler = E, W.StrictMode = x, W.Suspense = T, W.isAsyncMode = L, W.isConcurrentMode = s, W.isContextConsumer = v, W.isContextProvider = C, W.isElement = O, W.isForwardRef = R, W.isFragment = P, W.isLazy = D, W.isMemo = I, W.isPortal = U, W.isProfiler = G, W.isStrictMode = B, W.isSuspense = re, W.isValidElementType = w, W.typeOf = N;\n  }()), W;\n}\nvar k = {};\n/** @license React v16.13.1\n * react-is.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar gt;\nfunction ya() {\n  if (gt)\n    return k;\n  gt = 1;\n  var e = typeof Symbol == \"function\" && Symbol.for, r = e ? Symbol.for(\"react.element\") : 60103, t = e ? Symbol.for(\"react.portal\") : 60106, n = e ? Symbol.for(\"react.fragment\") : 60107, c = e ? Symbol.for(\"react.strict_mode\") : 60108, i = e ? Symbol.for(\"react.profiler\") : 60114, l = e ? Symbol.for(\"react.provider\") : 60109, o = e ? Symbol.for(\"react.context\") : 60110, p = e ? Symbol.for(\"react.async_mode\") : 60111, u = e ? Symbol.for(\"react.concurrent_mode\") : 60111, f = e ? Symbol.for(\"react.forward_ref\") : 60112, h = e ? Symbol.for(\"react.suspense\") : 60113, _ = e ? Symbol.for(\"react.suspense_list\") : 60120, M = e ? Symbol.for(\"react.memo\") : 60115, F = e ? Symbol.for(\"react.lazy\") : 60116, A = e ? Symbol.for(\"react.block\") : 60121, d = e ? Symbol.for(\"react.fundamental\") : 60117, Y = e ? Symbol.for(\"react.responder\") : 60118, Q = e ? Symbol.for(\"react.scope\") : 60119;\n  function w(y) {\n    if (typeof y == \"object\" && y !== null) {\n      var ve = y.$$typeof;\n      switch (ve) {\n        case r:\n          switch (y = y.type, y) {\n            case p:\n            case u:\n            case n:\n            case i:\n            case c:\n            case h:\n              return y;\n            default:\n              switch (y = y && y.$$typeof, y) {\n                case o:\n                case f:\n                case F:\n                case M:\n                case l:\n                  return y;\n                default:\n                  return ve;\n              }\n          }\n        case t:\n          return ve;\n      }\n    }\n  }\n  function N(y) {\n    return w(y) === u;\n  }\n  return k.AsyncMode = p, k.ConcurrentMode = u, k.ContextConsumer = o, k.ContextProvider = l, k.Element = r, k.ForwardRef = f, k.Fragment = n, k.Lazy = F, k.Memo = M, k.Portal = t, k.Profiler = i, k.StrictMode = c, k.Suspense = h, k.isAsyncMode = function(y) {\n    return N(y) || w(y) === p;\n  }, k.isConcurrentMode = N, k.isContextConsumer = function(y) {\n    return w(y) === o;\n  }, k.isContextProvider = function(y) {\n    return w(y) === l;\n  }, k.isElement = function(y) {\n    return typeof y == \"object\" && y !== null && y.$$typeof === r;\n  }, k.isForwardRef = function(y) {\n    return w(y) === f;\n  }, k.isFragment = function(y) {\n    return w(y) === n;\n  }, k.isLazy = function(y) {\n    return w(y) === F;\n  }, k.isMemo = function(y) {\n    return w(y) === M;\n  }, k.isPortal = function(y) {\n    return w(y) === t;\n  }, k.isProfiler = function(y) {\n    return w(y) === i;\n  }, k.isStrictMode = function(y) {\n    return w(y) === c;\n  }, k.isSuspense = function(y) {\n    return w(y) === h;\n  }, k.isValidElementType = function(y) {\n    return typeof y == \"string\" || typeof y == \"function\" || y === n || y === u || y === i || y === c || y === h || y === _ || typeof y == \"object\" && y !== null && (y.$$typeof === F || y.$$typeof === M || y.$$typeof === l || y.$$typeof === o || y.$$typeof === f || y.$$typeof === d || y.$$typeof === Y || y.$$typeof === Q || y.$$typeof === A);\n  }, k.typeOf = w, k;\n}\nvar ht;\nfunction fn() {\n  return ht || (ht = 1, se.env.NODE_ENV === \"production\" ? tr.exports = ya() : tr.exports = pa()), tr.exports;\n}\n/*\nobject-assign\n(c) Sindre Sorhus\n@license MIT\n*/\nvar Or, bt;\nfunction ga() {\n  if (bt)\n    return Or;\n  bt = 1;\n  var e = Object.getOwnPropertySymbols, r = Object.prototype.hasOwnProperty, t = Object.prototype.propertyIsEnumerable;\n  function n(i) {\n    if (i == null)\n      throw new TypeError(\"Object.assign cannot be called with null or undefined\");\n    return Object(i);\n  }\n  function c() {\n    try {\n      if (!Object.assign)\n        return !1;\n      var i = new String(\"abc\");\n      if (i[5] = \"de\", Object.getOwnPropertyNames(i)[0] === \"5\")\n        return !1;\n      for (var l = {}, o = 0; o < 10; o++)\n        l[\"_\" + String.fromCharCode(o)] = o;\n      var p = Object.getOwnPropertyNames(l).map(function(f) {\n        return l[f];\n      });\n      if (p.join(\"\") !== \"0123456789\")\n        return !1;\n      var u = {};\n      return \"abcdefghijklmnopqrst\".split(\"\").forEach(function(f) {\n        u[f] = f;\n      }), Object.keys(Object.assign({}, u)).join(\"\") === \"abcdefghijklmnopqrst\";\n    } catch {\n      return !1;\n    }\n  }\n  return Or = c() ? Object.assign : function(i, l) {\n    for (var o, p = n(i), u, f = 1; f < arguments.length; f++) {\n      o = Object(arguments[f]);\n      for (var h in o)\n        r.call(o, h) && (p[h] = o[h]);\n      if (e) {\n        u = e(o);\n        for (var _ = 0; _ < u.length; _++)\n          t.call(o, u[_]) && (p[u[_]] = o[u[_]]);\n      }\n    }\n    return p;\n  }, Or;\n}\nvar Ar, $t;\nfunction dn() {\n  return $t || ($t = 1, Ar = Function.call.bind(Object.prototype.hasOwnProperty)), Ar;\n}\nvar jr, mt;\nfunction ha() {\n  if (mt)\n    return jr;\n  mt = 1;\n  var e = function() {\n  };\n  if (se.env.NODE_ENV !== \"production\") {\n    var r = zr(), t = {}, n = dn();\n    e = function(i) {\n      var l = \"Warning: \" + i;\n      typeof console < \"u\" && console.error(l);\n      try {\n        throw new Error(l);\n      } catch {\n      }\n    };\n  }\n  function c(i, l, o, p, u) {\n    if (se.env.NODE_ENV !== \"production\") {\n      for (var f in i)\n        if (n(i, f)) {\n          var h;\n          try {\n            if (typeof i[f] != \"function\") {\n              var _ = Error(\n                (p || \"React class\") + \": \" + o + \" type `\" + f + \"` is invalid; it must be a function, usually from the `prop-types` package, but received `\" + typeof i[f] + \"`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.\"\n              );\n              throw _.name = \"Invariant Violation\", _;\n            }\n            h = i[f](l, f, p, o, null, r);\n          } catch (F) {\n            h = F;\n          }\n          if (h && !(h instanceof Error) && e(\n            (p || \"React class\") + \": type specification of \" + o + \" `\" + f + \"` is invalid; the type checker function must return `null` or an `Error` but returned a \" + typeof h + \". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).\"\n          ), h instanceof Error && !(h.message in t)) {\n            t[h.message] = !0;\n            var M = u ? u() : \"\";\n            e(\n              \"Failed \" + o + \" type: \" + h.message + (M ?? \"\")\n            );\n          }\n        }\n    }\n  }\n  return c.resetWarningCache = function() {\n    se.env.NODE_ENV !== \"production\" && (t = {});\n  }, jr = c, jr;\n}\nvar Pr, xt;\nfunction ba() {\n  if (xt)\n    return Pr;\n  xt = 1;\n  var e = fn(), r = ga(), t = zr(), n = dn(), c = ha(), i = function() {\n  };\n  se.env.NODE_ENV !== \"production\" && (i = function(o) {\n    var p = \"Warning: \" + o;\n    typeof console < \"u\" && console.error(p);\n    try {\n      throw new Error(p);\n    } catch {\n    }\n  });\n  function l() {\n    return null;\n  }\n  return Pr = function(o, p) {\n    var u = typeof Symbol == \"function\" && Symbol.iterator, f = \"@@iterator\";\n    function h(s) {\n      var v = s && (u && s[u] || s[f]);\n      if (typeof v == \"function\")\n        return v;\n    }\n    var _ = \"<<anonymous>>\", M = {\n      array: Y(\"array\"),\n      bigint: Y(\"bigint\"),\n      bool: Y(\"boolean\"),\n      func: Y(\"function\"),\n      number: Y(\"number\"),\n      object: Y(\"object\"),\n      string: Y(\"string\"),\n      symbol: Y(\"symbol\"),\n      any: Q(),\n      arrayOf: w,\n      element: N(),\n      elementType: y(),\n      instanceOf: ve,\n      node: xe(),\n      objectOf: me,\n      oneOf: pe,\n      oneOfType: ye,\n      shape: ge,\n      exact: Te\n    };\n    function F(s, v) {\n      return s === v ? s !== 0 || 1 / s === 1 / v : s !== s && v !== v;\n    }\n    function A(s, v) {\n      this.message = s, this.data = v && typeof v == \"object\" ? v : {}, this.stack = \"\";\n    }\n    A.prototype = Error.prototype;\n    function d(s) {\n      if (se.env.NODE_ENV !== \"production\")\n        var v = {}, C = 0;\n      function O(P, D, I, U, G, B, re) {\n        if (U = U || _, B = B || I, re !== t) {\n          if (p) {\n            var b = new Error(\n              \"Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types\"\n            );\n            throw b.name = \"Invariant Violation\", b;\n          } else if (se.env.NODE_ENV !== \"production\" && typeof console < \"u\") {\n            var ie = U + \":\" + I;\n            !v[ie] && // Avoid spamming the console because they are often not actionable except for lib authors\n            C < 3 && (i(\n              \"You are manually calling a React.PropTypes validation function for the `\" + B + \"` prop on `\" + U + \"`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details.\"\n            ), v[ie] = !0, C++);\n          }\n        }\n        return D[I] == null ? P ? D[I] === null ? new A(\"The \" + G + \" `\" + B + \"` is marked as required \" + (\"in `\" + U + \"`, but its value is `null`.\")) : new A(\"The \" + G + \" `\" + B + \"` is marked as required in \" + (\"`\" + U + \"`, but its value is `undefined`.\")) : null : s(D, I, U, G, B);\n      }\n      var R = O.bind(null, !1);\n      return R.isRequired = O.bind(null, !0), R;\n    }\n    function Y(s) {\n      function v(C, O, R, P, D, I) {\n        var U = C[O], G = x(U);\n        if (G !== s) {\n          var B = T(U);\n          return new A(\n            \"Invalid \" + P + \" `\" + D + \"` of type \" + (\"`\" + B + \"` supplied to `\" + R + \"`, expected \") + (\"`\" + s + \"`.\"),\n            { expectedType: s }\n          );\n        }\n        return null;\n      }\n      return d(v);\n    }\n    function Q() {\n      return d(l);\n    }\n    function w(s) {\n      function v(C, O, R, P, D) {\n        if (typeof s != \"function\")\n          return new A(\"Property `\" + D + \"` of component `\" + R + \"` has invalid PropType notation inside arrayOf.\");\n        var I = C[O];\n        if (!Array.isArray(I)) {\n          var U = x(I);\n          return new A(\"Invalid \" + P + \" `\" + D + \"` of type \" + (\"`\" + U + \"` supplied to `\" + R + \"`, expected an array.\"));\n        }\n        for (var G = 0; G < I.length; G++) {\n          var B = s(I, G, R, P, D + \"[\" + G + \"]\", t);\n          if (B instanceof Error)\n            return B;\n        }\n        return null;\n      }\n      return d(v);\n    }\n    function N() {\n      function s(v, C, O, R, P) {\n        var D = v[C];\n        if (!o(D)) {\n          var I = x(D);\n          return new A(\"Invalid \" + R + \" `\" + P + \"` of type \" + (\"`\" + I + \"` supplied to `\" + O + \"`, expected a single ReactElement.\"));\n        }\n        return null;\n      }\n      return d(s);\n    }\n    function y() {\n      function s(v, C, O, R, P) {\n        var D = v[C];\n        if (!e.isValidElementType(D)) {\n          var I = x(D);\n          return new A(\"Invalid \" + R + \" `\" + P + \"` of type \" + (\"`\" + I + \"` supplied to `\" + O + \"`, expected a single ReactElement type.\"));\n        }\n        return null;\n      }\n      return d(s);\n    }\n    function ve(s) {\n      function v(C, O, R, P, D) {\n        if (!(C[O] instanceof s)) {\n          var I = s.name || _, U = L(C[O]);\n          return new A(\"Invalid \" + P + \" `\" + D + \"` of type \" + (\"`\" + U + \"` supplied to `\" + R + \"`, expected \") + (\"instance of `\" + I + \"`.\"));\n        }\n        return null;\n      }\n      return d(v);\n    }\n    function pe(s) {\n      if (!Array.isArray(s))\n        return se.env.NODE_ENV !== \"production\" && (arguments.length > 1 ? i(\n          \"Invalid arguments supplied to oneOf, expected an array, got \" + arguments.length + \" arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).\"\n        ) : i(\"Invalid argument supplied to oneOf, expected an array.\")), l;\n      function v(C, O, R, P, D) {\n        for (var I = C[O], U = 0; U < s.length; U++)\n          if (F(I, s[U]))\n            return null;\n        var G = JSON.stringify(s, function(re, b) {\n          var ie = T(b);\n          return ie === \"symbol\" ? String(b) : b;\n        });\n        return new A(\"Invalid \" + P + \" `\" + D + \"` of value `\" + String(I) + \"` \" + (\"supplied to `\" + R + \"`, expected one of \" + G + \".\"));\n      }\n      return d(v);\n    }\n    function me(s) {\n      function v(C, O, R, P, D) {\n        if (typeof s != \"function\")\n          return new A(\"Property `\" + D + \"` of component `\" + R + \"` has invalid PropType notation inside objectOf.\");\n        var I = C[O], U = x(I);\n        if (U !== \"object\")\n          return new A(\"Invalid \" + P + \" `\" + D + \"` of type \" + (\"`\" + U + \"` supplied to `\" + R + \"`, expected an object.\"));\n        for (var G in I)\n          if (n(I, G)) {\n            var B = s(I, G, R, P, D + \".\" + G, t);\n            if (B instanceof Error)\n              return B;\n          }\n        return null;\n      }\n      return d(v);\n    }\n    function ye(s) {\n      if (!Array.isArray(s))\n        return se.env.NODE_ENV !== \"production\" && i(\"Invalid argument supplied to oneOfType, expected an instance of array.\"), l;\n      for (var v = 0; v < s.length; v++) {\n        var C = s[v];\n        if (typeof C != \"function\")\n          return i(\n            \"Invalid argument supplied to oneOfType. Expected an array of check functions, but received \" + m(C) + \" at index \" + v + \".\"\n          ), l;\n      }\n      function O(R, P, D, I, U) {\n        for (var G = [], B = 0; B < s.length; B++) {\n          var re = s[B], b = re(R, P, D, I, U, t);\n          if (b == null)\n            return null;\n          b.data && n(b.data, \"expectedType\") && G.push(b.data.expectedType);\n        }\n        var ie = G.length > 0 ? \", expected one of type [\" + G.join(\", \") + \"]\" : \"\";\n        return new A(\"Invalid \" + I + \" `\" + U + \"` supplied to \" + (\"`\" + D + \"`\" + ie + \".\"));\n      }\n      return d(O);\n    }\n    function xe() {\n      function s(v, C, O, R, P) {\n        return g(v[C]) ? null : new A(\"Invalid \" + R + \" `\" + P + \"` supplied to \" + (\"`\" + O + \"`, expected a ReactNode.\"));\n      }\n      return d(s);\n    }\n    function _e(s, v, C, O, R) {\n      return new A(\n        (s || \"React class\") + \": \" + v + \" type `\" + C + \".\" + O + \"` is invalid; it must be a function, usually from the `prop-types` package, but received `\" + R + \"`.\"\n      );\n    }\n    function ge(s) {\n      function v(C, O, R, P, D) {\n        var I = C[O], U = x(I);\n        if (U !== \"object\")\n          return new A(\"Invalid \" + P + \" `\" + D + \"` of type `\" + U + \"` \" + (\"supplied to `\" + R + \"`, expected `object`.\"));\n        for (var G in s) {\n          var B = s[G];\n          if (typeof B != \"function\")\n            return _e(R, P, D, G, T(B));\n          var re = B(I, G, R, P, D + \".\" + G, t);\n          if (re)\n            return re;\n        }\n        return null;\n      }\n      return d(v);\n    }\n    function Te(s) {\n      function v(C, O, R, P, D) {\n        var I = C[O], U = x(I);\n        if (U !== \"object\")\n          return new A(\"Invalid \" + P + \" `\" + D + \"` of type `\" + U + \"` \" + (\"supplied to `\" + R + \"`, expected `object`.\"));\n        var G = r({}, C[O], s);\n        for (var B in G) {\n          var re = s[B];\n          if (n(s, B) && typeof re != \"function\")\n            return _e(R, P, D, B, T(re));\n          if (!re)\n            return new A(\n              \"Invalid \" + P + \" `\" + D + \"` key `\" + B + \"` supplied to `\" + R + \"`.\\nBad object: \" + JSON.stringify(C[O], null, \"  \") + `\nValid keys: ` + JSON.stringify(Object.keys(s), null, \"  \")\n            );\n          var b = re(I, B, R, P, D + \".\" + B, t);\n          if (b)\n            return b;\n        }\n        return null;\n      }\n      return d(v);\n    }\n    function g(s) {\n      switch (typeof s) {\n        case \"number\":\n        case \"string\":\n        case \"undefined\":\n          return !0;\n        case \"boolean\":\n          return !s;\n        case \"object\":\n          if (Array.isArray(s))\n            return s.every(g);\n          if (s === null || o(s))\n            return !0;\n          var v = h(s);\n          if (v) {\n            var C = v.call(s), O;\n            if (v !== s.entries) {\n              for (; !(O = C.next()).done; )\n                if (!g(O.value))\n                  return !1;\n            } else\n              for (; !(O = C.next()).done; ) {\n                var R = O.value;\n                if (R && !g(R[1]))\n                  return !1;\n              }\n          } else\n            return !1;\n          return !0;\n        default:\n          return !1;\n      }\n    }\n    function E(s, v) {\n      return s === \"symbol\" ? !0 : v ? v[\"@@toStringTag\"] === \"Symbol\" || typeof Symbol == \"function\" && v instanceof Symbol : !1;\n    }\n    function x(s) {\n      var v = typeof s;\n      return Array.isArray(s) ? \"array\" : s instanceof RegExp ? \"object\" : E(v, s) ? \"symbol\" : v;\n    }\n    function T(s) {\n      if (typeof s > \"u\" || s === null)\n        return \"\" + s;\n      var v = x(s);\n      if (v === \"object\") {\n        if (s instanceof Date)\n          return \"date\";\n        if (s instanceof RegExp)\n          return \"regexp\";\n      }\n      return v;\n    }\n    function m(s) {\n      var v = T(s);\n      switch (v) {\n        case \"array\":\n        case \"object\":\n          return \"an \" + v;\n        case \"boolean\":\n        case \"date\":\n        case \"regexp\":\n          return \"a \" + v;\n        default:\n          return v;\n      }\n    }\n    function L(s) {\n      return !s.constructor || !s.constructor.name ? _ : s.constructor.name;\n    }\n    return M.checkPropTypes = c, M.resetWarningCache = c.resetWarningCache, M.PropTypes = M, M;\n  }, Pr;\n}\nif (se.env.NODE_ENV !== \"production\") {\n  var $a = fn(), ma = !0;\n  Ur.exports = ba()($a.isElement, ma);\n} else\n  Ur.exports = va()();\nvar xa = Ur.exports;\nconst ze = /* @__PURE__ */ kr(xa);\nfunction _a() {\n  this.__data__ = [], this.size = 0;\n}\nvar Ea = _a;\nfunction wa(e, r) {\n  return e === r || e !== e && r !== r;\n}\nvar Kr = wa, Ta = Kr;\nfunction Ca(e, r) {\n  for (var t = e.length; t--; )\n    if (Ta(e[t][0], r))\n      return t;\n  return -1;\n}\nvar dr = Ca, Sa = dr, Ra = Array.prototype, Oa = Ra.splice;\nfunction Aa(e) {\n  var r = this.__data__, t = Sa(r, e);\n  if (t < 0)\n    return !1;\n  var n = r.length - 1;\n  return t == n ? r.pop() : Oa.call(r, t, 1), --this.size, !0;\n}\nvar ja = Aa, Pa = dr;\nfunction Ia(e) {\n  var r = this.__data__, t = Pa(r, e);\n  return t < 0 ? void 0 : r[t][1];\n}\nvar Da = Ia, Ma = dr;\nfunction La(e) {\n  return Ma(this.__data__, e) > -1;\n}\nvar Fa = La, Na = dr;\nfunction Ua(e, r) {\n  var t = this.__data__, n = Na(t, e);\n  return n < 0 ? (++this.size, t.push([e, r])) : t[n][1] = r, this;\n}\nvar Ba = Ua, qa = Ea, Ya = ja, Ga = Da, Wa = Fa, ka = Ba;\nfunction Le(e) {\n  var r = -1, t = e == null ? 0 : e.length;\n  for (this.clear(); ++r < t; ) {\n    var n = e[r];\n    this.set(n[0], n[1]);\n  }\n}\nLe.prototype.clear = qa;\nLe.prototype.delete = Ya;\nLe.prototype.get = Ga;\nLe.prototype.has = Wa;\nLe.prototype.set = ka;\nvar vr = Le, za = vr;\nfunction Ka() {\n  this.__data__ = new za(), this.size = 0;\n}\nvar Ha = Ka;\nfunction Va(e) {\n  var r = this.__data__, t = r.delete(e);\n  return this.size = r.size, t;\n}\nvar Ja = Va;\nfunction Xa(e) {\n  return this.__data__.get(e);\n}\nvar Za = Xa;\nfunction Qa(e) {\n  return this.__data__.has(e);\n}\nvar ei = Qa, ri = typeof rr == \"object\" && rr && rr.Object === Object && rr, vn = ri, ti = vn, ni = typeof self == \"object\" && self && self.Object === Object && self, ai = ti || ni || Function(\"return this\")(), $e = ai, ii = $e, oi = ii.Symbol, pr = oi, _t = pr, pn = Object.prototype, si = pn.hasOwnProperty, ci = pn.toString, Ke = _t ? _t.toStringTag : void 0;\nfunction li(e) {\n  var r = si.call(e, Ke), t = e[Ke];\n  try {\n    e[Ke] = void 0;\n    var n = !0;\n  } catch {\n  }\n  var c = ci.call(e);\n  return n && (r ? e[Ke] = t : delete e[Ke]), c;\n}\nvar ui = li, fi = Object.prototype, di = fi.toString;\nfunction vi(e) {\n  return di.call(e);\n}\nvar pi = vi, Et = pr, yi = ui, gi = pi, hi = \"[object Null]\", bi = \"[object Undefined]\", wt = Et ? Et.toStringTag : void 0;\nfunction $i(e) {\n  return e == null ? e === void 0 ? bi : hi : wt && wt in Object(e) ? yi(e) : gi(e);\n}\nvar yr = $i;\nfunction mi(e) {\n  var r = typeof e;\n  return e != null && (r == \"object\" || r == \"function\");\n}\nvar Ve = mi, xi = yr, _i = Ve, Ei = \"[object AsyncFunction]\", wi = \"[object Function]\", Ti = \"[object GeneratorFunction]\", Ci = \"[object Proxy]\";\nfunction Si(e) {\n  if (!_i(e))\n    return !1;\n  var r = xi(e);\n  return r == wi || r == Ti || r == Ei || r == Ci;\n}\nvar yn = Si, Ri = $e, Oi = Ri[\"__core-js_shared__\"], Ai = Oi, Ir = Ai, Tt = function() {\n  var e = /[^.]+$/.exec(Ir && Ir.keys && Ir.keys.IE_PROTO || \"\");\n  return e ? \"Symbol(src)_1.\" + e : \"\";\n}();\nfunction ji(e) {\n  return !!Tt && Tt in e;\n}\nvar Pi = ji, Ii = Function.prototype, Di = Ii.toString;\nfunction Mi(e) {\n  if (e != null) {\n    try {\n      return Di.call(e);\n    } catch {\n    }\n    try {\n      return e + \"\";\n    } catch {\n    }\n  }\n  return \"\";\n}\nvar gn = Mi, Li = yn, Fi = Pi, Ni = Ve, Ui = gn, Bi = /[\\\\^$.*+?()[\\]{}|]/g, qi = /^\\[object .+?Constructor\\]$/, Yi = Function.prototype, Gi = Object.prototype, Wi = Yi.toString, ki = Gi.hasOwnProperty, zi = RegExp(\n  \"^\" + Wi.call(ki).replace(Bi, \"\\\\$&\").replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, \"$1.*?\") + \"$\"\n);\nfunction Ki(e) {\n  if (!Ni(e) || Fi(e))\n    return !1;\n  var r = Li(e) ? zi : qi;\n  return r.test(Ui(e));\n}\nvar Hi = Ki;\nfunction Vi(e, r) {\n  return e == null ? void 0 : e[r];\n}\nvar Ji = Vi, Xi = Hi, Zi = Ji;\nfunction Qi(e, r) {\n  var t = Zi(e, r);\n  return Xi(t) ? t : void 0;\n}\nvar Ie = Qi, eo = Ie, ro = $e, to = eo(ro, \"Map\"), Hr = to, no = Ie, ao = no(Object, \"create\"), gr = ao, Ct = gr;\nfunction io() {\n  this.__data__ = Ct ? Ct(null) : {}, this.size = 0;\n}\nvar oo = io;\nfunction so(e) {\n  var r = this.has(e) && delete this.__data__[e];\n  return this.size -= r ? 1 : 0, r;\n}\nvar co = so, lo = gr, uo = \"__lodash_hash_undefined__\", fo = Object.prototype, vo = fo.hasOwnProperty;\nfunction po(e) {\n  var r = this.__data__;\n  if (lo) {\n    var t = r[e];\n    return t === uo ? void 0 : t;\n  }\n  return vo.call(r, e) ? r[e] : void 0;\n}\nvar yo = po, go = gr, ho = Object.prototype, bo = ho.hasOwnProperty;\nfunction $o(e) {\n  var r = this.__data__;\n  return go ? r[e] !== void 0 : bo.call(r, e);\n}\nvar mo = $o, xo = gr, _o = \"__lodash_hash_undefined__\";\nfunction Eo(e, r) {\n  var t = this.__data__;\n  return this.size += this.has(e) ? 0 : 1, t[e] = xo && r === void 0 ? _o : r, this;\n}\nvar wo = Eo, To = oo, Co = co, So = yo, Ro = mo, Oo = wo;\nfunction Fe(e) {\n  var r = -1, t = e == null ? 0 : e.length;\n  for (this.clear(); ++r < t; ) {\n    var n = e[r];\n    this.set(n[0], n[1]);\n  }\n}\nFe.prototype.clear = To;\nFe.prototype.delete = Co;\nFe.prototype.get = So;\nFe.prototype.has = Ro;\nFe.prototype.set = Oo;\nvar Ao = Fe, St = Ao, jo = vr, Po = Hr;\nfunction Io() {\n  this.size = 0, this.__data__ = {\n    hash: new St(),\n    map: new (Po || jo)(),\n    string: new St()\n  };\n}\nvar Do = Io;\nfunction Mo(e) {\n  var r = typeof e;\n  return r == \"string\" || r == \"number\" || r == \"symbol\" || r == \"boolean\" ? e !== \"__proto__\" : e === null;\n}\nvar Lo = Mo, Fo = Lo;\nfunction No(e, r) {\n  var t = e.__data__;\n  return Fo(r) ? t[typeof r == \"string\" ? \"string\" : \"hash\"] : t.map;\n}\nvar hr = No, Uo = hr;\nfunction Bo(e) {\n  var r = Uo(this, e).delete(e);\n  return this.size -= r ? 1 : 0, r;\n}\nvar qo = Bo, Yo = hr;\nfunction Go(e) {\n  return Yo(this, e).get(e);\n}\nvar Wo = Go, ko = hr;\nfunction zo(e) {\n  return ko(this, e).has(e);\n}\nvar Ko = zo, Ho = hr;\nfunction Vo(e, r) {\n  var t = Ho(this, e), n = t.size;\n  return t.set(e, r), this.size += t.size == n ? 0 : 1, this;\n}\nvar Jo = Vo, Xo = Do, Zo = qo, Qo = Wo, es = Ko, rs = Jo;\nfunction Ne(e) {\n  var r = -1, t = e == null ? 0 : e.length;\n  for (this.clear(); ++r < t; ) {\n    var n = e[r];\n    this.set(n[0], n[1]);\n  }\n}\nNe.prototype.clear = Xo;\nNe.prototype.delete = Zo;\nNe.prototype.get = Qo;\nNe.prototype.has = es;\nNe.prototype.set = rs;\nvar hn = Ne, ts = vr, ns = Hr, as = hn, is = 200;\nfunction os(e, r) {\n  var t = this.__data__;\n  if (t instanceof ts) {\n    var n = t.__data__;\n    if (!ns || n.length < is - 1)\n      return n.push([e, r]), this.size = ++t.size, this;\n    t = this.__data__ = new as(n);\n  }\n  return t.set(e, r), this.size = t.size, this;\n}\nvar ss = os, cs = vr, ls = Ha, us = Ja, fs = Za, ds = ei, vs = ss;\nfunction Ue(e) {\n  var r = this.__data__ = new cs(e);\n  this.size = r.size;\n}\nUe.prototype.clear = ls;\nUe.prototype.delete = us;\nUe.prototype.get = fs;\nUe.prototype.has = ds;\nUe.prototype.set = vs;\nvar bn = Ue;\nfunction ps(e, r) {\n  for (var t = -1, n = e == null ? 0 : e.length; ++t < n && r(e[t], t, e) !== !1; )\n    ;\n  return e;\n}\nvar ys = ps, gs = Ie, hs = function() {\n  try {\n    var e = gs(Object, \"defineProperty\");\n    return e({}, \"\", {}), e;\n  } catch {\n  }\n}(), bs = hs, Rt = bs;\nfunction $s(e, r, t) {\n  r == \"__proto__\" && Rt ? Rt(e, r, {\n    configurable: !0,\n    enumerable: !0,\n    value: t,\n    writable: !0\n  }) : e[r] = t;\n}\nvar $n = $s, ms = $n, xs = Kr, _s = Object.prototype, Es = _s.hasOwnProperty;\nfunction ws(e, r, t) {\n  var n = e[r];\n  (!(Es.call(e, r) && xs(n, t)) || t === void 0 && !(r in e)) && ms(e, r, t);\n}\nvar mn = ws, Ts = mn, Cs = $n;\nfunction Ss(e, r, t, n) {\n  var c = !t;\n  t || (t = {});\n  for (var i = -1, l = r.length; ++i < l; ) {\n    var o = r[i], p = n ? n(t[o], e[o], o, t, e) : void 0;\n    p === void 0 && (p = e[o]), c ? Cs(t, o, p) : Ts(t, o, p);\n  }\n  return t;\n}\nvar br = Ss;\nfunction Rs(e, r) {\n  for (var t = -1, n = Array(e); ++t < e; )\n    n[t] = r(t);\n  return n;\n}\nvar Os = Rs;\nfunction As(e) {\n  return e != null && typeof e == \"object\";\n}\nvar Be = As, js = yr, Ps = Be, Is = \"[object Arguments]\";\nfunction Ds(e) {\n  return Ps(e) && js(e) == Is;\n}\nvar Ms = Ds, Ot = Ms, Ls = Be, xn = Object.prototype, Fs = xn.hasOwnProperty, Ns = xn.propertyIsEnumerable, Us = Ot(function() {\n  return arguments;\n}()) ? Ot : function(e) {\n  return Ls(e) && Fs.call(e, \"callee\") && !Ns.call(e, \"callee\");\n}, Bs = Us, qs = Array.isArray, $r = qs, cr = { exports: {} };\nfunction Ys() {\n  return !1;\n}\nvar Gs = Ys;\ncr.exports;\n(function(e, r) {\n  var t = $e, n = Gs, c = r && !r.nodeType && r, i = c && !0 && e && !e.nodeType && e, l = i && i.exports === c, o = l ? t.Buffer : void 0, p = o ? o.isBuffer : void 0, u = p || n;\n  e.exports = u;\n})(cr, cr.exports);\nvar Vr = cr.exports, Ws = 9007199254740991, ks = /^(?:0|[1-9]\\d*)$/;\nfunction zs(e, r) {\n  var t = typeof e;\n  return r = r ?? Ws, !!r && (t == \"number\" || t != \"symbol\" && ks.test(e)) && e > -1 && e % 1 == 0 && e < r;\n}\nvar Ks = zs, Hs = 9007199254740991;\nfunction Vs(e) {\n  return typeof e == \"number\" && e > -1 && e % 1 == 0 && e <= Hs;\n}\nvar _n = Vs, Js = yr, Xs = _n, Zs = Be, Qs = \"[object Arguments]\", ec = \"[object Array]\", rc = \"[object Boolean]\", tc = \"[object Date]\", nc = \"[object Error]\", ac = \"[object Function]\", ic = \"[object Map]\", oc = \"[object Number]\", sc = \"[object Object]\", cc = \"[object RegExp]\", lc = \"[object Set]\", uc = \"[object String]\", fc = \"[object WeakMap]\", dc = \"[object ArrayBuffer]\", vc = \"[object DataView]\", pc = \"[object Float32Array]\", yc = \"[object Float64Array]\", gc = \"[object Int8Array]\", hc = \"[object Int16Array]\", bc = \"[object Int32Array]\", $c = \"[object Uint8Array]\", mc = \"[object Uint8ClampedArray]\", xc = \"[object Uint16Array]\", _c = \"[object Uint32Array]\", H = {};\nH[pc] = H[yc] = H[gc] = H[hc] = H[bc] = H[$c] = H[mc] = H[xc] = H[_c] = !0;\nH[Qs] = H[ec] = H[dc] = H[rc] = H[vc] = H[tc] = H[nc] = H[ac] = H[ic] = H[oc] = H[sc] = H[cc] = H[lc] = H[uc] = H[fc] = !1;\nfunction Ec(e) {\n  return Zs(e) && Xs(e.length) && !!H[Js(e)];\n}\nvar wc = Ec;\nfunction Tc(e) {\n  return function(r) {\n    return e(r);\n  };\n}\nvar Jr = Tc, lr = { exports: {} };\nlr.exports;\n(function(e, r) {\n  var t = vn, n = r && !r.nodeType && r, c = n && !0 && e && !e.nodeType && e, i = c && c.exports === n, l = i && t.process, o = function() {\n    try {\n      var p = c && c.require && c.require(\"util\").types;\n      return p || l && l.binding && l.binding(\"util\");\n    } catch {\n    }\n  }();\n  e.exports = o;\n})(lr, lr.exports);\nvar Xr = lr.exports, Cc = wc, Sc = Jr, At = Xr, jt = At && At.isTypedArray, Rc = jt ? Sc(jt) : Cc, En = Rc, Oc = Os, Ac = Bs, jc = $r, Pc = Vr, Ic = Ks, Dc = En, Mc = Object.prototype, Lc = Mc.hasOwnProperty;\nfunction Fc(e, r) {\n  var t = jc(e), n = !t && Ac(e), c = !t && !n && Pc(e), i = !t && !n && !c && Dc(e), l = t || n || c || i, o = l ? Oc(e.length, String) : [], p = o.length;\n  for (var u in e)\n    (r || Lc.call(e, u)) && !(l && // Safari 9 has enumerable `arguments.length` in strict mode.\n    (u == \"length\" || // Node.js 0.10 has enumerable non-index properties on buffers.\n    c && (u == \"offset\" || u == \"parent\") || // PhantomJS 2 has enumerable non-index properties on typed arrays.\n    i && (u == \"buffer\" || u == \"byteLength\" || u == \"byteOffset\") || // Skip index properties.\n    Ic(u, p))) && o.push(u);\n  return o;\n}\nvar wn = Fc, Nc = Object.prototype;\nfunction Uc(e) {\n  var r = e && e.constructor, t = typeof r == \"function\" && r.prototype || Nc;\n  return e === t;\n}\nvar Zr = Uc;\nfunction Bc(e, r) {\n  return function(t) {\n    return e(r(t));\n  };\n}\nvar Tn = Bc, qc = Tn, Yc = qc(Object.keys, Object), Gc = Yc, Wc = Zr, kc = Gc, zc = Object.prototype, Kc = zc.hasOwnProperty;\nfunction Hc(e) {\n  if (!Wc(e))\n    return kc(e);\n  var r = [];\n  for (var t in Object(e))\n    Kc.call(e, t) && t != \"constructor\" && r.push(t);\n  return r;\n}\nvar Vc = Hc, Jc = yn, Xc = _n;\nfunction Zc(e) {\n  return e != null && Xc(e.length) && !Jc(e);\n}\nvar Cn = Zc, Qc = wn, el = Vc, rl = Cn;\nfunction tl(e) {\n  return rl(e) ? Qc(e) : el(e);\n}\nvar Qr = tl, nl = br, al = Qr;\nfunction il(e, r) {\n  return e && nl(r, al(r), e);\n}\nvar ol = il;\nfunction sl(e) {\n  var r = [];\n  if (e != null)\n    for (var t in Object(e))\n      r.push(t);\n  return r;\n}\nvar cl = sl, ll = Ve, ul = Zr, fl = cl, dl = Object.prototype, vl = dl.hasOwnProperty;\nfunction pl(e) {\n  if (!ll(e))\n    return fl(e);\n  var r = ul(e), t = [];\n  for (var n in e)\n    n == \"constructor\" && (r || !vl.call(e, n)) || t.push(n);\n  return t;\n}\nvar yl = pl, gl = wn, hl = yl, bl = Cn;\nfunction $l(e) {\n  return bl(e) ? gl(e, !0) : hl(e);\n}\nvar et = $l, ml = br, xl = et;\nfunction _l(e, r) {\n  return e && ml(r, xl(r), e);\n}\nvar El = _l, ur = { exports: {} };\nur.exports;\n(function(e, r) {\n  var t = $e, n = r && !r.nodeType && r, c = n && !0 && e && !e.nodeType && e, i = c && c.exports === n, l = i ? t.Buffer : void 0, o = l ? l.allocUnsafe : void 0;\n  function p(u, f) {\n    if (f)\n      return u.slice();\n    var h = u.length, _ = o ? o(h) : new u.constructor(h);\n    return u.copy(_), _;\n  }\n  e.exports = p;\n})(ur, ur.exports);\nvar wl = ur.exports;\nfunction Tl(e, r) {\n  var t = -1, n = e.length;\n  for (r || (r = Array(n)); ++t < n; )\n    r[t] = e[t];\n  return r;\n}\nvar Cl = Tl;\nfunction Sl(e, r) {\n  for (var t = -1, n = e == null ? 0 : e.length, c = 0, i = []; ++t < n; ) {\n    var l = e[t];\n    r(l, t, e) && (i[c++] = l);\n  }\n  return i;\n}\nvar Rl = Sl;\nfunction Ol() {\n  return [];\n}\nvar Sn = Ol, Al = Rl, jl = Sn, Pl = Object.prototype, Il = Pl.propertyIsEnumerable, Pt = Object.getOwnPropertySymbols, Dl = Pt ? function(e) {\n  return e == null ? [] : (e = Object(e), Al(Pt(e), function(r) {\n    return Il.call(e, r);\n  }));\n} : jl, rt = Dl, Ml = br, Ll = rt;\nfunction Fl(e, r) {\n  return Ml(e, Ll(e), r);\n}\nvar Nl = Fl;\nfunction Ul(e, r) {\n  for (var t = -1, n = r.length, c = e.length; ++t < n; )\n    e[c + t] = r[t];\n  return e;\n}\nvar Rn = Ul, Bl = Tn, ql = Bl(Object.getPrototypeOf, Object), On = ql, Yl = Rn, Gl = On, Wl = rt, kl = Sn, zl = Object.getOwnPropertySymbols, Kl = zl ? function(e) {\n  for (var r = []; e; )\n    Yl(r, Wl(e)), e = Gl(e);\n  return r;\n} : kl, An = Kl, Hl = br, Vl = An;\nfunction Jl(e, r) {\n  return Hl(e, Vl(e), r);\n}\nvar Xl = Jl, Zl = Rn, Ql = $r;\nfunction eu(e, r, t) {\n  var n = r(e);\n  return Ql(e) ? n : Zl(n, t(e));\n}\nvar jn = eu, ru = jn, tu = rt, nu = Qr;\nfunction au(e) {\n  return ru(e, nu, tu);\n}\nvar Pn = au, iu = jn, ou = An, su = et;\nfunction cu(e) {\n  return iu(e, su, ou);\n}\nvar lu = cu, uu = Ie, fu = $e, du = uu(fu, \"DataView\"), vu = du, pu = Ie, yu = $e, gu = pu(yu, \"Promise\"), hu = gu, bu = Ie, $u = $e, mu = bu($u, \"Set\"), xu = mu, _u = Ie, Eu = $e, wu = _u(Eu, \"WeakMap\"), Tu = wu, Br = vu, qr = Hr, Yr = hu, Gr = xu, Wr = Tu, In = yr, qe = gn, It = \"[object Map]\", Cu = \"[object Object]\", Dt = \"[object Promise]\", Mt = \"[object Set]\", Lt = \"[object WeakMap]\", Ft = \"[object DataView]\", Su = qe(Br), Ru = qe(qr), Ou = qe(Yr), Au = qe(Gr), ju = qe(Wr), je = In;\n(Br && je(new Br(new ArrayBuffer(1))) != Ft || qr && je(new qr()) != It || Yr && je(Yr.resolve()) != Dt || Gr && je(new Gr()) != Mt || Wr && je(new Wr()) != Lt) && (je = function(e) {\n  var r = In(e), t = r == Cu ? e.constructor : void 0, n = t ? qe(t) : \"\";\n  if (n)\n    switch (n) {\n      case Su:\n        return Ft;\n      case Ru:\n        return It;\n      case Ou:\n        return Dt;\n      case Au:\n        return Mt;\n      case ju:\n        return Lt;\n    }\n  return r;\n});\nvar mr = je, Pu = Object.prototype, Iu = Pu.hasOwnProperty;\nfunction Du(e) {\n  var r = e.length, t = new e.constructor(r);\n  return r && typeof e[0] == \"string\" && Iu.call(e, \"index\") && (t.index = e.index, t.input = e.input), t;\n}\nvar Mu = Du, Lu = $e, Fu = Lu.Uint8Array, Dn = Fu, Nt = Dn;\nfunction Nu(e) {\n  var r = new e.constructor(e.byteLength);\n  return new Nt(r).set(new Nt(e)), r;\n}\nvar tt = Nu, Uu = tt;\nfunction Bu(e, r) {\n  var t = r ? Uu(e.buffer) : e.buffer;\n  return new e.constructor(t, e.byteOffset, e.byteLength);\n}\nvar qu = Bu, Yu = /\\w*$/;\nfunction Gu(e) {\n  var r = new e.constructor(e.source, Yu.exec(e));\n  return r.lastIndex = e.lastIndex, r;\n}\nvar Wu = Gu, Ut = pr, Bt = Ut ? Ut.prototype : void 0, qt = Bt ? Bt.valueOf : void 0;\nfunction ku(e) {\n  return qt ? Object(qt.call(e)) : {};\n}\nvar zu = ku, Ku = tt;\nfunction Hu(e, r) {\n  var t = r ? Ku(e.buffer) : e.buffer;\n  return new e.constructor(t, e.byteOffset, e.length);\n}\nvar Vu = Hu, Ju = tt, Xu = qu, Zu = Wu, Qu = zu, ef = Vu, rf = \"[object Boolean]\", tf = \"[object Date]\", nf = \"[object Map]\", af = \"[object Number]\", of = \"[object RegExp]\", sf = \"[object Set]\", cf = \"[object String]\", lf = \"[object Symbol]\", uf = \"[object ArrayBuffer]\", ff = \"[object DataView]\", df = \"[object Float32Array]\", vf = \"[object Float64Array]\", pf = \"[object Int8Array]\", yf = \"[object Int16Array]\", gf = \"[object Int32Array]\", hf = \"[object Uint8Array]\", bf = \"[object Uint8ClampedArray]\", $f = \"[object Uint16Array]\", mf = \"[object Uint32Array]\";\nfunction xf(e, r, t) {\n  var n = e.constructor;\n  switch (r) {\n    case uf:\n      return Ju(e);\n    case rf:\n    case tf:\n      return new n(+e);\n    case ff:\n      return Xu(e, t);\n    case df:\n    case vf:\n    case pf:\n    case yf:\n    case gf:\n    case hf:\n    case bf:\n    case $f:\n    case mf:\n      return ef(e, t);\n    case nf:\n      return new n();\n    case af:\n    case cf:\n      return new n(e);\n    case of:\n      return Zu(e);\n    case sf:\n      return new n();\n    case lf:\n      return Qu(e);\n  }\n}\nvar _f = xf, Ef = Ve, Yt = Object.create, wf = function() {\n  function e() {\n  }\n  return function(r) {\n    if (!Ef(r))\n      return {};\n    if (Yt)\n      return Yt(r);\n    e.prototype = r;\n    var t = new e();\n    return e.prototype = void 0, t;\n  };\n}(), Tf = wf, Cf = Tf, Sf = On, Rf = Zr;\nfunction Of(e) {\n  return typeof e.constructor == \"function\" && !Rf(e) ? Cf(Sf(e)) : {};\n}\nvar Af = Of, jf = mr, Pf = Be, If = \"[object Map]\";\nfunction Df(e) {\n  return Pf(e) && jf(e) == If;\n}\nvar Mf = Df, Lf = Mf, Ff = Jr, Gt = Xr, Wt = Gt && Gt.isMap, Nf = Wt ? Ff(Wt) : Lf, Uf = Nf, Bf = mr, qf = Be, Yf = \"[object Set]\";\nfunction Gf(e) {\n  return qf(e) && Bf(e) == Yf;\n}\nvar Wf = Gf, kf = Wf, zf = Jr, kt = Xr, zt = kt && kt.isSet, Kf = zt ? zf(zt) : kf, Hf = Kf, Vf = bn, Jf = ys, Xf = mn, Zf = ol, Qf = El, ed = wl, rd = Cl, td = Nl, nd = Xl, ad = Pn, id = lu, od = mr, sd = Mu, cd = _f, ld = Af, ud = $r, fd = Vr, dd = Uf, vd = Ve, pd = Hf, yd = Qr, gd = et, hd = 1, bd = 2, $d = 4, Mn = \"[object Arguments]\", md = \"[object Array]\", xd = \"[object Boolean]\", _d = \"[object Date]\", Ed = \"[object Error]\", Ln = \"[object Function]\", wd = \"[object GeneratorFunction]\", Td = \"[object Map]\", Cd = \"[object Number]\", Fn = \"[object Object]\", Sd = \"[object RegExp]\", Rd = \"[object Set]\", Od = \"[object String]\", Ad = \"[object Symbol]\", jd = \"[object WeakMap]\", Pd = \"[object ArrayBuffer]\", Id = \"[object DataView]\", Dd = \"[object Float32Array]\", Md = \"[object Float64Array]\", Ld = \"[object Int8Array]\", Fd = \"[object Int16Array]\", Nd = \"[object Int32Array]\", Ud = \"[object Uint8Array]\", Bd = \"[object Uint8ClampedArray]\", qd = \"[object Uint16Array]\", Yd = \"[object Uint32Array]\", z = {};\nz[Mn] = z[md] = z[Pd] = z[Id] = z[xd] = z[_d] = z[Dd] = z[Md] = z[Ld] = z[Fd] = z[Nd] = z[Td] = z[Cd] = z[Fn] = z[Sd] = z[Rd] = z[Od] = z[Ad] = z[Ud] = z[Bd] = z[qd] = z[Yd] = !0;\nz[Ed] = z[Ln] = z[jd] = !1;\nfunction ir(e, r, t, n, c, i) {\n  var l, o = r & hd, p = r & bd, u = r & $d;\n  if (t && (l = c ? t(e, n, c, i) : t(e)), l !== void 0)\n    return l;\n  if (!vd(e))\n    return e;\n  var f = ud(e);\n  if (f) {\n    if (l = sd(e), !o)\n      return rd(e, l);\n  } else {\n    var h = od(e), _ = h == Ln || h == wd;\n    if (fd(e))\n      return ed(e, o);\n    if (h == Fn || h == Mn || _ && !c) {\n      if (l = p || _ ? {} : ld(e), !o)\n        return p ? nd(e, Qf(l, e)) : td(e, Zf(l, e));\n    } else {\n      if (!z[h])\n        return c ? e : {};\n      l = cd(e, h, o);\n    }\n  }\n  i || (i = new Vf());\n  var M = i.get(e);\n  if (M)\n    return M;\n  i.set(e, l), pd(e) ? e.forEach(function(d) {\n    l.add(ir(d, r, t, d, e, i));\n  }) : dd(e) && e.forEach(function(d, Y) {\n    l.set(Y, ir(d, r, t, Y, e, i));\n  });\n  var F = u ? p ? id : ad : p ? gd : yd, A = f ? void 0 : F(e);\n  return Jf(A || e, function(d, Y) {\n    A && (Y = d, d = e[Y]), Xf(l, Y, ir(d, r, t, Y, e, i));\n  }), l;\n}\nvar Gd = ir, Wd = Gd, kd = 1, zd = 4;\nfunction Kd(e) {\n  return Wd(e, kd | zd);\n}\nvar Hd = Kd;\nconst Kt = /* @__PURE__ */ kr(Hd);\nvar Vd = \"__lodash_hash_undefined__\";\nfunction Jd(e) {\n  return this.__data__.set(e, Vd), this;\n}\nvar Xd = Jd;\nfunction Zd(e) {\n  return this.__data__.has(e);\n}\nvar Qd = Zd, ev = hn, rv = Xd, tv = Qd;\nfunction fr(e) {\n  var r = -1, t = e == null ? 0 : e.length;\n  for (this.__data__ = new ev(); ++r < t; )\n    this.add(e[r]);\n}\nfr.prototype.add = fr.prototype.push = rv;\nfr.prototype.has = tv;\nvar nv = fr;\nfunction av(e, r) {\n  for (var t = -1, n = e == null ? 0 : e.length; ++t < n; )\n    if (r(e[t], t, e))\n      return !0;\n  return !1;\n}\nvar iv = av;\nfunction ov(e, r) {\n  return e.has(r);\n}\nvar sv = ov, cv = nv, lv = iv, uv = sv, fv = 1, dv = 2;\nfunction vv(e, r, t, n, c, i) {\n  var l = t & fv, o = e.length, p = r.length;\n  if (o != p && !(l && p > o))\n    return !1;\n  var u = i.get(e), f = i.get(r);\n  if (u && f)\n    return u == r && f == e;\n  var h = -1, _ = !0, M = t & dv ? new cv() : void 0;\n  for (i.set(e, r), i.set(r, e); ++h < o; ) {\n    var F = e[h], A = r[h];\n    if (n)\n      var d = l ? n(A, F, h, r, e, i) : n(F, A, h, e, r, i);\n    if (d !== void 0) {\n      if (d)\n        continue;\n      _ = !1;\n      break;\n    }\n    if (M) {\n      if (!lv(r, function(Y, Q) {\n        if (!uv(M, Q) && (F === Y || c(F, Y, t, n, i)))\n          return M.push(Q);\n      })) {\n        _ = !1;\n        break;\n      }\n    } else if (!(F === A || c(F, A, t, n, i))) {\n      _ = !1;\n      break;\n    }\n  }\n  return i.delete(e), i.delete(r), _;\n}\nvar Nn = vv;\nfunction pv(e) {\n  var r = -1, t = Array(e.size);\n  return e.forEach(function(n, c) {\n    t[++r] = [c, n];\n  }), t;\n}\nvar yv = pv;\nfunction gv(e) {\n  var r = -1, t = Array(e.size);\n  return e.forEach(function(n) {\n    t[++r] = n;\n  }), t;\n}\nvar hv = gv, Ht = pr, Vt = Dn, bv = Kr, $v = Nn, mv = yv, xv = hv, _v = 1, Ev = 2, wv = \"[object Boolean]\", Tv = \"[object Date]\", Cv = \"[object Error]\", Sv = \"[object Map]\", Rv = \"[object Number]\", Ov = \"[object RegExp]\", Av = \"[object Set]\", jv = \"[object String]\", Pv = \"[object Symbol]\", Iv = \"[object ArrayBuffer]\", Dv = \"[object DataView]\", Jt = Ht ? Ht.prototype : void 0, Dr = Jt ? Jt.valueOf : void 0;\nfunction Mv(e, r, t, n, c, i, l) {\n  switch (t) {\n    case Dv:\n      if (e.byteLength != r.byteLength || e.byteOffset != r.byteOffset)\n        return !1;\n      e = e.buffer, r = r.buffer;\n    case Iv:\n      return !(e.byteLength != r.byteLength || !i(new Vt(e), new Vt(r)));\n    case wv:\n    case Tv:\n    case Rv:\n      return bv(+e, +r);\n    case Cv:\n      return e.name == r.name && e.message == r.message;\n    case Ov:\n    case jv:\n      return e == r + \"\";\n    case Sv:\n      var o = mv;\n    case Av:\n      var p = n & _v;\n      if (o || (o = xv), e.size != r.size && !p)\n        return !1;\n      var u = l.get(e);\n      if (u)\n        return u == r;\n      n |= Ev, l.set(e, r);\n      var f = $v(o(e), o(r), n, c, i, l);\n      return l.delete(e), f;\n    case Pv:\n      if (Dr)\n        return Dr.call(e) == Dr.call(r);\n  }\n  return !1;\n}\nvar Lv = Mv, Xt = Pn, Fv = 1, Nv = Object.prototype, Uv = Nv.hasOwnProperty;\nfunction Bv(e, r, t, n, c, i) {\n  var l = t & Fv, o = Xt(e), p = o.length, u = Xt(r), f = u.length;\n  if (p != f && !l)\n    return !1;\n  for (var h = p; h--; ) {\n    var _ = o[h];\n    if (!(l ? _ in r : Uv.call(r, _)))\n      return !1;\n  }\n  var M = i.get(e), F = i.get(r);\n  if (M && F)\n    return M == r && F == e;\n  var A = !0;\n  i.set(e, r), i.set(r, e);\n  for (var d = l; ++h < p; ) {\n    _ = o[h];\n    var Y = e[_], Q = r[_];\n    if (n)\n      var w = l ? n(Q, Y, _, r, e, i) : n(Y, Q, _, e, r, i);\n    if (!(w === void 0 ? Y === Q || c(Y, Q, t, n, i) : w)) {\n      A = !1;\n      break;\n    }\n    d || (d = _ == \"constructor\");\n  }\n  if (A && !d) {\n    var N = e.constructor, y = r.constructor;\n    N != y && \"constructor\" in e && \"constructor\" in r && !(typeof N == \"function\" && N instanceof N && typeof y == \"function\" && y instanceof y) && (A = !1);\n  }\n  return i.delete(e), i.delete(r), A;\n}\nvar qv = Bv, Mr = bn, Yv = Nn, Gv = Lv, Wv = qv, Zt = mr, Qt = $r, en = Vr, kv = En, zv = 1, rn = \"[object Arguments]\", tn = \"[object Array]\", nr = \"[object Object]\", Kv = Object.prototype, nn = Kv.hasOwnProperty;\nfunction Hv(e, r, t, n, c, i) {\n  var l = Qt(e), o = Qt(r), p = l ? tn : Zt(e), u = o ? tn : Zt(r);\n  p = p == rn ? nr : p, u = u == rn ? nr : u;\n  var f = p == nr, h = u == nr, _ = p == u;\n  if (_ && en(e)) {\n    if (!en(r))\n      return !1;\n    l = !0, f = !1;\n  }\n  if (_ && !f)\n    return i || (i = new Mr()), l || kv(e) ? Yv(e, r, t, n, c, i) : Gv(e, r, p, t, n, c, i);\n  if (!(t & zv)) {\n    var M = f && nn.call(e, \"__wrapped__\"), F = h && nn.call(r, \"__wrapped__\");\n    if (M || F) {\n      var A = M ? e.value() : e, d = F ? r.value() : r;\n      return i || (i = new Mr()), c(A, d, t, n, i);\n    }\n  }\n  return _ ? (i || (i = new Mr()), Wv(e, r, t, n, c, i)) : !1;\n}\nvar Vv = Hv, Jv = Vv, an = Be;\nfunction Un(e, r, t, n, c) {\n  return e === r ? !0 : e == null || r == null || !an(e) && !an(r) ? e !== e && r !== r : Jv(e, r, t, n, Un, c);\n}\nvar Xv = Un, Zv = Xv;\nfunction Qv(e, r) {\n  return Zv(e, r);\n}\nvar ep = Qv;\nconst rp = /* @__PURE__ */ kr(ep);\nfunction cp(e) {\n  const r = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    (async () => console.log(\"TestRef.currrent\", r.current))();\n  }, []), /* @__PURE__ */ j.jsx(\"div\", { ref: r, children: \"test component\" });\n}\nfunction tp() {\n  return /* @__PURE__ */ j.jsx(\"div\", { className: \"splash\", style: {\n    fontSize: \"36px\",\n    border: \"10px solid #0960a5\",\n    width: \"100%\",\n    height: \"100%\",\n    margin: 0,\n    padding: 0,\n    boxSizing: \"border-box\",\n    overflow: \"hidden\",\n    display: \"flex\",\n    flexDirection: \"column\",\n    flex: 1,\n    justifyContent: \"center\",\n    alignItems: \"center\"\n  }, children: /* @__PURE__ */ j.jsx(\"img\", { style: { height: 500, width: 1e3 }, src: \"./ReExt/ReExt.png\" }) });\n}\nfunction lp({ children: e, ReExtData: r, splash: t, fill: n }) {\n  r === void 0 && (r = {\n    sdkversion: \"7.8.0\",\n    toolkit: \"classic\",\n    theme: \"classic\",\n    packages: {\n      charts: !1,\n      fontawesome: !1,\n      ux: !1,\n      calendar: !1,\n      d3: !1,\n      exporter: !1,\n      pivot: !1,\n      pivotd3: !1,\n      pivotlocale: !1,\n      froalaeditor: !1\n    },\n    debug: !1,\n    license: \"b116e32e-0847-4764-94ef-a16987070409\",\n    url: \"default\"\n  });\n  const [c, i] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!1);\n  return n !== void 0 && ap(), (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    (async () => {\n      try {\n        await Bn(r), i(!0);\n      } catch (o) {\n        console.error(\"fail\", o);\n      }\n    })();\n  }, []), c ? /* @__PURE__ */ j.jsx(j.Fragment, { children: e }) : t === !0 ? /* @__PURE__ */ j.jsx(tp, {}) : null;\n}\nfunction np(e) {\n  const [r, t] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null), [n] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!0), [c, i] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n  var l = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n  l.current = c;\n  const o = () => l.current, [p, u] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n  var f = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n  f.current = p;\n  const h = () => f.current, _ = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  window.Ext === void 0 && window.ReExtLoad === void 0 && (window.ReExtLoad = !0, Bn());\n  const M = new ResizeObserver((g) => {\n    for (const s of g) {\n      var E;\n      window.Ext.ReExtL === !0 ? E = s.target.children.length - 1 : E = s.target.children.length - 2;\n      var x = s.target.children.item(E);\n      if (x !== null && s.contentBoxSize) {\n        const v = s.contentBoxSize[0];\n        var T = v.inlineSize, m = window.Ext.getCmp(x.id);\n        if (m !== void 0)\n          window.Ext.getCmp(x.id).setWidth(T), window.Ext.getCmp(x.id).setHeight(v.blockSize);\n        else {\n          var L = x.getAttribute(\"w\");\n          L !== \"w\" && console.log(\"child not resized\", x);\n        }\n      }\n    }\n  });\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    var g, E = \"false\";\n    return (async () => {\n      await N(), e.children !== void 0 && e.config.items === void 0 && (e.config.items = []);\n      var x = 1e4;\n      if (E === \"false\" && e.xtype !== \"logo\" && e.xtype !== \"logosmall\" && e.xtype !== \"loader\") {\n        var T;\n        h() == null ? T = e.config : T = h();\n        try {\n          var m = A(e.xtype, T, e), L = Ext.ClassManager.getByAlias(\"widget.\" + m.xtype);\n          if (L === void 0) {\n            var s = m.xtype + \" could not be created\";\n            m = { xtype: \"button\", disabled: !0, text: s, style: { fontSize: \"36px\", color: \"red\" } };\n          }\n          if (m.height === void 0 && (window.Ext.isClassic === !0 && m.xtype === \"grid\" ? m.height = 0 : m.height = \"100%\"), m.width === void 0 && (window.Ext.isClassic === !0 && m.xtype === \"grid\" ? m.width = 0 : m.width = \"100%\"), window.Ext.isClassic === !0) {\n            const v = (C) => {\n              var O = C.el.dom.parentNode;\n              M.observe(O);\n            };\n            m.listeners === void 0 ? m.listeners = { boxready: v } : m.listeners.boxready = v;\n          }\n          if (Y(x)) {\n            alert(\"ReExt trial limit:\" + x + \" components\");\n            return;\n          }\n          m.renderTo = _.current, g = window.Ext.create(m), i(g), l.current = g, e.config !== void 0 && e.config.reference !== void 0 && e.ReExtParent !== void 0 && (e.ReExtParent.ReExtChildren === void 0 && (e.ReExtParent.ReExtChildren = []), e.ReExtParent.ReExtChildren.push(g)), _.current === null ? console.log(\"ReExtRootRef.current,props\", _.current, e) : (_.current.style.background = \"transparent\", _.current.firstChild.remove()), d(e.children, g), y(g, \"ReExt \" + m.xtype, _.current), e.ready !== void 0 && e.ready(g);\n        } catch (v) {\n          console.error(v);\n        }\n      }\n    })(), () => {\n      E = \"true\", window.Ext !== void 0 && window.Ext.destroy !== void 0 && g != null && (window.Ext.ReExtCount = window.Ext.ReExtCount - 1, i(null), window.Ext.destroy(g));\n    };\n  }, []);\n  const F = (g, E, x) => {\n    var T = (L) => {\n      const v = L.charAt(0).toUpperCase(), C = L.slice(1);\n      var R = \"set\" + (v + C);\n      return R;\n    }, m;\n    window.Ext.isClassic === !0 ? E === \"items\" ? (g.removeAll(!0), g.add(x)) : E !== \"layout\" && (m = T(E), g[m] !== void 0 ? g[m](x) : g[E] = x) : (m = T(E), g[m] !== void 0 && g[m](x));\n  };\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (e.config !== void 0) {\n      if (l.current !== null) {\n        e.children !== void 0 && e.config.items === void 0 && (e.config.items = []);\n        for (const [L] of Object.entries(f.current)) {\n          if (Q(L) != null || L === \"xtype\")\n            return;\n          var g = Kt(f.current[L]), E = Kt(e.config[L]);\n          g != null && delete g.listeners, E !== void 0 && g !== null && delete E.listeners;\n          const s = (v) => {\n            let C = [], O = JSON.stringify(v, function(R, P) {\n              if (typeof P == \"object\" && P !== null) {\n                if (C.indexOf(P) !== -1)\n                  return;\n                C.push(P);\n              }\n              return P;\n            });\n            return C = null, O;\n          };\n          var x = s(g), T = s(E), m = rp(x, T);\n          m || (F(l.current, L, E), L === \"items\" && d(e.children, l.current));\n        }\n      }\n      u(e.config), f.current = e.config;\n    }\n  }, [e.config]);\n  const A = (g, E, x) => {\n    var T = {};\n    if (T.xtype = g, E !== void 0)\n      for (const [L, s] of Object.entries(E))\n        T[L] = s;\n    if (x.references === !0 && (T.controller = window.Ext.create(\"Ext.app.ViewController\")), T.store !== void 0 && (T.store.listeners !== void 0 ? T.store.listeners.load === void 0 && (T.store.listeners.load = (L) => {\n      x.storeloaded !== void 0 && x.storeloaded(L, o());\n    }) : T.store.listeners = {\n      load: (L) => {\n        x.storeloaded !== void 0 && x.storeloaded(L, o());\n      }\n    }), T.listeners === void 0) {\n      T.listeners = {};\n      for (const [L, s] of Object.entries(x)) {\n        var m = Q(L);\n        m !== null && (T.listeners[m] = function() {\n          s(...arguments);\n        });\n      }\n      Object.keys(T.listeners).length === 0 && delete T.listeners;\n    }\n    return T;\n  }, d = (g, E) => {\n    var x = [], T = [];\n    if (g !== void 0) {\n      e.children.length === void 0 ? T.push(g) : T = g;\n      try {\n        T.map((m) => {\n          var L, s;\n          if (E.xtype === \"tabpanel\") {\n            var v;\n            window.Ext.ReExtTheme === \"classic\" ? v = \"Ext.panel.Panel\" : v = \"Ext.Panel\", L = window.Ext.create(v, {\n              layout: \"fit\",\n              title: m.props.title,\n              cls: \"ReExtTabChildRoot\",\n              items: [\n                {\n                  xtype: \"component\",\n                  listeners: {\n                    boxready: (R) => {\n                      s = (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.createPortal)(m, R.el.dom), x.push(s);\n                      var P = R.el.dom.parentNode;\n                      M.observe(P);\n                    }\n                  },\n                  style: { backgroundColor: \"transparent\", display: \"flex\", height: \"100%\", width: \"100%\" }\n                }\n              ]\n            }), y(L, \"ReExt tab child\", null), E.add(L), window.Ext.isClassic === !0 ? C = \"Ext.container.Container\" : C = \"Ext.Container\", window.Ext.isClassic !== !0 && (s = (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.createPortal)(m, L.items.items[0].el.dom), x.push(s));\n          } else {\n            var C;\n            window.Ext.isClassic === !0 ? C = \"Ext.container.Container\" : C = \"Ext.Container\", L = window.Ext.create(C, {\n              cls: \"ReExtWidgetRoot\"\n              //style:{background:'yellow',border:'5px solid red'}\n            }), E.add(L);\n            var O = (0,react__WEBPACK_IMPORTED_MODULE_0__.cloneElement)(m, { ReExtParent: E });\n            window.Ext.isClassic === !0 ? s = (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.createPortal)(O, L.el.dom) : s = (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.createPortal)(O, L.innerElement.dom), x.push(s);\n          }\n        }), t(x);\n      } catch (m) {\n        console.error(\"iterateOverChildren:\", m.toString());\n      }\n    }\n  };\n  function Y(g) {\n    return window.Ext.ReExtCount === void 0 ? window.Ext.ReExtCount = 1 : window.Ext.ReExtCount = window.Ext.ReExtCount + 1, window.Ext.ReExtCount > g;\n  }\n  var Q = (g) => {\n    var E = null, x = g.slice(0, 2);\n    if (x === \"on\") {\n      var T = g.charAt(2), m = g.charAt(2).toUpperCase();\n      T === m && (E = g.slice(2).toLowerCase());\n    }\n    return window.Ext.isClassic === !0 && E === \"tap\" && (E = \"click\"), E;\n  };\n  function w(g) {\n    let E = 2, x = \"\";\n    for (let m = g.length - E; m >= E; m--)\n      x += g[m];\n    var T = g[1] + g[0] + x;\n    return T;\n  }\n  async function N() {\n    return await new Promise((x) => {\n      function T() {\n        window.Ext !== void 0 && window.Ext.onReady(function() {\n          return clearInterval(m), x(1);\n        });\n      }\n      var m = setInterval(T, 5);\n    });\n  }\n  const y = (g, E, x) => {\n    if (x === null || window.Ext.ReExtL === !0 || n === !1)\n      return;\n    const T = document.createElement(\"div\"), m = document.createAttribute(\"w\");\n    m.value = \"w\", T.setAttributeNode(m);\n    const L = document.createTextNode(E);\n    T.appendChild(L);\n    var s;\n    x !== null ? s = x.appendChild(T) : g.el !== void 0 && (s = g.el.dom.appendChild(T)), ve(s);\n  };\n  function ve(g) {\n    var E = w(\"tselyx\");\n    g[E][w(\"idyalpsx\")] = w(\"lbkcox\"), g[E][w(\"ofeziStnx\")] = w(\"p8xx\"), g[E][w(\"obredrx\")] = w(\"p1yargthgil dilos xx\"), g[E][w(\"ofelytStnx\")] = w(\"ticilax\"), g[E][w(\"apgniddx\")] = w(\"p4xx\"), g[E][w(\"abdnuorgkcx\")] = w(\"E#CDFFCx\"), g[E][w(\"ocrolx\")] = w(\"lbkcax\"), g[E][w(\"poyticax\")] = w(\"p1xx\"), g[E][w(\"Izxednx\")] = w(\"01000x\"), g[E][w(\"obmottx\")] = w(\"p0xx\"), g[E][w(\"opnoitisx\")] = w(\"baetulosx\"), g[E][w(\"irthgx\")] = w(\"p0xx\"), g[E][w(\"ilthgieh-enx\")] = w(\"p1xx\");\n  }\n  var pe = \"\", me = \"\", ye = \"\", xe = \"\";\n  if (window.Ext !== void 0 && window.Ext.versions !== null) {\n    me = window.Ext.versions.core.version, xe = window.Ext.ReExtTheme, window.Ext.ReExtUrl === \"\" ? pe = \"local\" : pe = \"remote\";\n    var _e = window.Ext.isClassic;\n    _e === !0 ? ye = \"classic\" : ye = \"modern\";\n  }\n  if (e.xtype === \"logo\")\n    return /* @__PURE__ */ j.jsxs(\n      \"div\",\n      {\n        name: \"ReExtRootLogo\",\n        \"data-rid\": e.rid,\n        className: \"center\",\n        style: { borderBottom: \"1px solid gray\", display: \"flex\", height: \"80px\", color: \"black\", padding: 10, ...e.style },\n        children: [\n          /* @__PURE__ */ j.jsx(\"img\", { style: { height: 80, width: 88 }, src: \"./ReExt/ReExt.png\" }),\n          /* @__PURE__ */ j.jsxs(\"div\", { style: { margin: 5 }, children: [\n            /* @__PURE__ */ j.jsxs(\"div\", { style: { margin: \"0 0 0 1px\", fontSize: 26 }, children: [\n              /* @__PURE__ */ j.jsx(\"i\", { children: \"React ReExt\" }),\n              \" - React Components for ExtJS\"\n            ] }),\n            /* @__PURE__ */ j.jsx(\"div\", { style: { margin: \"0 0 0 1px\", fontSize: 18, color: \"black\" }, children: /* @__PURE__ */ j.jsx(\"a\", { target: \"_blank\", rel: \"noreferrer\", href: \"https://www.npmjs.com/package/@gusmano/reext\", children: \"https://www.npmjs.com/package/@gusmano/reext\" }) }),\n            /* @__PURE__ */ j.jsxs(\"div\", { style: { fontSize: \"12px\", margin: \"5px 0 0 0\" }, children: [\n              /* @__PURE__ */ j.jsxs(\"span\", { style: { margin: \"0 0 0 0\" }, children: [\n                \"ReExt: \",\n                /* @__PURE__ */ j.jsx(\"b\", { children: \"0.0.339\" })\n              ] }),\n              /* @__PURE__ */ j.jsxs(\"span\", { style: { margin: \"0 0 0 10px\" }, children: [\n                \"React: \",\n                /* @__PURE__ */ j.jsx(\"b\", { children: (react__WEBPACK_IMPORTED_MODULE_0___default().version) })\n              ] }),\n              /* @__PURE__ */ j.jsxs(\"span\", { style: { margin: \"0 0 0 10px\" }, children: [\n                \"ExtJS: \",\n                /* @__PURE__ */ j.jsxs(\"b\", { children: [\n                  me,\n                  \" (\",\n                  pe,\n                  \")\"\n                ] })\n              ] }),\n              /* @__PURE__ */ j.jsxs(\"span\", { style: { margin: \"0 0 0 10px\" }, children: [\n                \"toolkit: \",\n                /* @__PURE__ */ j.jsx(\"b\", { children: ye })\n              ] }),\n              /* @__PURE__ */ j.jsxs(\"span\", { style: { margin: \"0 0 0 10px\" }, children: [\n                \"theme: \",\n                /* @__PURE__ */ j.jsx(\"b\", { children: xe })\n              ] })\n            ] })\n          ] })\n        ]\n      }\n    );\n  if (e.xtype === \"logosmall\")\n    return /* @__PURE__ */ j.jsxs(\n      \"div\",\n      {\n        name: \"ReExtRootLogo\",\n        \"data-rid\": e.rid,\n        className: \"center\",\n        style: { borderBottom: \"0px solid gray\", display: \"flex\", height: \"46px\", color: \"black\", padding: 5, ...e.style },\n        children: [\n          /* @__PURE__ */ j.jsx(\"img\", { style: { height: 40, width: 80 }, src: \"./ReExt/ReExt.png\" }),\n          /* @__PURE__ */ j.jsxs(\"div\", { style: { margin: \"0 0 0 3px\" }, children: [\n            /* @__PURE__ */ j.jsx(\"div\", { style: { margin: \"0 0 0 1px\", fontSize: 12, color: \"black\" }, children: /* @__PURE__ */ j.jsx(\"a\", { style: e.style, target: \"_blank\", rel: \"noreferrer\", href: \"https://www.npmjs.com/package/@gusmano/reext\", children: /* @__PURE__ */ j.jsx(\"i\", { children: \"React ReExt\" }) }) }),\n            /* @__PURE__ */ j.jsxs(\"div\", { style: { fontSize: \"10px\", margin: \"2px 0 0 0\" }, children: [\n              /* @__PURE__ */ j.jsxs(\"span\", { style: { margin: \"0 0 0 0\" }, children: [\n                \"ReExt: \",\n                /* @__PURE__ */ j.jsx(\"b\", { children: \"0.0.339\" })\n              ] }),\n              /* @__PURE__ */ j.jsxs(\"span\", { style: { margin: \"0 0 0 5px\" }, children: [\n                \"React: \",\n                /* @__PURE__ */ j.jsx(\"b\", { children: (react__WEBPACK_IMPORTED_MODULE_0___default().version) })\n              ] })\n            ] }),\n            /* @__PURE__ */ j.jsx(\"div\", { style: { fontSize: \"10px\", margin: \"2px 0 0 0\" }, children: /* @__PURE__ */ j.jsxs(\"span\", { style: { margin: \"0 0 0 0\" }, children: [\n              \"ExtJS: \",\n              /* @__PURE__ */ j.jsxs(\"b\", { children: [\n                me,\n                \" (\",\n                pe,\n                \")\"\n              ] })\n            ] }) }),\n            /* @__PURE__ */ j.jsxs(\"div\", { style: { fontSize: \"10px\", margin: \"2px 0 0 0\" }, children: [\n              /* @__PURE__ */ j.jsxs(\"span\", { style: { margin: \"0 0 0 0\" }, children: [\n                \"toolkit: \",\n                /* @__PURE__ */ j.jsx(\"b\", { children: ye })\n              ] }),\n              /* @__PURE__ */ j.jsxs(\"span\", { style: { margin: \"0 0 0 3px\" }, children: [\n                \"theme: \",\n                /* @__PURE__ */ j.jsx(\"b\", { children: xe })\n              ] })\n            ] })\n          ] })\n        ]\n      }\n    );\n  var ge;\n  e.style === void 0 || e.style.height === void 0 ? ge = 1 : ge = \"none\";\n  var Te = \"\";\n  return e.className !== void 0 && (Te = e.className), /* @__PURE__ */ j.jsxs(\n    \"div\",\n    {\n      name: \"ReExtRoot-\" + e.xtype,\n      \"data-rid\": e.rid,\n      className: Te + \" fill\",\n      style: { ...e.style, flex: ge, position: \"relative\", background: \"white\", display: \"flex\" },\n      ref: _,\n      children: [\n        /* @__PURE__ */ j.jsx(\"div\", { style: { display: \"flex\", flex: 1, alignItems: \"center\", justifyContent: \"center\", background: \"#F8F8F8\" } }),\n        r !== null && r.map((g) => g)\n      ]\n    }\n  );\n}\nnp.propTypes = {\n  className: ze.string,\n  style: ze.object,\n  xtype: ze.string,\n  config: ze.object,\n  ready: ze.func\n};\nasync function ap() {\n  function e(r) {\n    r.style.width = \"100%\", r.style.height = \"100%\", r.style.margin = \"0\", r.style.padding = \"0\", r.style.padding = \"0\", r.style.boxSizing = \"border-box\", r.style.overflow = \"hidden\";\n  }\n  document.documentElement && e(document.documentElement), document.body && e(document.body), document.getElementById(\"root\") && e(document.getElementById(\"root\"));\n}\nconst up = (e) => {\n  const [r, t] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(e);\n  var n = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n  return n.current = r, [() => n.current, t];\n};\nfunction fp(e) {\n  for (var r, t = e.getController(), n = e; t === void 0; )\n    t = e.parent.getController(), n = e.parent;\n  if (r = t.getReferences(), r === null && (r = {}), n.ReExtChildren !== void 0)\n    for (var c = 0; c < n.ReExtChildren.length; c++)\n      n.ReExtChildren[c].reference !== null && (r[n.ReExtChildren[c].reference] = n.ReExtChildren[c]);\n  return r;\n}\nconst de = async (e) => await new Promise((n, c) => {\n  let i = document.getElementsByTagName(\"HEAD\")[0];\n  var l = !1;\n  for (let o = 0; o < i.childNodes.length; o++)\n    i.childNodes[o].src === e && (l = !0);\n  if (l === !1) {\n    const o = document.createElement(\"script\");\n    o.addEventListener(\"load\", () => n(1)), o.addEventListener(\"error\", () => {\n      var p = `${e} could not be loaded - copy the node_modules/@gusmano/reext/ext folder to the project's public folder`;\n      console.error(p), c(p);\n    }), o.src = e, i.appendChild(o);\n  }\n}), K = async (e) => await new Promise((n, c) => {\n  let i = document.getElementsByTagName(\"HEAD\")[0], l = document.createElement(\"link\");\n  l.rel = \"stylesheet\", l.type = \"text/css\", l.href = e, l.addEventListener(\"error\", () => {\n    var o = `${e} could not be loaded - copy the node_modules/@gusmano/reext/ext folder to the project's public folder`;\n    return console.error(o), c(o);\n  }), l.addEventListener(\"load\", () => n(1)), i.appendChild(l);\n}), on = async (e, r, t) => await new Promise((i) => {\n  window.Ext.onReady(function() {\n    window.Ext.ReExtUrl = t, window.Ext.ReExtTheme = e;\n    var l = r.substr(r.length - 4);\n    return [...l].reverse().join(\"\") === \"7040\" ? window.Ext.ReExtL = !0 : window.Ext.ReExtL = !1, i(1);\n  });\n}), ip = async (e) => await new Promise((n, c) => {\n  let i = document.getElementsByTagName(\"HEAD\")[0];\n  const l = document.createElement(\"script\");\n  l.addEventListener(\"load\", () => n(1)), l.addEventListener(\"error\", () => {\n    var o = `${e} could not be loaded`;\n    console.error(o), c(o);\n  }), l.src = e, i.appendChild(l);\n});\nasync function Bn(e) {\n  var r = e.sdkversion, t = e.toolkit, n = e.theme, c = e.packages, i = e.debug, l = e.license, o = e.url;\n  (n == null || n === \"\") && (n = \"material\"), (t == null || t === \"\") && (t = \"modern\");\n  var p;\n  switch (r) {\n    case \"7.0.0\":\n      p = r + \".156\", r = r + \".156\";\n      break;\n    case \"7.1.0\":\n      p = r + \".46\", r = r + \".46\";\n      break;\n    case \"7.8.0\":\n      p = r + \".33\", r = r + \".33\";\n      break;\n    case \"7.2.0\":\n    case \"7.3.0\":\n    case \"7.3.1\":\n    case \"7.4.0\":\n    case \"7.5.0\":\n    case \"7.5.1\":\n    case \"7.6.0\":\n    case \"7.7.0\":\n      p = r;\n      break;\n    default:\n      throw `SDK version ${r} is not valid`;\n  }\n  (o === \"default\" || o === null) && (o = \"http://marcgusmano.com/ReExt/\"), (o === \"local\" || o === \"\") && (o = \"\");\n  var u = o + \"ext-\" + r, f = o + \"ext-addons-\" + p;\n  i === !0 ? i = \"-debug\" : i = \"\";\n  var h = \"\";\n  t === \"modern\" && (h = \"-modern\");\n  var _ = [\"ios\", \"material\", \"neptune\", \"triton\"];\n  if (t === \"modern\" && !_.includes(n))\n    throw `${n} theme is not in ${t} toolkit for SDK version ${r}`;\n  var M = [\"classic\", \"crisp\", \"graphite\", \"gray\", \"material\", \"neptune\", \"triton\"];\n  if (t === \"classic\" && !M.includes(n))\n    throw `${n} theme is not in ${t} toolkit for SDK version ${r}`;\n  var F = !1;\n  if ((c.calendar === !0 || c.d3 === !0 || c.exporter === !0 || c.pivot === !0 || c.pivotd3 === !0 || c.pivotlocale === !0 || c.froalaeditor === !0) && (F = !0), e.debug === !0 && await ip(\"node_modules/@gusmano/reext/dist/example/debug.js\"), u = u + \"/build\", r.slice(-1) === \"c\") {\n    await de(`${u}/ext-${r}-toolkit-${t}-sdk.js`), await K(`${u}/ext-${r}-theme-${n}-sdk.css`), F === !0 && (await de(`${u}/ext-${r}-toolkit-${t}-addons.js`), await K(`${u}/ext-${r}-theme-${n}-addons.css`)), await on(n, l, o);\n    return;\n  }\n  if (await de(`${u}/ext${h}-all${i}.js`), await K(`${u}/${t}/theme-${n}/resources/theme-${n}-all.css`), c.fontawesome === !0 && await K(`${u}/packages/font-awesome/resources/font-awesome-all${i}.css`), c.ux === !0 && (await de(`${u}/packages/ux/${t}/ux${i}.js`), r === \"7.0.0\" && t === \"modern\" && n === \"neptune\" && await K(`${u}/packages/ux/${t}/${t}-${n}/resources/ux-all${i}.css`), r === \"7.0.0\" && t === \"classic\" && await K(`${u}/packages/ux/${t}/${n}/resources/ux-all${i}.css`), r !== \"7.0.0\" && t === \"classic\" && n === \"material\" && await K(`${u}/packages/ux/${t}/${t}-${n}/resources/ux-all${i}.css`), r !== \"7.0.0\" && t === \"classic\" && n !== \"material\" && n !== \"gray\" && await K(`${u}/packages/ux/${t}/${n}/resources/ux-all${i}.css`)), c.charts === !0) {\n    await de(`${u}/packages/charts/${t}/charts${i}.js`);\n    var A = !0;\n    (t === \"modern\" && n === \"ios\" && r === \"7.0.0\" || n === \"gray\") && (A = !1), A === !0 && (t === \"classic\" && n !== \"material\" ? await K(`${u}/packages/charts/${t}/${n}/resources/charts-all${i}.css`) : await K(`${u}/packages/charts/${t}/${t}-${n}/resources/charts-all${i}.css`));\n  }\n  if (F === !0) {\n    var d;\n    f = f + \"/packages\", c.calendar === !0 && (d = \"calendar\", await de(`${f}/${d}/build/${t}/${d}${i}.js`), t === \"modern\" && n === \"ios\" || p === \"7.0.0.156\" ? await K(`${f}/${d}/build/${t}/${n}/resources/${d}-all${i}.css`) : n !== \"gray\" && n !== \"graphite\" && (t === \"classic\" && n !== \"material\" ? await K(`${f}/${d}/build/${t}/${n}/resources/${d}-all${i}.css`) : await K(`${f}/${d}/build/${t}/${t}-${n}/resources/${d}-all${i}.css`))), c.d3 === !0 && (d = \"d3\", await de(`${f}/${d}/build/${t}/${d}${i}.js`), t === \"modern\" && (n === \"ios\" || n === \"material\") ? await K(`${f}/${d}/build/${t}/${n}/resources/${d}-all${i}.css`) : n !== \"gray\" && n !== \"graphite\" && (t === \"classic\" && n !== \"material\" ? await K(`${f}/${d}/build/${t}/${n}/resources/${d}-all${i}.css`) : await K(`${f}/${d}/build/${t}/${t}-${n}/resources/${d}-all${i}.css`))), c.exporter === !0 && (d = \"exporter\", await de(`${f}/${d}/build/${t}/${d}${i}.js`), await K(`${f}/${d}/build/${t}/resources/${d}-all${i}.css`)), c.pivot === !0 && (d = \"pivot\", await de(`${f}/${d}/build/${t}/${d}${i}.js`), t === \"modern\" && (n === \"ios\" || n === \"material\") ? await K(`${f}/${d}/build/${t}/${n}/resources/${d}-all${i}.css`) : n !== \"gray\" && n !== \"graphite\" && (t === \"classic\" && n !== \"material\" ? await K(`${f}/${d}/build/${t}/${n}/resources/${d}-all${i}.css`) : await K(`${f}/${d}/build/${t}/${t}-${n}/resources/${d}-all${i}.css`))), c.pivotd3 === !0 && (d = \"pivot-d3\", await de(`${f}/${d}/build/${t}/${d}${i}.js`), t === \"modern\" && (n === \"ios\" || n === \"material\") ? await K(`${f}/${d}/build/${t}/${n}/resources/${d}-all${i}.css`) : n !== \"gray\" && n !== \"graphite\" && (t === \"classic\" && n !== \"material\" ? await K(`${f}/${d}/build/${t}/${n}/resources/${d}-all${i}.css`) : await K(`${f}/${d}/build/${t}/${t}-${n}/resources/${d}-all${i}.css`))), c.froalaeditor === !0 && t === \"modern\" && (await de(`${f}/froala-editor/froala-editor${i}.js`), await K(`${f}/froala-editor/build/resources/froala-editor-all${i}.css`), await de(`${f}/froala-editor/development/froalaeditor.pkgd.js`), await K(`${f}/froala-editor/development/froalaeditor.pkgd.css`)), c.pivotlocale;\n  }\n  await on(n, l, o);\n}\nconst dp = (e, r, t) => (Ext.ClassManager.isCreated(e) && (console.log(e, \"already created\"), Ext.undefine(e)), Ext.define(e, r, t));\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3VzbWFuby9yZWV4dC9kaXN0L3JlZXh0LmVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUE4RjtBQUMvQztBQUMvQztBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWEscUJBQXFCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixHQUFHO0FBQy9CLDZCQUE2QixVQUFVO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRkFBc0YscUJBQU0sU0FBUyxxQkFBTTtBQUMzRztBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWEsU0FBUztBQUNqQztBQUNBO0FBQ0EsWUFBWSw4Q0FBRTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRixPQUFPO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxhQUFhO0FBQ2Isc0JBQXNCO0FBQ3RCO0FBQ0EsYUFBYTtBQUNiLHNCQUFzQjtBQUN0QjtBQUNBLGFBQWE7QUFDYix1QkFBdUI7QUFDdkI7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixjQUFjO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsdUJBQXVCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGNBQWM7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSw4Q0FBRTtBQUNaO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGFBQWE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsV0FBVyxhQUFhLFFBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7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QUNBO0FBQ0E7QUFDQTtBQUNBLG1GQUFtRjtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsc0JBQXNCO0FBQzNDO0FBQ0E7QUFDQSxjQUFjO0FBQ2QscUJBQXFCLHNCQUFzQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsS0FBSztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUU7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELGlDQUFpQztBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsSUFBSTtBQUNKO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsaUNBQWlDLFNBQVM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsU0FBUztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUMsK0NBQStDO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixTQUFTO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsU0FBUztBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsU0FBUztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixHQUFHO0FBQ3RCO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFNBQVM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELFNBQVM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxTQUFTO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FB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QUFFLFNBQVMsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLGFBQWEsRUFBRSxNQUFNLEVBQUUsZ0RBQWdELEVBQUUsR0FBRyxFQUFFLFNBQVMsRUFBRSxHQUFHLEVBQUUsRUFBRSxFQUFFLHdFQUF3RSxFQUFFLEdBQUcsRUFBRSxTQUFTLEVBQUUsR0FBRyxFQUFFLGFBQWEsRUFBRSxNQUFNLEVBQUUsK0ZBQStGLEVBQUUsR0FBRyxFQUFFLFNBQVMsRUFBRSxHQUFHLEVBQUUsYUFBYSxFQUFFLE1BQU0sRUFBRSxvQkFBb0IsRUFBRSxHQUFHLEVBQUUsU0FBUyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsYUFBYSxFQUFFLE1BQU0sRUFBRSw0REFBNEQsRUFBRSxHQUFHLEVBQUUsU0FBUyxFQUFFLEdBQUcsRUFBRSxFQUFFLEVBQUUsa0JBQWtCLEVBQUUsR0FBRyxFQUFFLFNBQVMsRUFBRSxhQUFhLEVBQUUsTUFBTSxFQUFFLHFEQUFxRCxFQUFFLEdBQUcsRUFBRSxTQUFTLEVBQUUsR0FBRyxFQUFFLEVBQUUsRUFBRSx3RUFBd0UsRUFBRSxHQUFHLEVBQUUsU0FBUyxFQUFFLEdBQUcsRUFBRSxhQUFhLEVBQUUsTUFBTSxFQUFFLCtGQUErRixFQUFFLEdBQUcsRUFBRSxTQUFTLEVBQUUsR0FBRyxFQUFFLGFBQWEsRUFBRSxNQUFNLEVBQUUsb0JBQW9CLEVBQUUsR0FBRyxFQUFFLFNBQVMsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLGFBQWEsRUFBRSxNQUFNLEVBQUUsMkRBQTJELEVBQUUsR0FBRyxFQUFFLFNBQVMsRUFBRSxHQUFHLEVBQUUsRUFBRSxFQUFFLHdFQUF3RSxFQUFFLEdBQUcsRUFBRSxTQUFTLEVBQUUsR0FBRyxFQUFFLGFBQWEsRUFBRSxNQUFNLEVBQUUsK0ZBQStGLEVBQUUsR0FBRyxFQUFFLFNBQVMsRUFBRSxHQUFHLEVBQUUsYUFBYSxFQUFFLE1BQU0sRUFBRSxvQkFBb0IsRUFBRSxHQUFHLEVBQUUsU0FBUyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsYUFBYSxFQUFFLE1BQU0sRUFBRSxrRUFBa0UsRUFBRSw4QkFBOEIsRUFBRSxrQkFBa0IsRUFBRSxrREFBa0QsRUFBRSxvQkFBb0IsRUFBRSw4REFBOEQsRUFBRTtBQUNsaEU7QUFDQTtBQUNBO0FBQ0E7QUFXRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGd1c21hbm8vcmVleHQvZGlzdC9yZWV4dC5lcy5qcz9jMGQ3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBvciwgeyB1c2VTdGF0ZSBhcyBEZSwgdXNlUmVmIGFzIEhlLCB1c2VFZmZlY3QgYXMgc3IsIGNsb25lRWxlbWVudCBhcyBvYSB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgY3JlYXRlUG9ydGFsIGFzIGVyIH0gZnJvbSBcInJlYWN0LWRvbVwiO1xuZnVuY3Rpb24gc2EoZSkge1xuICByZXR1cm4gZSAmJiBlLl9fZXNNb2R1bGUgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsIFwiZGVmYXVsdFwiKSA/IGUuZGVmYXVsdCA6IGU7XG59XG52YXIgc24gPSB7IGV4cG9ydHM6IHt9IH0sIEogPSBzbi5leHBvcnRzID0ge30sIGhlLCBiZTtcbmZ1bmN0aW9uIExyKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoXCJzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkXCIpO1xufVxuZnVuY3Rpb24gRnIoKSB7XG4gIHRocm93IG5ldyBFcnJvcihcImNsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZFwiKTtcbn1cbihmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICB0eXBlb2Ygc2V0VGltZW91dCA9PSBcImZ1bmN0aW9uXCIgPyBoZSA9IHNldFRpbWVvdXQgOiBoZSA9IExyO1xuICB9IGNhdGNoIHtcbiAgICBoZSA9IExyO1xuICB9XG4gIHRyeSB7XG4gICAgdHlwZW9mIGNsZWFyVGltZW91dCA9PSBcImZ1bmN0aW9uXCIgPyBiZSA9IGNsZWFyVGltZW91dCA6IGJlID0gRnI7XG4gIH0gY2F0Y2gge1xuICAgIGJlID0gRnI7XG4gIH1cbn0pKCk7XG5mdW5jdGlvbiBjbihlKSB7XG4gIGlmIChoZSA9PT0gc2V0VGltZW91dClcbiAgICByZXR1cm4gc2V0VGltZW91dChlLCAwKTtcbiAgaWYgKChoZSA9PT0gTHIgfHwgIWhlKSAmJiBzZXRUaW1lb3V0KVxuICAgIHJldHVybiBoZSA9IHNldFRpbWVvdXQsIHNldFRpbWVvdXQoZSwgMCk7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGhlKGUsIDApO1xuICB9IGNhdGNoIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGhlLmNhbGwobnVsbCwgZSwgMCk7XG4gICAgfSBjYXRjaCB7XG4gICAgICByZXR1cm4gaGUuY2FsbCh0aGlzLCBlLCAwKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGNhKGUpIHtcbiAgaWYgKGJlID09PSBjbGVhclRpbWVvdXQpXG4gICAgcmV0dXJuIGNsZWFyVGltZW91dChlKTtcbiAgaWYgKChiZSA9PT0gRnIgfHwgIWJlKSAmJiBjbGVhclRpbWVvdXQpXG4gICAgcmV0dXJuIGJlID0gY2xlYXJUaW1lb3V0LCBjbGVhclRpbWVvdXQoZSk7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGJlKGUpO1xuICB9IGNhdGNoIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGJlLmNhbGwobnVsbCwgZSk7XG4gICAgfSBjYXRjaCB7XG4gICAgICByZXR1cm4gYmUuY2FsbCh0aGlzLCBlKTtcbiAgICB9XG4gIH1cbn1cbnZhciBFZSA9IFtdLCBNZSA9ICExLCBQZSwgYXIgPSAtMTtcbmZ1bmN0aW9uIGxhKCkge1xuICAhTWUgfHwgIVBlIHx8IChNZSA9ICExLCBQZS5sZW5ndGggPyBFZSA9IFBlLmNvbmNhdChFZSkgOiBhciA9IC0xLCBFZS5sZW5ndGggJiYgbG4oKSk7XG59XG5mdW5jdGlvbiBsbigpIHtcbiAgaWYgKCFNZSkge1xuICAgIHZhciBlID0gY24obGEpO1xuICAgIE1lID0gITA7XG4gICAgZm9yICh2YXIgciA9IEVlLmxlbmd0aDsgcjsgKSB7XG4gICAgICBmb3IgKFBlID0gRWUsIEVlID0gW107ICsrYXIgPCByOyApXG4gICAgICAgIFBlICYmIFBlW2FyXS5ydW4oKTtcbiAgICAgIGFyID0gLTEsIHIgPSBFZS5sZW5ndGg7XG4gICAgfVxuICAgIFBlID0gbnVsbCwgTWUgPSAhMSwgY2EoZSk7XG4gIH1cbn1cbkoubmV4dFRpY2sgPSBmdW5jdGlvbihlKSB7XG4gIHZhciByID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKVxuICAgIGZvciAodmFyIHQgPSAxOyB0IDwgYXJndW1lbnRzLmxlbmd0aDsgdCsrKVxuICAgICAgclt0IC0gMV0gPSBhcmd1bWVudHNbdF07XG4gIEVlLnB1c2gobmV3IHVuKGUsIHIpKSwgRWUubGVuZ3RoID09PSAxICYmICFNZSAmJiBjbihsbik7XG59O1xuZnVuY3Rpb24gdW4oZSwgcikge1xuICB0aGlzLmZ1biA9IGUsIHRoaXMuYXJyYXkgPSByO1xufVxudW4ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5KLnRpdGxlID0gXCJicm93c2VyXCI7XG5KLmJyb3dzZXIgPSAhMDtcbkouZW52ID0ge307XG5KLmFyZ3YgPSBbXTtcbkoudmVyc2lvbiA9IFwiXCI7XG5KLnZlcnNpb25zID0ge307XG5mdW5jdGlvbiB3ZSgpIHtcbn1cbkoub24gPSB3ZTtcbkouYWRkTGlzdGVuZXIgPSB3ZTtcbkoub25jZSA9IHdlO1xuSi5vZmYgPSB3ZTtcbkoucmVtb3ZlTGlzdGVuZXIgPSB3ZTtcbkoucmVtb3ZlQWxsTGlzdGVuZXJzID0gd2U7XG5KLmVtaXQgPSB3ZTtcbkoucHJlcGVuZExpc3RlbmVyID0gd2U7XG5KLnByZXBlbmRPbmNlTGlzdGVuZXIgPSB3ZTtcbkoubGlzdGVuZXJzID0gZnVuY3Rpb24oZSkge1xuICByZXR1cm4gW107XG59O1xuSi5iaW5kaW5nID0gZnVuY3Rpb24oZSkge1xuICB0aHJvdyBuZXcgRXJyb3IoXCJwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZFwiKTtcbn07XG5KLmN3ZCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gXCIvXCI7XG59O1xuSi5jaGRpciA9IGZ1bmN0aW9uKGUpIHtcbiAgdGhyb3cgbmV3IEVycm9yKFwicHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkXCIpO1xufTtcbkoudW1hc2sgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIDA7XG59O1xudmFyIHVhID0gc24uZXhwb3J0cztcbmNvbnN0IHNlID0gLyogQF9fUFVSRV9fICovIHNhKHVhKTtcbnZhciByciA9IHR5cGVvZiBnbG9iYWxUaGlzIDwgXCJ1XCIgPyBnbG9iYWxUaGlzIDogdHlwZW9mIHdpbmRvdyA8IFwidVwiID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCA8IFwidVwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgPCBcInVcIiA/IHNlbGYgOiB7fTtcbmZ1bmN0aW9uIGtyKGUpIHtcbiAgcmV0dXJuIGUgJiYgZS5fX2VzTW9kdWxlICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLCBcImRlZmF1bHRcIikgPyBlLmRlZmF1bHQgOiBlO1xufVxudmFyIE5yID0geyBleHBvcnRzOiB7fSB9LCBXZSA9IHt9LCBmdDtcbmZ1bmN0aW9uIGZhKCkge1xuICByZXR1cm4gZnQgfHwgKGZ0ID0gMSwgc2UuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBmdW5jdGlvbigpIHtcbiAgICB2YXIgZSA9IG9yLCByID0gU3ltYm9sLmZvcihcInJlYWN0LmVsZW1lbnRcIiksIHQgPSBTeW1ib2wuZm9yKFwicmVhY3QucG9ydGFsXCIpLCBuID0gU3ltYm9sLmZvcihcInJlYWN0LmZyYWdtZW50XCIpLCBjID0gU3ltYm9sLmZvcihcInJlYWN0LnN0cmljdF9tb2RlXCIpLCBpID0gU3ltYm9sLmZvcihcInJlYWN0LnByb2ZpbGVyXCIpLCBsID0gU3ltYm9sLmZvcihcInJlYWN0LnByb3ZpZGVyXCIpLCBvID0gU3ltYm9sLmZvcihcInJlYWN0LmNvbnN1bWVyXCIpLCBwID0gU3ltYm9sLmZvcihcInJlYWN0LmNvbnRleHRcIiksIHUgPSBTeW1ib2wuZm9yKFwicmVhY3QuZm9yd2FyZF9yZWZcIiksIGYgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3VzcGVuc2VcIiksIGggPSBTeW1ib2wuZm9yKFwicmVhY3Quc3VzcGVuc2VfbGlzdFwiKSwgXyA9IFN5bWJvbC5mb3IoXCJyZWFjdC5tZW1vXCIpLCBNID0gU3ltYm9sLmZvcihcInJlYWN0LmxhenlcIiksIEYgPSBTeW1ib2wuZm9yKFwicmVhY3Qub2Zmc2NyZWVuXCIpLCBBID0gU3ltYm9sLmZvcihcInJlYWN0LmNhY2hlXCIpLCBkID0gU3ltYm9sLml0ZXJhdG9yLCBZID0gXCJAQGl0ZXJhdG9yXCI7XG4gICAgZnVuY3Rpb24gUShhKSB7XG4gICAgICBpZiAoYSA9PT0gbnVsbCB8fCB0eXBlb2YgYSAhPSBcIm9iamVjdFwiKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIHZhciAkID0gZCAmJiBhW2RdIHx8IGFbWV07XG4gICAgICByZXR1cm4gdHlwZW9mICQgPT0gXCJmdW5jdGlvblwiID8gJCA6IG51bGw7XG4gICAgfVxuICAgIHZhciB3ID0gZS5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDtcbiAgICBmdW5jdGlvbiBOKGEpIHtcbiAgICAgIHtcbiAgICAgICAgZm9yICh2YXIgJCA9IGFyZ3VtZW50cy5sZW5ndGgsIFMgPSBuZXcgQXJyYXkoJCA+IDEgPyAkIC0gMSA6IDApLCBxID0gMTsgcSA8ICQ7IHErKylcbiAgICAgICAgICBTW3EgLSAxXSA9IGFyZ3VtZW50c1txXTtcbiAgICAgICAgeShcImVycm9yXCIsIGEsIFMpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB5KGEsICQsIFMpIHtcbiAgICAgIHtcbiAgICAgICAgdmFyIHEgPSB3LlJlYWN0RGVidWdDdXJyZW50RnJhbWUsIFYgPSBxLmdldFN0YWNrQWRkZW5kdW0oKTtcbiAgICAgICAgViAhPT0gXCJcIiAmJiAoJCArPSBcIiVzXCIsIFMgPSBTLmNvbmNhdChbVl0pKTtcbiAgICAgICAgdmFyIFggPSBTLm1hcChmdW5jdGlvbih0ZSkge1xuICAgICAgICAgIHJldHVybiBTdHJpbmcodGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgWC51bnNoaWZ0KFwiV2FybmluZzogXCIgKyAkKSwgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZVthXSwgY29uc29sZSwgWCk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciB2ZSA9ICExLCBwZSA9ICExLCBtZSA9ICExLCB5ZSA9ICExLCB4ZSA9ICEwLCBfZSA9IHhlLCBnZSA9ICExO1xuICAgIGZ1bmN0aW9uIFRlKGEsICQsIFMpIHtcbiAgICAgIHZhciBxID0gYS5kaXNwbGF5TmFtZTtcbiAgICAgIGlmIChxKVxuICAgICAgICByZXR1cm4gcTtcbiAgICAgIHZhciBWID0gJC5kaXNwbGF5TmFtZSB8fCAkLm5hbWUgfHwgXCJcIjtcbiAgICAgIHJldHVybiBWICE9PSBcIlwiID8gUyArIFwiKFwiICsgViArIFwiKVwiIDogUztcbiAgICB9XG4gICAgZnVuY3Rpb24gZyhhKSB7XG4gICAgICByZXR1cm4gYS5kaXNwbGF5TmFtZSB8fCBcIkNvbnRleHRcIjtcbiAgICB9XG4gICAgdmFyIEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuY2xpZW50LnJlZmVyZW5jZVwiKTtcbiAgICBmdW5jdGlvbiB4KGEpIHtcbiAgICAgIGlmIChhID09IG51bGwpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgaWYgKHR5cGVvZiBhID09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgcmV0dXJuIGEuJCR0eXBlb2YgPT09IEUgPyBudWxsIDogYS5kaXNwbGF5TmFtZSB8fCBhLm5hbWUgfHwgbnVsbDtcbiAgICAgIGlmICh0eXBlb2YgYSA9PSBcInN0cmluZ1wiKVxuICAgICAgICByZXR1cm4gYTtcbiAgICAgIHN3aXRjaCAoYSkge1xuICAgICAgICBjYXNlIG46XG4gICAgICAgICAgcmV0dXJuIFwiRnJhZ21lbnRcIjtcbiAgICAgICAgY2FzZSB0OlxuICAgICAgICAgIHJldHVybiBcIlBvcnRhbFwiO1xuICAgICAgICBjYXNlIGk6XG4gICAgICAgICAgcmV0dXJuIFwiUHJvZmlsZXJcIjtcbiAgICAgICAgY2FzZSBjOlxuICAgICAgICAgIHJldHVybiBcIlN0cmljdE1vZGVcIjtcbiAgICAgICAgY2FzZSBmOlxuICAgICAgICAgIHJldHVybiBcIlN1c3BlbnNlXCI7XG4gICAgICAgIGNhc2UgaDpcbiAgICAgICAgICByZXR1cm4gXCJTdXNwZW5zZUxpc3RcIjtcbiAgICAgICAgY2FzZSBBOlxuICAgICAgICAgIHJldHVybiBcIkNhY2hlXCI7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGEgPT0gXCJvYmplY3RcIilcbiAgICAgICAgc3dpdGNoICh0eXBlb2YgYS50YWcgPT0gXCJudW1iZXJcIiAmJiBOKFwiUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKCkuIFRoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIiksIGEuJCR0eXBlb2YpIHtcbiAgICAgICAgICBjYXNlIGw6IHtcbiAgICAgICAgICAgIHZhciAkID0gYTtcbiAgICAgICAgICAgIHJldHVybiBnKCQuX2NvbnRleHQpICsgXCIuUHJvdmlkZXJcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBwOlxuICAgICAgICAgICAgdmFyIFMgPSBhO1xuICAgICAgICAgICAgcmV0dXJuIGcoUykgKyBcIi5Db25zdW1lclwiO1xuICAgICAgICAgIGNhc2UgbzpcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIGNhc2UgdTpcbiAgICAgICAgICAgIHJldHVybiBUZShhLCBhLnJlbmRlciwgXCJGb3J3YXJkUmVmXCIpO1xuICAgICAgICAgIGNhc2UgXzpcbiAgICAgICAgICAgIHZhciBxID0gYS5kaXNwbGF5TmFtZSB8fCBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIHEgIT09IG51bGwgPyBxIDogeChhLnR5cGUpIHx8IFwiTWVtb1wiO1xuICAgICAgICAgIGNhc2UgTToge1xuICAgICAgICAgICAgdmFyIFYgPSBhLCBYID0gVi5fcGF5bG9hZCwgdGUgPSBWLl9pbml0O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcmV0dXJuIHgodGUoWCkpO1xuICAgICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBUID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSwgbSA9IE9iamVjdC5hc3NpZ247XG4gICAgZnVuY3Rpb24gTChhKSB7XG4gICAgICB7XG4gICAgICAgIHZhciAkID0gdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLnRvU3RyaW5nVGFnLCBTID0gJCAmJiBhW1N5bWJvbC50b1N0cmluZ1RhZ10gfHwgYS5jb25zdHJ1Y3Rvci5uYW1lIHx8IFwiT2JqZWN0XCI7XG4gICAgICAgIHJldHVybiBTO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBzKGEpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB2KGEpLCAhMTtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgICByZXR1cm4gITA7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHYoYSkge1xuICAgICAgcmV0dXJuIFwiXCIgKyBhO1xuICAgIH1cbiAgICBmdW5jdGlvbiBDKGEpIHtcbiAgICAgIGlmIChzKGEpKVxuICAgICAgICByZXR1cm4gTihcIlRoZSBwcm92aWRlZCBrZXkgaXMgYW4gdW5zdXBwb3J0ZWQgdHlwZSAlcy4gVGhpcyB2YWx1ZSBtdXN0IGJlIGNvZXJjZWQgdG8gYSBzdHJpbmcgYmVmb3JlIHVzaW5nIGl0IGhlcmUuXCIsIEwoYSkpLCB2KGEpO1xuICAgIH1cbiAgICB2YXIgTyA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jbGllbnQucmVmZXJlbmNlXCIpO1xuICAgIGZ1bmN0aW9uIFIoYSkge1xuICAgICAgcmV0dXJuICEhKHR5cGVvZiBhID09IFwic3RyaW5nXCIgfHwgdHlwZW9mIGEgPT0gXCJmdW5jdGlvblwiIHx8IGEgPT09IG4gfHwgYSA9PT0gaSB8fCBnZSB8fCBhID09PSBjIHx8IGEgPT09IGYgfHwgYSA9PT0gaCB8fCBtZSB8fCBhID09PSBGIHx8IHZlIHx8IGEgPT09IEEgfHwgcGUgfHwgdHlwZW9mIGEgPT0gXCJvYmplY3RcIiAmJiBhICE9PSBudWxsICYmIChhLiQkdHlwZW9mID09PSBNIHx8IGEuJCR0eXBlb2YgPT09IF8gfHwgYS4kJHR5cGVvZiA9PT0gcCB8fCBhLiQkdHlwZW9mID09PSBsIHx8IHllIHx8IGEuJCR0eXBlb2YgPT09IHUgfHwgLy8gVGhpcyBuZWVkcyB0byBpbmNsdWRlIGFsbCBwb3NzaWJsZSBtb2R1bGUgcmVmZXJlbmNlIG9iamVjdFxuICAgICAgLy8gdHlwZXMgc3VwcG9ydGVkIGJ5IGFueSBGbGlnaHQgY29uZmlndXJhdGlvbiBhbnl3aGVyZSBzaW5jZVxuICAgICAgLy8gd2UgZG9uJ3Qga25vdyB3aGljaCBGbGlnaHQgYnVpbGQgdGhpcyB3aWxsIGVuZCB1cCBiZWluZyB1c2VkXG4gICAgICAvLyB3aXRoLlxuICAgICAgYS4kJHR5cGVvZiA9PT0gTyB8fCBhLmdldE1vZHVsZUlkICE9PSB2b2lkIDApKTtcbiAgICB9XG4gICAgdmFyIFAgPSBBcnJheS5pc0FycmF5O1xuICAgIGZ1bmN0aW9uIEQoYSkge1xuICAgICAgcmV0dXJuIFAoYSk7XG4gICAgfVxuICAgIHZhciBJID0gMCwgVSwgRywgQiwgcmUsIGIsIGllLCBPZTtcbiAgICBmdW5jdGlvbiBZZSgpIHtcbiAgICB9XG4gICAgWWUuX19yZWFjdERpc2FibGVkTG9nID0gITA7XG4gICAgZnVuY3Rpb24gcW4oKSB7XG4gICAgICB7XG4gICAgICAgIGlmIChJID09PSAwKSB7XG4gICAgICAgICAgVSA9IGNvbnNvbGUubG9nLCBHID0gY29uc29sZS5pbmZvLCBCID0gY29uc29sZS53YXJuLCByZSA9IGNvbnNvbGUuZXJyb3IsIGIgPSBjb25zb2xlLmdyb3VwLCBpZSA9IGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQsIE9lID0gY29uc29sZS5ncm91cEVuZDtcbiAgICAgICAgICB2YXIgYSA9IHtcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgICAgICAgIHZhbHVlOiBZZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiAhMFxuICAgICAgICAgIH07XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICAgICAgaW5mbzogYSxcbiAgICAgICAgICAgIGxvZzogYSxcbiAgICAgICAgICAgIHdhcm46IGEsXG4gICAgICAgICAgICBlcnJvcjogYSxcbiAgICAgICAgICAgIGdyb3VwOiBhLFxuICAgICAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IGEsXG4gICAgICAgICAgICBncm91cEVuZDogYVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIEkrKztcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gWW4oKSB7XG4gICAgICB7XG4gICAgICAgIGlmIChJLS0sIEkgPT09IDApIHtcbiAgICAgICAgICB2YXIgYSA9IHtcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgICAgICAgIHdyaXRhYmxlOiAhMFxuICAgICAgICAgIH07XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICAgICAgbG9nOiBtKHt9LCBhLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiBVXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGluZm86IG0oe30sIGEsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IEdcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgd2FybjogbSh7fSwgYSwge1xuICAgICAgICAgICAgICB2YWx1ZTogQlxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBlcnJvcjogbSh7fSwgYSwge1xuICAgICAgICAgICAgICB2YWx1ZTogcmVcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgZ3JvdXA6IG0oe30sIGEsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IGJcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IG0oe30sIGEsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IGllXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGdyb3VwRW5kOiBtKHt9LCBhLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiBPZVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBJIDwgMCAmJiBOKFwiZGlzYWJsZWREZXB0aCBmZWxsIGJlbG93IHplcm8uIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHhyID0gdy5SZWFjdEN1cnJlbnREaXNwYXRjaGVyLCBfcjtcbiAgICBmdW5jdGlvbiBKZShhLCAkKSB7XG4gICAgICB7XG4gICAgICAgIGlmIChfciA9PT0gdm9pZCAwKVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgIH0gY2F0Y2ggKHEpIHtcbiAgICAgICAgICAgIHZhciBTID0gcS5zdGFjay50cmltKCkubWF0Y2goL1xcbiggKihhdCApPykvKTtcbiAgICAgICAgICAgIF9yID0gUyAmJiBTWzFdIHx8IFwiXCI7XG4gICAgICAgICAgfVxuICAgICAgICByZXR1cm4gYFxuYCArIF9yICsgYTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIEVyID0gITEsIFhlO1xuICAgIHtcbiAgICAgIHZhciBHbiA9IHR5cGVvZiBXZWFrTWFwID09IFwiZnVuY3Rpb25cIiA/IFdlYWtNYXAgOiBNYXA7XG4gICAgICBYZSA9IG5ldyBHbigpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBudChhLCAkKSB7XG4gICAgICBpZiAoIWEgfHwgRXIpXG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgICAge1xuICAgICAgICB2YXIgUyA9IFhlLmdldChhKTtcbiAgICAgICAgaWYgKFMgIT09IHZvaWQgMClcbiAgICAgICAgICByZXR1cm4gUztcbiAgICAgIH1cbiAgICAgIEVyID0gITA7XG4gICAgICB2YXIgcSA9IEVycm9yLnByZXBhcmVTdGFja1RyYWNlO1xuICAgICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSB2b2lkIDA7XG4gICAgICB2YXIgVjtcbiAgICAgIFYgPSB4ci5jdXJyZW50LCB4ci5jdXJyZW50ID0gbnVsbCwgcW4oKTtcbiAgICAgIHZhciBYID0ge1xuICAgICAgICBEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBBZTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKCQpIHtcbiAgICAgICAgICAgICAgdmFyIFJlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZS5wcm90b3R5cGUsIFwicHJvcHNcIiwge1xuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSksIHR5cGVvZiBSZWZsZWN0ID09IFwib2JqZWN0XCIgJiYgUmVmbGVjdC5jb25zdHJ1Y3QpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoUmUsIFtdKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChmZSkge1xuICAgICAgICAgICAgICAgICAgQWUgPSBmZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoYSwgW10sIFJlKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgUmUuY2FsbCgpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGZlKSB7XG4gICAgICAgICAgICAgICAgICBBZSA9IGZlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhLmNhbGwoUmUucHJvdG90eXBlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgICAgICB9IGNhdGNoIChmZSkge1xuICAgICAgICAgICAgICAgIEFlID0gZmU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFyIEdlID0gYSgpO1xuICAgICAgICAgICAgICBHZSAmJiB0eXBlb2YgR2UuY2F0Y2ggPT0gXCJmdW5jdGlvblwiICYmIEdlLmNhdGNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChmZSkge1xuICAgICAgICAgICAgaWYgKGZlICYmIEFlICYmIHR5cGVvZiBmZS5zdGFjayA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICByZXR1cm4gW2ZlLnN0YWNrLCBBZS5zdGFja107XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBbbnVsbCwgbnVsbF07XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBYLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdC5kaXNwbGF5TmFtZSA9IFwiRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290XCI7XG4gICAgICB2YXIgdGUgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFguRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290LCBcIm5hbWVcIik7XG4gICAgICB0ZSAmJiB0ZS5jb25maWd1cmFibGUgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KFxuICAgICAgICBYLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCxcbiAgICAgICAgLy8gQ29uZmlndXJhYmxlIHByb3BlcnRpZXMgY2FuIGJlIHVwZGF0ZWQgZXZlbiBpZiBpdHMgd3JpdGFibGUgZGVzY3JpcHRvclxuICAgICAgICAvLyBpcyBzZXQgdG8gYGZhbHNlYC5cbiAgICAgICAgLy8gJEZsb3dGaXhNZVtjYW5ub3Qtd3JpdGVdXG4gICAgICAgIFwibmFtZVwiLFxuICAgICAgICB7XG4gICAgICAgICAgdmFsdWU6IFwiRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290XCJcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBjZSA9IFguRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290KCksIGxlID0gY2VbMF0sIG5lID0gY2VbMV07XG4gICAgICAgIGlmIChsZSAmJiBuZSkge1xuICAgICAgICAgIGZvciAodmFyIG9lID0gbGUuc3BsaXQoYFxuYCksIHVlID0gbmUuc3BsaXQoYFxuYCksIFogPSAwLCBlZSA9IDA7IFogPCBvZS5sZW5ndGggJiYgIW9lW1pdLmluY2x1ZGVzKFwiRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290XCIpOyApXG4gICAgICAgICAgICBaKys7XG4gICAgICAgICAgZm9yICg7IGVlIDwgdWUubGVuZ3RoICYmICF1ZVtlZV0uaW5jbHVkZXMoXCJEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3RcIik7IClcbiAgICAgICAgICAgIGVlKys7XG4gICAgICAgICAgaWYgKFogPT09IG9lLmxlbmd0aCB8fCBlZSA9PT0gdWUubGVuZ3RoKVxuICAgICAgICAgICAgZm9yIChaID0gb2UubGVuZ3RoIC0gMSwgZWUgPSB1ZS5sZW5ndGggLSAxOyBaID49IDEgJiYgZWUgPj0gMCAmJiBvZVtaXSAhPT0gdWVbZWVdOyApXG4gICAgICAgICAgICAgIGVlLS07XG4gICAgICAgICAgZm9yICg7IFogPj0gMSAmJiBlZSA+PSAwOyBaLS0sIGVlLS0pXG4gICAgICAgICAgICBpZiAob2VbWl0gIT09IHVlW2VlXSkge1xuICAgICAgICAgICAgICBpZiAoWiAhPT0gMSB8fCBlZSAhPT0gMSlcbiAgICAgICAgICAgICAgICBkb1xuICAgICAgICAgICAgICAgICAgaWYgKFotLSwgZWUtLSwgZWUgPCAwIHx8IG9lW1pdICE9PSB1ZVtlZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFlID0gYFxuYCArIG9lW1pdLnJlcGxhY2UoXCIgYXQgbmV3IFwiLCBcIiBhdCBcIik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhLmRpc3BsYXlOYW1lICYmIGFlLmluY2x1ZGVzKFwiPGFub255bW91cz5cIikgJiYgKGFlID0gYWUucmVwbGFjZShcIjxhbm9ueW1vdXM+XCIsIGEuZGlzcGxheU5hbWUpKSwgdHlwZW9mIGEgPT0gXCJmdW5jdGlvblwiICYmIFhlLnNldChhLCBhZSksIGFlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdoaWxlIChaID49IDEgJiYgZWUgPj0gMCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBFciA9ICExLCB4ci5jdXJyZW50ID0gViwgWW4oKSwgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBxO1xuICAgICAgfVxuICAgICAgdmFyIENlID0gYSA/IGEuZGlzcGxheU5hbWUgfHwgYS5uYW1lIDogXCJcIiwgU2UgPSBDZSA/IEplKENlKSA6IFwiXCI7XG4gICAgICByZXR1cm4gdHlwZW9mIGEgPT0gXCJmdW5jdGlvblwiICYmIFhlLnNldChhLCBTZSksIFNlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBXbihhLCAkKSB7XG4gICAgICByZXR1cm4gbnQoYSwgITEpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBrbihhKSB7XG4gICAgICB2YXIgJCA9IGEucHJvdG90eXBlO1xuICAgICAgcmV0dXJuICEhKCQgJiYgJC5pc1JlYWN0Q29tcG9uZW50KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gd3IoYSwgJCkge1xuICAgICAgaWYgKGEgPT0gbnVsbClcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICBpZiAodHlwZW9mIGEgPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICByZXR1cm4gbnQoYSwga24oYSkpO1xuICAgICAgaWYgKHR5cGVvZiBhID09IFwic3RyaW5nXCIpXG4gICAgICAgIHJldHVybiBKZShhKTtcbiAgICAgIHN3aXRjaCAoYSkge1xuICAgICAgICBjYXNlIGY6XG4gICAgICAgICAgcmV0dXJuIEplKFwiU3VzcGVuc2VcIik7XG4gICAgICAgIGNhc2UgaDpcbiAgICAgICAgICByZXR1cm4gSmUoXCJTdXNwZW5zZUxpc3RcIik7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGEgPT0gXCJvYmplY3RcIilcbiAgICAgICAgc3dpdGNoIChhLiQkdHlwZW9mKSB7XG4gICAgICAgICAgY2FzZSB1OlxuICAgICAgICAgICAgcmV0dXJuIFduKGEucmVuZGVyKTtcbiAgICAgICAgICBjYXNlIF86XG4gICAgICAgICAgICByZXR1cm4gd3IoYS50eXBlLCAkKTtcbiAgICAgICAgICBjYXNlIE06IHtcbiAgICAgICAgICAgIHZhciBTID0gYSwgcSA9IFMuX3BheWxvYWQsIFYgPSBTLl9pbml0O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcmV0dXJuIHdyKFYocSksICQpO1xuICAgICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgdmFyIFplID0gdy5SZWFjdEN1cnJlbnRPd25lciwgYXQgPSB3LlJlYWN0RGVidWdDdXJyZW50RnJhbWUsIHpuID0gU3ltYm9sLmZvcihcInJlYWN0LmNsaWVudC5yZWZlcmVuY2VcIiksIGl0LCBUcjtcbiAgICBUciA9IHt9O1xuICAgIGZ1bmN0aW9uIEtuKGEpIHtcbiAgICAgIGlmIChULmNhbGwoYSwgXCJyZWZcIikpIHtcbiAgICAgICAgdmFyICQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGEsIFwicmVmXCIpLmdldDtcbiAgICAgICAgaWYgKCQgJiYgJC5pc1JlYWN0V2FybmluZylcbiAgICAgICAgICByZXR1cm4gITE7XG4gICAgICB9XG4gICAgICByZXR1cm4gYS5yZWYgIT09IHZvaWQgMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gSG4oYSkge1xuICAgICAgaWYgKFQuY2FsbChhLCBcImtleVwiKSkge1xuICAgICAgICB2YXIgJCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYSwgXCJrZXlcIikuZ2V0O1xuICAgICAgICBpZiAoJCAmJiAkLmlzUmVhY3RXYXJuaW5nKVxuICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhLmtleSAhPT0gdm9pZCAwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBWbihhLCAkKSB7XG4gICAgICB7XG4gICAgICAgIHZhciBTID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaXQgfHwgKGl0ID0gITAsIE4oXCIlczogYGtleWAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCBpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lIHZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgcHJvcC4gKGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvc3BlY2lhbC1wcm9wcylcIiwgJCkpO1xuICAgICAgICB9O1xuICAgICAgICBTLmlzUmVhY3RXYXJuaW5nID0gITAsIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhLCBcImtleVwiLCB7XG4gICAgICAgICAgZ2V0OiBTLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIEpuKCkge1xuICAgICAge1xuICAgICAgICB2YXIgYSA9IHgodGhpcy50eXBlKTtcbiAgICAgICAgVHJbYV0gfHwgKFRyW2FdID0gITAsIE4oXCJBY2Nlc3NpbmcgZWxlbWVudC5yZWYgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZC4gcmVmIGlzIG5vdyBhIHJlZ3VsYXIgcHJvcC4gSXQgd2lsbCBiZSByZW1vdmVkIGZyb20gdGhlIEpTWCBFbGVtZW50IHR5cGUgaW4gYSBmdXR1cmUgcmVsZWFzZS5cIikpO1xuICAgICAgICB2YXIgJCA9IHRoaXMucHJvcHMucmVmO1xuICAgICAgICByZXR1cm4gJCAhPT0gdm9pZCAwID8gJCA6IG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIFhuKGEsICQsIFMsIHEsIFYsIFgsIHRlKSB7XG4gICAgICB2YXIgY2U7XG4gICAgICB7XG4gICAgICAgIHZhciBsZSA9IHRlLnJlZjtcbiAgICAgICAgY2UgPSBsZSAhPT0gdm9pZCAwID8gbGUgOiBudWxsO1xuICAgICAgfVxuICAgICAgdmFyIG5lO1xuICAgICAgcmV0dXJuIG5lID0ge1xuICAgICAgICAvLyBUaGlzIHRhZyBhbGxvd3MgdXMgdG8gdW5pcXVlbHkgaWRlbnRpZnkgdGhpcyBhcyBhIFJlYWN0IEVsZW1lbnRcbiAgICAgICAgJCR0eXBlb2Y6IHIsXG4gICAgICAgIC8vIEJ1aWx0LWluIHByb3BlcnRpZXMgdGhhdCBiZWxvbmcgb24gdGhlIGVsZW1lbnRcbiAgICAgICAgdHlwZTogYSxcbiAgICAgICAga2V5OiAkLFxuICAgICAgICBwcm9wczogdGUsXG4gICAgICAgIC8vIFJlY29yZCB0aGUgY29tcG9uZW50IHJlc3BvbnNpYmxlIGZvciBjcmVhdGluZyB0aGlzIGVsZW1lbnQuXG4gICAgICAgIF9vd25lcjogWFxuICAgICAgfSwgY2UgIT09IG51bGwgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmUsIFwicmVmXCIsIHtcbiAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgIGdldDogSm5cbiAgICAgIH0pIDogT2JqZWN0LmRlZmluZVByb3BlcnR5KG5lLCBcInJlZlwiLCB7XG4gICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICB2YWx1ZTogbnVsbFxuICAgICAgfSksIG5lLl9zdG9yZSA9IHt9LCBPYmplY3QuZGVmaW5lUHJvcGVydHkobmUuX3N0b3JlLCBcInZhbGlkYXRlZFwiLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITEsXG4gICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICB3cml0YWJsZTogITAsXG4gICAgICAgIHZhbHVlOiAhMVxuICAgICAgfSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZSwgXCJfZGVidWdJbmZvXCIsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMSxcbiAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgICAgdmFsdWU6IG51bGxcbiAgICAgIH0pLCBPYmplY3QuZnJlZXplICYmIChPYmplY3QuZnJlZXplKG5lLnByb3BzKSwgT2JqZWN0LmZyZWV6ZShuZSkpLCBuZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gWm4oYSwgJCwgUywgcSwgVikge1xuICAgICAge1xuICAgICAgICB2YXIgWCA9ICExO1xuICAgICAgICByZXR1cm4gc3QoYSwgJCwgUywgWCwgcSwgVik7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIFFuKGEsICQsIFMsIHEsIFYpIHtcbiAgICAgIHtcbiAgICAgICAgdmFyIFggPSAhMDtcbiAgICAgICAgcmV0dXJuIHN0KGEsICQsIFMsIFgsIHEsIFYpO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgb3QgPSB7fTtcbiAgICBmdW5jdGlvbiBzdChhLCAkLCBTLCBxLCBWLCBYKSB7XG4gICAgICB7XG4gICAgICAgIGlmIChSKGEpKSB7XG4gICAgICAgICAgdmFyIGxlID0gJC5jaGlsZHJlbjtcbiAgICAgICAgICBpZiAobGUgIT09IHZvaWQgMClcbiAgICAgICAgICAgIGlmIChxKVxuICAgICAgICAgICAgICBpZiAoRChsZSkpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBuZSA9IDA7IG5lIDwgbGUubGVuZ3RoOyBuZSsrKVxuICAgICAgICAgICAgICAgICAgY3QobGVbbmVdLCBhKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuZnJlZXplICYmIE9iamVjdC5mcmVlemUobGUpO1xuICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICBOKFwiUmVhY3QuanN4OiBTdGF0aWMgY2hpbGRyZW4gc2hvdWxkIGFsd2F5cyBiZSBhbiBhcnJheS4gWW91IGFyZSBsaWtlbHkgZXhwbGljaXRseSBjYWxsaW5nIFJlYWN0LmpzeHMgb3IgUmVhY3QuanN4REVWLiBVc2UgdGhlIEJhYmVsIHRyYW5zZm9ybSBpbnN0ZWFkLlwiKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgY3QobGUsIGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciB0ZSA9IFwiXCI7XG4gICAgICAgICAgKGEgPT09IHZvaWQgMCB8fCB0eXBlb2YgYSA9PSBcIm9iamVjdFwiICYmIGEgIT09IG51bGwgJiYgT2JqZWN0LmtleXMoYSkubGVuZ3RoID09PSAwKSAmJiAodGUgKz0gXCIgWW91IGxpa2VseSBmb3Jnb3QgdG8gZXhwb3J0IHlvdXIgY29tcG9uZW50IGZyb20gdGhlIGZpbGUgaXQncyBkZWZpbmVkIGluLCBvciB5b3UgbWlnaHQgaGF2ZSBtaXhlZCB1cCBkZWZhdWx0IGFuZCBuYW1lZCBpbXBvcnRzLlwiKTtcbiAgICAgICAgICB2YXIgY2U7XG4gICAgICAgICAgYSA9PT0gbnVsbCA/IGNlID0gXCJudWxsXCIgOiBEKGEpID8gY2UgPSBcImFycmF5XCIgOiBhICE9PSB2b2lkIDAgJiYgYS4kJHR5cGVvZiA9PT0gciA/IChjZSA9IFwiPFwiICsgKHgoYS50eXBlKSB8fCBcIlVua25vd25cIikgKyBcIiAvPlwiLCB0ZSA9IFwiIERpZCB5b3UgYWNjaWRlbnRhbGx5IGV4cG9ydCBhIEpTWCBsaXRlcmFsIGluc3RlYWQgb2YgYSBjb21wb25lbnQ/XCIpIDogY2UgPSB0eXBlb2YgYSwgTihcIlJlYWN0LmpzeDogdHlwZSBpcyBpbnZhbGlkIC0tIGV4cGVjdGVkIGEgc3RyaW5nIChmb3IgYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSBjb21wb25lbnRzKSBidXQgZ290OiAlcy4lc1wiLCBjZSwgdGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChULmNhbGwoJCwgXCJrZXlcIikpIHtcbiAgICAgICAgICB2YXIgb2UgPSB4KGEpLCB1ZSA9IE9iamVjdC5rZXlzKCQpLmZpbHRlcihmdW5jdGlvbihpYSkge1xuICAgICAgICAgICAgcmV0dXJuIGlhICE9PSBcImtleVwiO1xuICAgICAgICAgIH0pLCBaID0gdWUubGVuZ3RoID4gMCA/IFwie2tleTogc29tZUtleSwgXCIgKyB1ZS5qb2luKFwiOiAuLi4sIFwiKSArIFwiOiAuLi59XCIgOiBcIntrZXk6IHNvbWVLZXl9XCI7XG4gICAgICAgICAgaWYgKCFvdFtvZSArIFpdKSB7XG4gICAgICAgICAgICB2YXIgZWUgPSB1ZS5sZW5ndGggPiAwID8gXCJ7XCIgKyB1ZS5qb2luKFwiOiAuLi4sIFwiKSArIFwiOiAuLi59XCIgOiBcInt9XCI7XG4gICAgICAgICAgICBOKGBBIHByb3BzIG9iamVjdCBjb250YWluaW5nIGEgXCJrZXlcIiBwcm9wIGlzIGJlaW5nIHNwcmVhZCBpbnRvIEpTWDpcbiAgbGV0IHByb3BzID0gJXM7XG4gIDwlcyB7Li4ucHJvcHN9IC8+XG5SZWFjdCBrZXlzIG11c3QgYmUgcGFzc2VkIGRpcmVjdGx5IHRvIEpTWCB3aXRob3V0IHVzaW5nIHNwcmVhZDpcbiAgbGV0IHByb3BzID0gJXM7XG4gIDwlcyBrZXk9e3NvbWVLZXl9IHsuLi5wcm9wc30gLz5gLCBaLCBvZSwgZWUsIG9lKSwgb3Rbb2UgKyBaXSA9ICEwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgYWUsIENlID0ge30sIFNlID0gbnVsbCwgQWUgPSBudWxsO1xuICAgICAgICBTICE9PSB2b2lkIDAgJiYgKEMoUyksIFNlID0gXCJcIiArIFMpLCBIbigkKSAmJiAoQygkLmtleSksIFNlID0gXCJcIiArICQua2V5KSwgS24oJCk7XG4gICAgICAgIGZvciAoYWUgaW4gJClcbiAgICAgICAgICBULmNhbGwoJCwgYWUpICYmIC8vIFNraXAgb3ZlciByZXNlcnZlZCBwcm9wIG5hbWVzXG4gICAgICAgICAgYWUgIT09IFwia2V5XCIgJiYgX2UgJiYgKENlW2FlXSA9ICRbYWVdKTtcbiAgICAgICAgaWYgKGEgJiYgYS5kZWZhdWx0UHJvcHMpIHtcbiAgICAgICAgICB2YXIgUmUgPSBhLmRlZmF1bHRQcm9wcztcbiAgICAgICAgICBmb3IgKGFlIGluIFJlKVxuICAgICAgICAgICAgQ2VbYWVdID09PSB2b2lkIDAgJiYgKENlW2FlXSA9IFJlW2FlXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFNlIHx8ICFfZSkge1xuICAgICAgICAgIHZhciBHZSA9IHR5cGVvZiBhID09IFwiZnVuY3Rpb25cIiA/IGEuZGlzcGxheU5hbWUgfHwgYS5uYW1lIHx8IFwiVW5rbm93blwiIDogYTtcbiAgICAgICAgICBTZSAmJiBWbihDZSwgR2UpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmZSA9IFhuKGEsIFNlLCBBZSwgWCwgViwgWmUuY3VycmVudCwgQ2UpO1xuICAgICAgICByZXR1cm4gYSA9PT0gbiAmJiB0YShmZSksIGZlO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBlYSgpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKFplLmN1cnJlbnQpIHtcbiAgICAgICAgICB2YXIgYSA9IHgoWmUuY3VycmVudC50eXBlKTtcbiAgICAgICAgICBpZiAoYSlcbiAgICAgICAgICAgIHJldHVybiBgXG5cbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIFxcYGAgKyBhICsgXCJgLlwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjdChhLCAkKSB7XG4gICAgICB7XG4gICAgICAgIGlmICh0eXBlb2YgYSAhPSBcIm9iamVjdFwiIHx8ICFhKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKGEuJCR0eXBlb2YgIT09IHpuKVxuICAgICAgICAgIGlmIChEKGEpKVxuICAgICAgICAgICAgZm9yICh2YXIgUyA9IDA7IFMgPCBhLmxlbmd0aDsgUysrKSB7XG4gICAgICAgICAgICAgIHZhciBxID0gYVtTXTtcbiAgICAgICAgICAgICAgQ3IocSkgJiYgdXQocSwgJCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoQ3IoYSkpXG4gICAgICAgICAgICBhLl9zdG9yZSAmJiAoYS5fc3RvcmUudmFsaWRhdGVkID0gITApO1xuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIFYgPSBRKGEpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBWID09IFwiZnVuY3Rpb25cIiAmJiBWICE9PSBhLmVudHJpZXMpXG4gICAgICAgICAgICAgIGZvciAodmFyIFggPSBWLmNhbGwoYSksIHRlOyAhKHRlID0gWC5uZXh0KCkpLmRvbmU7IClcbiAgICAgICAgICAgICAgICBDcih0ZS52YWx1ZSkgJiYgdXQodGUudmFsdWUsICQpO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gQ3IoYSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiBhID09IFwib2JqZWN0XCIgJiYgYSAhPT0gbnVsbCAmJiBhLiQkdHlwZW9mID09PSByO1xuICAgIH1cbiAgICB2YXIgbHQgPSB7fTtcbiAgICBmdW5jdGlvbiB1dChhLCAkKSB7XG4gICAgICB7XG4gICAgICAgIGlmICghYS5fc3RvcmUgfHwgYS5fc3RvcmUudmFsaWRhdGVkIHx8IGEua2V5ICE9IG51bGwpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBhLl9zdG9yZS52YWxpZGF0ZWQgPSAhMDtcbiAgICAgICAgdmFyIFMgPSByYSgkKTtcbiAgICAgICAgaWYgKGx0W1NdKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbHRbU10gPSAhMDtcbiAgICAgICAgdmFyIHEgPSBcIlwiO1xuICAgICAgICBhICYmIGEuX293bmVyICYmIGEuX293bmVyICE9PSBaZS5jdXJyZW50ICYmIChxID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyB4KGEuX293bmVyLnR5cGUpICsgXCIuXCIpLCBRZShhKSwgTignRWFjaCBjaGlsZCBpbiBhIGxpc3Qgc2hvdWxkIGhhdmUgYSB1bmlxdWUgXCJrZXlcIiBwcm9wLiVzJXMgU2VlIGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsIFMsIHEpLCBRZShudWxsKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gUWUoYSkge1xuICAgICAgaWYgKGEpIHtcbiAgICAgICAgdmFyICQgPSBhLl9vd25lciwgUyA9IHdyKGEudHlwZSwgJCA/ICQudHlwZSA6IG51bGwpO1xuICAgICAgICBhdC5zZXRFeHRyYVN0YWNrRnJhbWUoUyk7XG4gICAgICB9IGVsc2VcbiAgICAgICAgYXQuc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByYShhKSB7XG4gICAgICB7XG4gICAgICAgIHZhciAkID0gZWEoKTtcbiAgICAgICAgaWYgKCEkKSB7XG4gICAgICAgICAgdmFyIFMgPSB4KGEpO1xuICAgICAgICAgIFMgJiYgKCQgPSBgXG5cbkNoZWNrIHRoZSB0b3AtbGV2ZWwgcmVuZGVyIGNhbGwgdXNpbmcgPGAgKyBTICsgXCI+LlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJDtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdGEoYSkge1xuICAgICAgZm9yICh2YXIgJCA9IE9iamVjdC5rZXlzKGEucHJvcHMpLCBTID0gMDsgUyA8ICQubGVuZ3RoOyBTKyspIHtcbiAgICAgICAgdmFyIHEgPSAkW1NdO1xuICAgICAgICBpZiAocSAhPT0gXCJjaGlsZHJlblwiICYmIHEgIT09IFwia2V5XCIpIHtcbiAgICAgICAgICBRZShhKSwgTihcIkludmFsaWQgcHJvcCBgJXNgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuIFJlYWN0LkZyYWdtZW50IGNhbiBvbmx5IGhhdmUgYGtleWAgYW5kIGBjaGlsZHJlbmAgcHJvcHMuXCIsIHEpLCBRZShudWxsKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB2YXIgbmEgPSBabiwgYWEgPSBRbjtcbiAgICBXZS5GcmFnbWVudCA9IG4sIFdlLmpzeCA9IG5hLCBXZS5qc3hzID0gYWE7XG4gIH0oKSksIFdlO1xufVxudmFyIGtlID0ge30sIGR0O1xuZnVuY3Rpb24gZGEoKSB7XG4gIGlmIChkdClcbiAgICByZXR1cm4ga2U7XG4gIGR0ID0gMTtcbiAgdmFyIGUgPSBvciwgciA9IFN5bWJvbC5mb3IoXCJyZWFjdC5lbGVtZW50XCIpLCB0ID0gU3ltYm9sLmZvcihcInJlYWN0LmZyYWdtZW50XCIpLCBuID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSwgYyA9IGUuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQuUmVhY3RDdXJyZW50T3duZXI7XG4gIGZ1bmN0aW9uIGkobCwgbywgcCkge1xuICAgIHZhciB1ID0ge30sIGYgPSBudWxsO1xuICAgIHAgIT09IHZvaWQgMCAmJiAoZiA9IFwiXCIgKyBwKSwgby5rZXkgIT09IHZvaWQgMCAmJiAoZiA9IFwiXCIgKyBvLmtleSk7XG4gICAgZm9yIChoIGluIG8pXG4gICAgICBuLmNhbGwobywgaCkgJiYgaCAhPT0gXCJrZXlcIiAmJiAodVtoXSA9IG9baF0pO1xuICAgIGlmIChsICYmIGwuZGVmYXVsdFByb3BzKVxuICAgICAgZm9yIChoIGluIG8gPSBsLmRlZmF1bHRQcm9wcywgbylcbiAgICAgICAgdVtoXSA9PT0gdm9pZCAwICYmICh1W2hdID0gb1toXSk7XG4gICAgdmFyIGggPSB1LnJlZjtcbiAgICByZXR1cm4geyAkJHR5cGVvZjogciwgdHlwZTogbCwga2V5OiBmLCByZWY6IGggIT09IHZvaWQgMCA/IGggOiBudWxsLCBwcm9wczogdSwgX293bmVyOiBjLmN1cnJlbnQgfTtcbiAgfVxuICByZXR1cm4ga2UuRnJhZ21lbnQgPSB0LCBrZS5qc3ggPSBpLCBrZS5qc3hzID0gaSwga2U7XG59XG5zZS5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gTnIuZXhwb3J0cyA9IGRhKCkgOiBOci5leHBvcnRzID0gZmEoKTtcbnZhciBqID0gTnIuZXhwb3J0cywgVXIgPSB7IGV4cG9ydHM6IHt9IH0sIFNyLCB2dDtcbmZ1bmN0aW9uIHpyKCkge1xuICBpZiAodnQpXG4gICAgcmV0dXJuIFNyO1xuICB2dCA9IDE7XG4gIHZhciBlID0gXCJTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRFwiO1xuICByZXR1cm4gU3IgPSBlLCBTcjtcbn1cbnZhciBSciwgcHQ7XG5mdW5jdGlvbiB2YSgpIHtcbiAgaWYgKHB0KVxuICAgIHJldHVybiBScjtcbiAgcHQgPSAxO1xuICB2YXIgZSA9IHpyKCk7XG4gIGZ1bmN0aW9uIHIoKSB7XG4gIH1cbiAgZnVuY3Rpb24gdCgpIHtcbiAgfVxuICByZXR1cm4gdC5yZXNldFdhcm5pbmdDYWNoZSA9IHIsIFJyID0gZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gbihsLCBvLCBwLCB1LCBmLCBoKSB7XG4gICAgICBpZiAoaCAhPT0gZSkge1xuICAgICAgICB2YXIgXyA9IG5ldyBFcnJvcihcbiAgICAgICAgICBcIkNhbGxpbmcgUHJvcFR5cGVzIHZhbGlkYXRvcnMgZGlyZWN0bHkgaXMgbm90IHN1cHBvcnRlZCBieSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UuIFVzZSBQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMoKSB0byBjYWxsIHRoZW0uIFJlYWQgbW9yZSBhdCBodHRwOi8vZmIubWUvdXNlLWNoZWNrLXByb3AtdHlwZXNcIlxuICAgICAgICApO1xuICAgICAgICB0aHJvdyBfLm5hbWUgPSBcIkludmFyaWFudCBWaW9sYXRpb25cIiwgXztcbiAgICAgIH1cbiAgICB9XG4gICAgbi5pc1JlcXVpcmVkID0gbjtcbiAgICBmdW5jdGlvbiBjKCkge1xuICAgICAgcmV0dXJuIG47XG4gICAgfVxuICAgIHZhciBpID0ge1xuICAgICAgYXJyYXk6IG4sXG4gICAgICBiaWdpbnQ6IG4sXG4gICAgICBib29sOiBuLFxuICAgICAgZnVuYzogbixcbiAgICAgIG51bWJlcjogbixcbiAgICAgIG9iamVjdDogbixcbiAgICAgIHN0cmluZzogbixcbiAgICAgIHN5bWJvbDogbixcbiAgICAgIGFueTogbixcbiAgICAgIGFycmF5T2Y6IGMsXG4gICAgICBlbGVtZW50OiBuLFxuICAgICAgZWxlbWVudFR5cGU6IG4sXG4gICAgICBpbnN0YW5jZU9mOiBjLFxuICAgICAgbm9kZTogbixcbiAgICAgIG9iamVjdE9mOiBjLFxuICAgICAgb25lT2Y6IGMsXG4gICAgICBvbmVPZlR5cGU6IGMsXG4gICAgICBzaGFwZTogYyxcbiAgICAgIGV4YWN0OiBjLFxuICAgICAgY2hlY2tQcm9wVHlwZXM6IHQsXG4gICAgICByZXNldFdhcm5pbmdDYWNoZTogclxuICAgIH07XG4gICAgcmV0dXJuIGkuUHJvcFR5cGVzID0gaSwgaTtcbiAgfSwgUnI7XG59XG52YXIgdHIgPSB7IGV4cG9ydHM6IHt9IH0sIFcgPSB7fSwgeXQ7XG5mdW5jdGlvbiBwYSgpIHtcbiAgcmV0dXJuIHl0IHx8ICh5dCA9IDEsIHNlLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgZnVuY3Rpb24oKSB7XG4gICAgdmFyIGUgPSB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuZm9yLCByID0gZSA/IFN5bWJvbC5mb3IoXCJyZWFjdC5lbGVtZW50XCIpIDogNjAxMDMsIHQgPSBlID8gU3ltYm9sLmZvcihcInJlYWN0LnBvcnRhbFwiKSA6IDYwMTA2LCBuID0gZSA/IFN5bWJvbC5mb3IoXCJyZWFjdC5mcmFnbWVudFwiKSA6IDYwMTA3LCBjID0gZSA/IFN5bWJvbC5mb3IoXCJyZWFjdC5zdHJpY3RfbW9kZVwiKSA6IDYwMTA4LCBpID0gZSA/IFN5bWJvbC5mb3IoXCJyZWFjdC5wcm9maWxlclwiKSA6IDYwMTE0LCBsID0gZSA/IFN5bWJvbC5mb3IoXCJyZWFjdC5wcm92aWRlclwiKSA6IDYwMTA5LCBvID0gZSA/IFN5bWJvbC5mb3IoXCJyZWFjdC5jb250ZXh0XCIpIDogNjAxMTAsIHAgPSBlID8gU3ltYm9sLmZvcihcInJlYWN0LmFzeW5jX21vZGVcIikgOiA2MDExMSwgdSA9IGUgPyBTeW1ib2wuZm9yKFwicmVhY3QuY29uY3VycmVudF9tb2RlXCIpIDogNjAxMTEsIGYgPSBlID8gU3ltYm9sLmZvcihcInJlYWN0LmZvcndhcmRfcmVmXCIpIDogNjAxMTIsIGggPSBlID8gU3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlXCIpIDogNjAxMTMsIF8gPSBlID8gU3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlX2xpc3RcIikgOiA2MDEyMCwgTSA9IGUgPyBTeW1ib2wuZm9yKFwicmVhY3QubWVtb1wiKSA6IDYwMTE1LCBGID0gZSA/IFN5bWJvbC5mb3IoXCJyZWFjdC5sYXp5XCIpIDogNjAxMTYsIEEgPSBlID8gU3ltYm9sLmZvcihcInJlYWN0LmJsb2NrXCIpIDogNjAxMjEsIGQgPSBlID8gU3ltYm9sLmZvcihcInJlYWN0LmZ1bmRhbWVudGFsXCIpIDogNjAxMTcsIFkgPSBlID8gU3ltYm9sLmZvcihcInJlYWN0LnJlc3BvbmRlclwiKSA6IDYwMTE4LCBRID0gZSA/IFN5bWJvbC5mb3IoXCJyZWFjdC5zY29wZVwiKSA6IDYwMTE5O1xuICAgIGZ1bmN0aW9uIHcoYikge1xuICAgICAgcmV0dXJuIHR5cGVvZiBiID09IFwic3RyaW5nXCIgfHwgdHlwZW9mIGIgPT0gXCJmdW5jdGlvblwiIHx8IC8vIE5vdGU6IGl0cyB0eXBlb2YgbWlnaHQgYmUgb3RoZXIgdGhhbiAnc3ltYm9sJyBvciAnbnVtYmVyJyBpZiBpdCdzIGEgcG9seWZpbGwuXG4gICAgICBiID09PSBuIHx8IGIgPT09IHUgfHwgYiA9PT0gaSB8fCBiID09PSBjIHx8IGIgPT09IGggfHwgYiA9PT0gXyB8fCB0eXBlb2YgYiA9PSBcIm9iamVjdFwiICYmIGIgIT09IG51bGwgJiYgKGIuJCR0eXBlb2YgPT09IEYgfHwgYi4kJHR5cGVvZiA9PT0gTSB8fCBiLiQkdHlwZW9mID09PSBsIHx8IGIuJCR0eXBlb2YgPT09IG8gfHwgYi4kJHR5cGVvZiA9PT0gZiB8fCBiLiQkdHlwZW9mID09PSBkIHx8IGIuJCR0eXBlb2YgPT09IFkgfHwgYi4kJHR5cGVvZiA9PT0gUSB8fCBiLiQkdHlwZW9mID09PSBBKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gTihiKSB7XG4gICAgICBpZiAodHlwZW9mIGIgPT0gXCJvYmplY3RcIiAmJiBiICE9PSBudWxsKSB7XG4gICAgICAgIHZhciBpZSA9IGIuJCR0eXBlb2Y7XG4gICAgICAgIHN3aXRjaCAoaWUpIHtcbiAgICAgICAgICBjYXNlIHI6XG4gICAgICAgICAgICB2YXIgT2UgPSBiLnR5cGU7XG4gICAgICAgICAgICBzd2l0Y2ggKE9lKSB7XG4gICAgICAgICAgICAgIGNhc2UgcDpcbiAgICAgICAgICAgICAgY2FzZSB1OlxuICAgICAgICAgICAgICBjYXNlIG46XG4gICAgICAgICAgICAgIGNhc2UgaTpcbiAgICAgICAgICAgICAgY2FzZSBjOlxuICAgICAgICAgICAgICBjYXNlIGg6XG4gICAgICAgICAgICAgICAgcmV0dXJuIE9lO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHZhciBZZSA9IE9lICYmIE9lLiQkdHlwZW9mO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoWWUpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgbzpcbiAgICAgICAgICAgICAgICAgIGNhc2UgZjpcbiAgICAgICAgICAgICAgICAgIGNhc2UgRjpcbiAgICAgICAgICAgICAgICAgIGNhc2UgTTpcbiAgICAgICAgICAgICAgICAgIGNhc2UgbDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFllO1xuICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGllO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIHQ6XG4gICAgICAgICAgICByZXR1cm4gaWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHkgPSBwLCB2ZSA9IHUsIHBlID0gbywgbWUgPSBsLCB5ZSA9IHIsIHhlID0gZiwgX2UgPSBuLCBnZSA9IEYsIFRlID0gTSwgZyA9IHQsIEUgPSBpLCB4ID0gYywgVCA9IGgsIG0gPSAhMTtcbiAgICBmdW5jdGlvbiBMKGIpIHtcbiAgICAgIHJldHVybiBtIHx8IChtID0gITAsIGNvbnNvbGUud2FybihcIlRoZSBSZWFjdElzLmlzQXN5bmNNb2RlKCkgYWxpYXMgaGFzIGJlZW4gZGVwcmVjYXRlZCwgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBSZWFjdCAxNysuIFVwZGF0ZSB5b3VyIGNvZGUgdG8gdXNlIFJlYWN0SXMuaXNDb25jdXJyZW50TW9kZSgpIGluc3RlYWQuIEl0IGhhcyB0aGUgZXhhY3Qgc2FtZSBBUEkuXCIpKSwgcyhiKSB8fCBOKGIpID09PSBwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzKGIpIHtcbiAgICAgIHJldHVybiBOKGIpID09PSB1O1xuICAgIH1cbiAgICBmdW5jdGlvbiB2KGIpIHtcbiAgICAgIHJldHVybiBOKGIpID09PSBvO1xuICAgIH1cbiAgICBmdW5jdGlvbiBDKGIpIHtcbiAgICAgIHJldHVybiBOKGIpID09PSBsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBPKGIpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgYiA9PSBcIm9iamVjdFwiICYmIGIgIT09IG51bGwgJiYgYi4kJHR5cGVvZiA9PT0gcjtcbiAgICB9XG4gICAgZnVuY3Rpb24gUihiKSB7XG4gICAgICByZXR1cm4gTihiKSA9PT0gZjtcbiAgICB9XG4gICAgZnVuY3Rpb24gUChiKSB7XG4gICAgICByZXR1cm4gTihiKSA9PT0gbjtcbiAgICB9XG4gICAgZnVuY3Rpb24gRChiKSB7XG4gICAgICByZXR1cm4gTihiKSA9PT0gRjtcbiAgICB9XG4gICAgZnVuY3Rpb24gSShiKSB7XG4gICAgICByZXR1cm4gTihiKSA9PT0gTTtcbiAgICB9XG4gICAgZnVuY3Rpb24gVShiKSB7XG4gICAgICByZXR1cm4gTihiKSA9PT0gdDtcbiAgICB9XG4gICAgZnVuY3Rpb24gRyhiKSB7XG4gICAgICByZXR1cm4gTihiKSA9PT0gaTtcbiAgICB9XG4gICAgZnVuY3Rpb24gQihiKSB7XG4gICAgICByZXR1cm4gTihiKSA9PT0gYztcbiAgICB9XG4gICAgZnVuY3Rpb24gcmUoYikge1xuICAgICAgcmV0dXJuIE4oYikgPT09IGg7XG4gICAgfVxuICAgIFcuQXN5bmNNb2RlID0geSwgVy5Db25jdXJyZW50TW9kZSA9IHZlLCBXLkNvbnRleHRDb25zdW1lciA9IHBlLCBXLkNvbnRleHRQcm92aWRlciA9IG1lLCBXLkVsZW1lbnQgPSB5ZSwgVy5Gb3J3YXJkUmVmID0geGUsIFcuRnJhZ21lbnQgPSBfZSwgVy5MYXp5ID0gZ2UsIFcuTWVtbyA9IFRlLCBXLlBvcnRhbCA9IGcsIFcuUHJvZmlsZXIgPSBFLCBXLlN0cmljdE1vZGUgPSB4LCBXLlN1c3BlbnNlID0gVCwgVy5pc0FzeW5jTW9kZSA9IEwsIFcuaXNDb25jdXJyZW50TW9kZSA9IHMsIFcuaXNDb250ZXh0Q29uc3VtZXIgPSB2LCBXLmlzQ29udGV4dFByb3ZpZGVyID0gQywgVy5pc0VsZW1lbnQgPSBPLCBXLmlzRm9yd2FyZFJlZiA9IFIsIFcuaXNGcmFnbWVudCA9IFAsIFcuaXNMYXp5ID0gRCwgVy5pc01lbW8gPSBJLCBXLmlzUG9ydGFsID0gVSwgVy5pc1Byb2ZpbGVyID0gRywgVy5pc1N0cmljdE1vZGUgPSBCLCBXLmlzU3VzcGVuc2UgPSByZSwgVy5pc1ZhbGlkRWxlbWVudFR5cGUgPSB3LCBXLnR5cGVPZiA9IE47XG4gIH0oKSksIFc7XG59XG52YXIgayA9IHt9O1xuLyoqIEBsaWNlbnNlIFJlYWN0IHYxNi4xMy4xXG4gKiByZWFjdC1pcy5wcm9kdWN0aW9uLm1pbi5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG52YXIgZ3Q7XG5mdW5jdGlvbiB5YSgpIHtcbiAgaWYgKGd0KVxuICAgIHJldHVybiBrO1xuICBndCA9IDE7XG4gIHZhciBlID0gdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLmZvciwgciA9IGUgPyBTeW1ib2wuZm9yKFwicmVhY3QuZWxlbWVudFwiKSA6IDYwMTAzLCB0ID0gZSA/IFN5bWJvbC5mb3IoXCJyZWFjdC5wb3J0YWxcIikgOiA2MDEwNiwgbiA9IGUgPyBTeW1ib2wuZm9yKFwicmVhY3QuZnJhZ21lbnRcIikgOiA2MDEwNywgYyA9IGUgPyBTeW1ib2wuZm9yKFwicmVhY3Quc3RyaWN0X21vZGVcIikgOiA2MDEwOCwgaSA9IGUgPyBTeW1ib2wuZm9yKFwicmVhY3QucHJvZmlsZXJcIikgOiA2MDExNCwgbCA9IGUgPyBTeW1ib2wuZm9yKFwicmVhY3QucHJvdmlkZXJcIikgOiA2MDEwOSwgbyA9IGUgPyBTeW1ib2wuZm9yKFwicmVhY3QuY29udGV4dFwiKSA6IDYwMTEwLCBwID0gZSA/IFN5bWJvbC5mb3IoXCJyZWFjdC5hc3luY19tb2RlXCIpIDogNjAxMTEsIHUgPSBlID8gU3ltYm9sLmZvcihcInJlYWN0LmNvbmN1cnJlbnRfbW9kZVwiKSA6IDYwMTExLCBmID0gZSA/IFN5bWJvbC5mb3IoXCJyZWFjdC5mb3J3YXJkX3JlZlwiKSA6IDYwMTEyLCBoID0gZSA/IFN5bWJvbC5mb3IoXCJyZWFjdC5zdXNwZW5zZVwiKSA6IDYwMTEzLCBfID0gZSA/IFN5bWJvbC5mb3IoXCJyZWFjdC5zdXNwZW5zZV9saXN0XCIpIDogNjAxMjAsIE0gPSBlID8gU3ltYm9sLmZvcihcInJlYWN0Lm1lbW9cIikgOiA2MDExNSwgRiA9IGUgPyBTeW1ib2wuZm9yKFwicmVhY3QubGF6eVwiKSA6IDYwMTE2LCBBID0gZSA/IFN5bWJvbC5mb3IoXCJyZWFjdC5ibG9ja1wiKSA6IDYwMTIxLCBkID0gZSA/IFN5bWJvbC5mb3IoXCJyZWFjdC5mdW5kYW1lbnRhbFwiKSA6IDYwMTE3LCBZID0gZSA/IFN5bWJvbC5mb3IoXCJyZWFjdC5yZXNwb25kZXJcIikgOiA2MDExOCwgUSA9IGUgPyBTeW1ib2wuZm9yKFwicmVhY3Quc2NvcGVcIikgOiA2MDExOTtcbiAgZnVuY3Rpb24gdyh5KSB7XG4gICAgaWYgKHR5cGVvZiB5ID09IFwib2JqZWN0XCIgJiYgeSAhPT0gbnVsbCkge1xuICAgICAgdmFyIHZlID0geS4kJHR5cGVvZjtcbiAgICAgIHN3aXRjaCAodmUpIHtcbiAgICAgICAgY2FzZSByOlxuICAgICAgICAgIHN3aXRjaCAoeSA9IHkudHlwZSwgeSkge1xuICAgICAgICAgICAgY2FzZSBwOlxuICAgICAgICAgICAgY2FzZSB1OlxuICAgICAgICAgICAgY2FzZSBuOlxuICAgICAgICAgICAgY2FzZSBpOlxuICAgICAgICAgICAgY2FzZSBjOlxuICAgICAgICAgICAgY2FzZSBoOlxuICAgICAgICAgICAgICByZXR1cm4geTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHN3aXRjaCAoeSA9IHkgJiYgeS4kJHR5cGVvZiwgeSkge1xuICAgICAgICAgICAgICAgIGNhc2UgbzpcbiAgICAgICAgICAgICAgICBjYXNlIGY6XG4gICAgICAgICAgICAgICAgY2FzZSBGOlxuICAgICAgICAgICAgICAgIGNhc2UgTTpcbiAgICAgICAgICAgICAgICBjYXNlIGw6XG4gICAgICAgICAgICAgICAgICByZXR1cm4geTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHZlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlIHQ6XG4gICAgICAgICAgcmV0dXJuIHZlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBOKHkpIHtcbiAgICByZXR1cm4gdyh5KSA9PT0gdTtcbiAgfVxuICByZXR1cm4gay5Bc3luY01vZGUgPSBwLCBrLkNvbmN1cnJlbnRNb2RlID0gdSwgay5Db250ZXh0Q29uc3VtZXIgPSBvLCBrLkNvbnRleHRQcm92aWRlciA9IGwsIGsuRWxlbWVudCA9IHIsIGsuRm9yd2FyZFJlZiA9IGYsIGsuRnJhZ21lbnQgPSBuLCBrLkxhenkgPSBGLCBrLk1lbW8gPSBNLCBrLlBvcnRhbCA9IHQsIGsuUHJvZmlsZXIgPSBpLCBrLlN0cmljdE1vZGUgPSBjLCBrLlN1c3BlbnNlID0gaCwgay5pc0FzeW5jTW9kZSA9IGZ1bmN0aW9uKHkpIHtcbiAgICByZXR1cm4gTih5KSB8fCB3KHkpID09PSBwO1xuICB9LCBrLmlzQ29uY3VycmVudE1vZGUgPSBOLCBrLmlzQ29udGV4dENvbnN1bWVyID0gZnVuY3Rpb24oeSkge1xuICAgIHJldHVybiB3KHkpID09PSBvO1xuICB9LCBrLmlzQ29udGV4dFByb3ZpZGVyID0gZnVuY3Rpb24oeSkge1xuICAgIHJldHVybiB3KHkpID09PSBsO1xuICB9LCBrLmlzRWxlbWVudCA9IGZ1bmN0aW9uKHkpIHtcbiAgICByZXR1cm4gdHlwZW9mIHkgPT0gXCJvYmplY3RcIiAmJiB5ICE9PSBudWxsICYmIHkuJCR0eXBlb2YgPT09IHI7XG4gIH0sIGsuaXNGb3J3YXJkUmVmID0gZnVuY3Rpb24oeSkge1xuICAgIHJldHVybiB3KHkpID09PSBmO1xuICB9LCBrLmlzRnJhZ21lbnQgPSBmdW5jdGlvbih5KSB7XG4gICAgcmV0dXJuIHcoeSkgPT09IG47XG4gIH0sIGsuaXNMYXp5ID0gZnVuY3Rpb24oeSkge1xuICAgIHJldHVybiB3KHkpID09PSBGO1xuICB9LCBrLmlzTWVtbyA9IGZ1bmN0aW9uKHkpIHtcbiAgICByZXR1cm4gdyh5KSA9PT0gTTtcbiAgfSwgay5pc1BvcnRhbCA9IGZ1bmN0aW9uKHkpIHtcbiAgICByZXR1cm4gdyh5KSA9PT0gdDtcbiAgfSwgay5pc1Byb2ZpbGVyID0gZnVuY3Rpb24oeSkge1xuICAgIHJldHVybiB3KHkpID09PSBpO1xuICB9LCBrLmlzU3RyaWN0TW9kZSA9IGZ1bmN0aW9uKHkpIHtcbiAgICByZXR1cm4gdyh5KSA9PT0gYztcbiAgfSwgay5pc1N1c3BlbnNlID0gZnVuY3Rpb24oeSkge1xuICAgIHJldHVybiB3KHkpID09PSBoO1xuICB9LCBrLmlzVmFsaWRFbGVtZW50VHlwZSA9IGZ1bmN0aW9uKHkpIHtcbiAgICByZXR1cm4gdHlwZW9mIHkgPT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgeSA9PSBcImZ1bmN0aW9uXCIgfHwgeSA9PT0gbiB8fCB5ID09PSB1IHx8IHkgPT09IGkgfHwgeSA9PT0gYyB8fCB5ID09PSBoIHx8IHkgPT09IF8gfHwgdHlwZW9mIHkgPT0gXCJvYmplY3RcIiAmJiB5ICE9PSBudWxsICYmICh5LiQkdHlwZW9mID09PSBGIHx8IHkuJCR0eXBlb2YgPT09IE0gfHwgeS4kJHR5cGVvZiA9PT0gbCB8fCB5LiQkdHlwZW9mID09PSBvIHx8IHkuJCR0eXBlb2YgPT09IGYgfHwgeS4kJHR5cGVvZiA9PT0gZCB8fCB5LiQkdHlwZW9mID09PSBZIHx8IHkuJCR0eXBlb2YgPT09IFEgfHwgeS4kJHR5cGVvZiA9PT0gQSk7XG4gIH0sIGsudHlwZU9mID0gdywgaztcbn1cbnZhciBodDtcbmZ1bmN0aW9uIGZuKCkge1xuICByZXR1cm4gaHQgfHwgKGh0ID0gMSwgc2UuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IHRyLmV4cG9ydHMgPSB5YSgpIDogdHIuZXhwb3J0cyA9IHBhKCkpLCB0ci5leHBvcnRzO1xufVxuLypcbm9iamVjdC1hc3NpZ25cbihjKSBTaW5kcmUgU29yaHVzXG5AbGljZW5zZSBNSVRcbiovXG52YXIgT3IsIGJ0O1xuZnVuY3Rpb24gZ2EoKSB7XG4gIGlmIChidClcbiAgICByZXR1cm4gT3I7XG4gIGJ0ID0gMTtcbiAgdmFyIGUgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzLCByID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSwgdCA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG4gIGZ1bmN0aW9uIG4oaSkge1xuICAgIGlmIChpID09IG51bGwpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiT2JqZWN0LmFzc2lnbiBjYW5ub3QgYmUgY2FsbGVkIHdpdGggbnVsbCBvciB1bmRlZmluZWRcIik7XG4gICAgcmV0dXJuIE9iamVjdChpKTtcbiAgfVxuICBmdW5jdGlvbiBjKCkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIU9iamVjdC5hc3NpZ24pXG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIHZhciBpID0gbmV3IFN0cmluZyhcImFiY1wiKTtcbiAgICAgIGlmIChpWzVdID0gXCJkZVwiLCBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhpKVswXSA9PT0gXCI1XCIpXG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIGZvciAodmFyIGwgPSB7fSwgbyA9IDA7IG8gPCAxMDsgbysrKVxuICAgICAgICBsW1wiX1wiICsgU3RyaW5nLmZyb21DaGFyQ29kZShvKV0gPSBvO1xuICAgICAgdmFyIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhsKS5tYXAoZnVuY3Rpb24oZikge1xuICAgICAgICByZXR1cm4gbFtmXTtcbiAgICAgIH0pO1xuICAgICAgaWYgKHAuam9pbihcIlwiKSAhPT0gXCIwMTIzNDU2Nzg5XCIpXG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIHZhciB1ID0ge307XG4gICAgICByZXR1cm4gXCJhYmNkZWZnaGlqa2xtbm9wcXJzdFwiLnNwbGl0KFwiXCIpLmZvckVhY2goZnVuY3Rpb24oZikge1xuICAgICAgICB1W2ZdID0gZjtcbiAgICAgIH0pLCBPYmplY3Qua2V5cyhPYmplY3QuYXNzaWduKHt9LCB1KSkuam9pbihcIlwiKSA9PT0gXCJhYmNkZWZnaGlqa2xtbm9wcXJzdFwiO1xuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuICExO1xuICAgIH1cbiAgfVxuICByZXR1cm4gT3IgPSBjKCkgPyBPYmplY3QuYXNzaWduIDogZnVuY3Rpb24oaSwgbCkge1xuICAgIGZvciAodmFyIG8sIHAgPSBuKGkpLCB1LCBmID0gMTsgZiA8IGFyZ3VtZW50cy5sZW5ndGg7IGYrKykge1xuICAgICAgbyA9IE9iamVjdChhcmd1bWVudHNbZl0pO1xuICAgICAgZm9yICh2YXIgaCBpbiBvKVxuICAgICAgICByLmNhbGwobywgaCkgJiYgKHBbaF0gPSBvW2hdKTtcbiAgICAgIGlmIChlKSB7XG4gICAgICAgIHUgPSBlKG8pO1xuICAgICAgICBmb3IgKHZhciBfID0gMDsgXyA8IHUubGVuZ3RoOyBfKyspXG4gICAgICAgICAgdC5jYWxsKG8sIHVbX10pICYmIChwW3VbX11dID0gb1t1W19dXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwO1xuICB9LCBPcjtcbn1cbnZhciBBciwgJHQ7XG5mdW5jdGlvbiBkbigpIHtcbiAgcmV0dXJuICR0IHx8ICgkdCA9IDEsIEFyID0gRnVuY3Rpb24uY2FsbC5iaW5kKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkpKSwgQXI7XG59XG52YXIganIsIG10O1xuZnVuY3Rpb24gaGEoKSB7XG4gIGlmIChtdClcbiAgICByZXR1cm4ganI7XG4gIG10ID0gMTtcbiAgdmFyIGUgPSBmdW5jdGlvbigpIHtcbiAgfTtcbiAgaWYgKHNlLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICB2YXIgciA9IHpyKCksIHQgPSB7fSwgbiA9IGRuKCk7XG4gICAgZSA9IGZ1bmN0aW9uKGkpIHtcbiAgICAgIHZhciBsID0gXCJXYXJuaW5nOiBcIiArIGk7XG4gICAgICB0eXBlb2YgY29uc29sZSA8IFwidVwiICYmIGNvbnNvbGUuZXJyb3IobCk7XG4gICAgICB0cnkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobCk7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGMoaSwgbCwgbywgcCwgdSkge1xuICAgIGlmIChzZS5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICBmb3IgKHZhciBmIGluIGkpXG4gICAgICAgIGlmIChuKGksIGYpKSB7XG4gICAgICAgICAgdmFyIGg7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaVtmXSAhPSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgdmFyIF8gPSBFcnJvcihcbiAgICAgICAgICAgICAgICAocCB8fCBcIlJlYWN0IGNsYXNzXCIpICsgXCI6IFwiICsgbyArIFwiIHR5cGUgYFwiICsgZiArIFwiYCBpcyBpbnZhbGlkOyBpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UsIGJ1dCByZWNlaXZlZCBgXCIgKyB0eXBlb2YgaVtmXSArIFwiYC5UaGlzIG9mdGVuIGhhcHBlbnMgYmVjYXVzZSBvZiB0eXBvcyBzdWNoIGFzIGBQcm9wVHlwZXMuZnVuY3Rpb25gIGluc3RlYWQgb2YgYFByb3BUeXBlcy5mdW5jYC5cIlxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB0aHJvdyBfLm5hbWUgPSBcIkludmFyaWFudCBWaW9sYXRpb25cIiwgXztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGggPSBpW2ZdKGwsIGYsIHAsIG8sIG51bGwsIHIpO1xuICAgICAgICAgIH0gY2F0Y2ggKEYpIHtcbiAgICAgICAgICAgIGggPSBGO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaCAmJiAhKGggaW5zdGFuY2VvZiBFcnJvcikgJiYgZShcbiAgICAgICAgICAgIChwIHx8IFwiUmVhY3QgY2xhc3NcIikgKyBcIjogdHlwZSBzcGVjaWZpY2F0aW9uIG9mIFwiICsgbyArIFwiIGBcIiArIGYgKyBcImAgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciBmdW5jdGlvbiBtdXN0IHJldHVybiBgbnVsbGAgb3IgYW4gYEVycm9yYCBidXQgcmV0dXJuZWQgYSBcIiArIHR5cGVvZiBoICsgXCIuIFlvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyIGNyZWF0b3IgKGFycmF5T2YsIGluc3RhbmNlT2YsIG9iamVjdE9mLCBvbmVPZiwgb25lT2ZUeXBlLCBhbmQgc2hhcGUgYWxsIHJlcXVpcmUgYW4gYXJndW1lbnQpLlwiXG4gICAgICAgICAgKSwgaCBpbnN0YW5jZW9mIEVycm9yICYmICEoaC5tZXNzYWdlIGluIHQpKSB7XG4gICAgICAgICAgICB0W2gubWVzc2FnZV0gPSAhMDtcbiAgICAgICAgICAgIHZhciBNID0gdSA/IHUoKSA6IFwiXCI7XG4gICAgICAgICAgICBlKFxuICAgICAgICAgICAgICBcIkZhaWxlZCBcIiArIG8gKyBcIiB0eXBlOiBcIiArIGgubWVzc2FnZSArIChNID8/IFwiXCIpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gYy5yZXNldFdhcm5pbmdDYWNoZSA9IGZ1bmN0aW9uKCkge1xuICAgIHNlLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgKHQgPSB7fSk7XG4gIH0sIGpyID0gYywganI7XG59XG52YXIgUHIsIHh0O1xuZnVuY3Rpb24gYmEoKSB7XG4gIGlmICh4dClcbiAgICByZXR1cm4gUHI7XG4gIHh0ID0gMTtcbiAgdmFyIGUgPSBmbigpLCByID0gZ2EoKSwgdCA9IHpyKCksIG4gPSBkbigpLCBjID0gaGEoKSwgaSA9IGZ1bmN0aW9uKCkge1xuICB9O1xuICBzZS5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIChpID0gZnVuY3Rpb24obykge1xuICAgIHZhciBwID0gXCJXYXJuaW5nOiBcIiArIG87XG4gICAgdHlwZW9mIGNvbnNvbGUgPCBcInVcIiAmJiBjb25zb2xlLmVycm9yKHApO1xuICAgIHRyeSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IocCk7XG4gICAgfSBjYXRjaCB7XG4gICAgfVxuICB9KTtcbiAgZnVuY3Rpb24gbCgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gUHIgPSBmdW5jdGlvbihvLCBwKSB7XG4gICAgdmFyIHUgPSB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIGYgPSBcIkBAaXRlcmF0b3JcIjtcbiAgICBmdW5jdGlvbiBoKHMpIHtcbiAgICAgIHZhciB2ID0gcyAmJiAodSAmJiBzW3VdIHx8IHNbZl0pO1xuICAgICAgaWYgKHR5cGVvZiB2ID09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfVxuICAgIHZhciBfID0gXCI8PGFub255bW91cz4+XCIsIE0gPSB7XG4gICAgICBhcnJheTogWShcImFycmF5XCIpLFxuICAgICAgYmlnaW50OiBZKFwiYmlnaW50XCIpLFxuICAgICAgYm9vbDogWShcImJvb2xlYW5cIiksXG4gICAgICBmdW5jOiBZKFwiZnVuY3Rpb25cIiksXG4gICAgICBudW1iZXI6IFkoXCJudW1iZXJcIiksXG4gICAgICBvYmplY3Q6IFkoXCJvYmplY3RcIiksXG4gICAgICBzdHJpbmc6IFkoXCJzdHJpbmdcIiksXG4gICAgICBzeW1ib2w6IFkoXCJzeW1ib2xcIiksXG4gICAgICBhbnk6IFEoKSxcbiAgICAgIGFycmF5T2Y6IHcsXG4gICAgICBlbGVtZW50OiBOKCksXG4gICAgICBlbGVtZW50VHlwZTogeSgpLFxuICAgICAgaW5zdGFuY2VPZjogdmUsXG4gICAgICBub2RlOiB4ZSgpLFxuICAgICAgb2JqZWN0T2Y6IG1lLFxuICAgICAgb25lT2Y6IHBlLFxuICAgICAgb25lT2ZUeXBlOiB5ZSxcbiAgICAgIHNoYXBlOiBnZSxcbiAgICAgIGV4YWN0OiBUZVxuICAgIH07XG4gICAgZnVuY3Rpb24gRihzLCB2KSB7XG4gICAgICByZXR1cm4gcyA9PT0gdiA/IHMgIT09IDAgfHwgMSAvIHMgPT09IDEgLyB2IDogcyAhPT0gcyAmJiB2ICE9PSB2O1xuICAgIH1cbiAgICBmdW5jdGlvbiBBKHMsIHYpIHtcbiAgICAgIHRoaXMubWVzc2FnZSA9IHMsIHRoaXMuZGF0YSA9IHYgJiYgdHlwZW9mIHYgPT0gXCJvYmplY3RcIiA/IHYgOiB7fSwgdGhpcy5zdGFjayA9IFwiXCI7XG4gICAgfVxuICAgIEEucHJvdG90eXBlID0gRXJyb3IucHJvdG90eXBlO1xuICAgIGZ1bmN0aW9uIGQocykge1xuICAgICAgaWYgKHNlLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpXG4gICAgICAgIHZhciB2ID0ge30sIEMgPSAwO1xuICAgICAgZnVuY3Rpb24gTyhQLCBELCBJLCBVLCBHLCBCLCByZSkge1xuICAgICAgICBpZiAoVSA9IFUgfHwgXywgQiA9IEIgfHwgSSwgcmUgIT09IHQpIHtcbiAgICAgICAgICBpZiAocCkge1xuICAgICAgICAgICAgdmFyIGIgPSBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgIFwiQ2FsbGluZyBQcm9wVHlwZXMgdmFsaWRhdG9ycyBkaXJlY3RseSBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZS4gVXNlIGBQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMoKWAgdG8gY2FsbCB0aGVtLiBSZWFkIG1vcmUgYXQgaHR0cDovL2ZiLm1lL3VzZS1jaGVjay1wcm9wLXR5cGVzXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0aHJvdyBiLm5hbWUgPSBcIkludmFyaWFudCBWaW9sYXRpb25cIiwgYjtcbiAgICAgICAgICB9IGVsc2UgaWYgKHNlLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgdHlwZW9mIGNvbnNvbGUgPCBcInVcIikge1xuICAgICAgICAgICAgdmFyIGllID0gVSArIFwiOlwiICsgSTtcbiAgICAgICAgICAgICF2W2llXSAmJiAvLyBBdm9pZCBzcGFtbWluZyB0aGUgY29uc29sZSBiZWNhdXNlIHRoZXkgYXJlIG9mdGVuIG5vdCBhY3Rpb25hYmxlIGV4Y2VwdCBmb3IgbGliIGF1dGhvcnNcbiAgICAgICAgICAgIEMgPCAzICYmIChpKFxuICAgICAgICAgICAgICBcIllvdSBhcmUgbWFudWFsbHkgY2FsbGluZyBhIFJlYWN0LlByb3BUeXBlcyB2YWxpZGF0aW9uIGZ1bmN0aW9uIGZvciB0aGUgYFwiICsgQiArIFwiYCBwcm9wIG9uIGBcIiArIFUgKyBcImAuIFRoaXMgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCB0aHJvdyBpbiB0aGUgc3RhbmRhbG9uZSBgcHJvcC10eXBlc2AgcGFja2FnZS4gWW91IG1heSBiZSBzZWVpbmcgdGhpcyB3YXJuaW5nIGR1ZSB0byBhIHRoaXJkLXBhcnR5IFByb3BUeXBlcyBsaWJyYXJ5LiBTZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC13YXJuaW5nLWRvbnQtY2FsbC1wcm9wdHlwZXMgZm9yIGRldGFpbHMuXCJcbiAgICAgICAgICAgICksIHZbaWVdID0gITAsIEMrKyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBEW0ldID09IG51bGwgPyBQID8gRFtJXSA9PT0gbnVsbCA/IG5ldyBBKFwiVGhlIFwiICsgRyArIFwiIGBcIiArIEIgKyBcImAgaXMgbWFya2VkIGFzIHJlcXVpcmVkIFwiICsgKFwiaW4gYFwiICsgVSArIFwiYCwgYnV0IGl0cyB2YWx1ZSBpcyBgbnVsbGAuXCIpKSA6IG5ldyBBKFwiVGhlIFwiICsgRyArIFwiIGBcIiArIEIgKyBcImAgaXMgbWFya2VkIGFzIHJlcXVpcmVkIGluIFwiICsgKFwiYFwiICsgVSArIFwiYCwgYnV0IGl0cyB2YWx1ZSBpcyBgdW5kZWZpbmVkYC5cIikpIDogbnVsbCA6IHMoRCwgSSwgVSwgRywgQik7XG4gICAgICB9XG4gICAgICB2YXIgUiA9IE8uYmluZChudWxsLCAhMSk7XG4gICAgICByZXR1cm4gUi5pc1JlcXVpcmVkID0gTy5iaW5kKG51bGwsICEwKSwgUjtcbiAgICB9XG4gICAgZnVuY3Rpb24gWShzKSB7XG4gICAgICBmdW5jdGlvbiB2KEMsIE8sIFIsIFAsIEQsIEkpIHtcbiAgICAgICAgdmFyIFUgPSBDW09dLCBHID0geChVKTtcbiAgICAgICAgaWYgKEcgIT09IHMpIHtcbiAgICAgICAgICB2YXIgQiA9IFQoVSk7XG4gICAgICAgICAgcmV0dXJuIG5ldyBBKFxuICAgICAgICAgICAgXCJJbnZhbGlkIFwiICsgUCArIFwiIGBcIiArIEQgKyBcImAgb2YgdHlwZSBcIiArIChcImBcIiArIEIgKyBcImAgc3VwcGxpZWQgdG8gYFwiICsgUiArIFwiYCwgZXhwZWN0ZWQgXCIpICsgKFwiYFwiICsgcyArIFwiYC5cIiksXG4gICAgICAgICAgICB7IGV4cGVjdGVkVHlwZTogcyB9XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkKHYpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBRKCkge1xuICAgICAgcmV0dXJuIGQobCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHcocykge1xuICAgICAgZnVuY3Rpb24gdihDLCBPLCBSLCBQLCBEKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcyAhPSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgcmV0dXJuIG5ldyBBKFwiUHJvcGVydHkgYFwiICsgRCArIFwiYCBvZiBjb21wb25lbnQgYFwiICsgUiArIFwiYCBoYXMgaW52YWxpZCBQcm9wVHlwZSBub3RhdGlvbiBpbnNpZGUgYXJyYXlPZi5cIik7XG4gICAgICAgIHZhciBJID0gQ1tPXTtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KEkpKSB7XG4gICAgICAgICAgdmFyIFUgPSB4KEkpO1xuICAgICAgICAgIHJldHVybiBuZXcgQShcIkludmFsaWQgXCIgKyBQICsgXCIgYFwiICsgRCArIFwiYCBvZiB0eXBlIFwiICsgKFwiYFwiICsgVSArIFwiYCBzdXBwbGllZCB0byBgXCIgKyBSICsgXCJgLCBleHBlY3RlZCBhbiBhcnJheS5cIikpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIEcgPSAwOyBHIDwgSS5sZW5ndGg7IEcrKykge1xuICAgICAgICAgIHZhciBCID0gcyhJLCBHLCBSLCBQLCBEICsgXCJbXCIgKyBHICsgXCJdXCIsIHQpO1xuICAgICAgICAgIGlmIChCIGluc3RhbmNlb2YgRXJyb3IpXG4gICAgICAgICAgICByZXR1cm4gQjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkKHYpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBOKCkge1xuICAgICAgZnVuY3Rpb24gcyh2LCBDLCBPLCBSLCBQKSB7XG4gICAgICAgIHZhciBEID0gdltDXTtcbiAgICAgICAgaWYgKCFvKEQpKSB7XG4gICAgICAgICAgdmFyIEkgPSB4KEQpO1xuICAgICAgICAgIHJldHVybiBuZXcgQShcIkludmFsaWQgXCIgKyBSICsgXCIgYFwiICsgUCArIFwiYCBvZiB0eXBlIFwiICsgKFwiYFwiICsgSSArIFwiYCBzdXBwbGllZCB0byBgXCIgKyBPICsgXCJgLCBleHBlY3RlZCBhIHNpbmdsZSBSZWFjdEVsZW1lbnQuXCIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkKHMpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB5KCkge1xuICAgICAgZnVuY3Rpb24gcyh2LCBDLCBPLCBSLCBQKSB7XG4gICAgICAgIHZhciBEID0gdltDXTtcbiAgICAgICAgaWYgKCFlLmlzVmFsaWRFbGVtZW50VHlwZShEKSkge1xuICAgICAgICAgIHZhciBJID0geChEKTtcbiAgICAgICAgICByZXR1cm4gbmV3IEEoXCJJbnZhbGlkIFwiICsgUiArIFwiIGBcIiArIFAgKyBcImAgb2YgdHlwZSBcIiArIChcImBcIiArIEkgKyBcImAgc3VwcGxpZWQgdG8gYFwiICsgTyArIFwiYCwgZXhwZWN0ZWQgYSBzaW5nbGUgUmVhY3RFbGVtZW50IHR5cGUuXCIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkKHMpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB2ZShzKSB7XG4gICAgICBmdW5jdGlvbiB2KEMsIE8sIFIsIFAsIEQpIHtcbiAgICAgICAgaWYgKCEoQ1tPXSBpbnN0YW5jZW9mIHMpKSB7XG4gICAgICAgICAgdmFyIEkgPSBzLm5hbWUgfHwgXywgVSA9IEwoQ1tPXSk7XG4gICAgICAgICAgcmV0dXJuIG5ldyBBKFwiSW52YWxpZCBcIiArIFAgKyBcIiBgXCIgKyBEICsgXCJgIG9mIHR5cGUgXCIgKyAoXCJgXCIgKyBVICsgXCJgIHN1cHBsaWVkIHRvIGBcIiArIFIgKyBcImAsIGV4cGVjdGVkIFwiKSArIChcImluc3RhbmNlIG9mIGBcIiArIEkgKyBcImAuXCIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkKHYpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwZShzKSB7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkocykpXG4gICAgICAgIHJldHVybiBzZS5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIChhcmd1bWVudHMubGVuZ3RoID4gMSA/IGkoXG4gICAgICAgICAgXCJJbnZhbGlkIGFyZ3VtZW50cyBzdXBwbGllZCB0byBvbmVPZiwgZXhwZWN0ZWQgYW4gYXJyYXksIGdvdCBcIiArIGFyZ3VtZW50cy5sZW5ndGggKyBcIiBhcmd1bWVudHMuIEEgY29tbW9uIG1pc3Rha2UgaXMgdG8gd3JpdGUgb25lT2YoeCwgeSwgeikgaW5zdGVhZCBvZiBvbmVPZihbeCwgeSwgel0pLlwiXG4gICAgICAgICkgOiBpKFwiSW52YWxpZCBhcmd1bWVudCBzdXBwbGllZCB0byBvbmVPZiwgZXhwZWN0ZWQgYW4gYXJyYXkuXCIpKSwgbDtcbiAgICAgIGZ1bmN0aW9uIHYoQywgTywgUiwgUCwgRCkge1xuICAgICAgICBmb3IgKHZhciBJID0gQ1tPXSwgVSA9IDA7IFUgPCBzLmxlbmd0aDsgVSsrKVxuICAgICAgICAgIGlmIChGKEksIHNbVV0pKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHZhciBHID0gSlNPTi5zdHJpbmdpZnkocywgZnVuY3Rpb24ocmUsIGIpIHtcbiAgICAgICAgICB2YXIgaWUgPSBUKGIpO1xuICAgICAgICAgIHJldHVybiBpZSA9PT0gXCJzeW1ib2xcIiA/IFN0cmluZyhiKSA6IGI7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3IEEoXCJJbnZhbGlkIFwiICsgUCArIFwiIGBcIiArIEQgKyBcImAgb2YgdmFsdWUgYFwiICsgU3RyaW5nKEkpICsgXCJgIFwiICsgKFwic3VwcGxpZWQgdG8gYFwiICsgUiArIFwiYCwgZXhwZWN0ZWQgb25lIG9mIFwiICsgRyArIFwiLlwiKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZCh2KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWUocykge1xuICAgICAgZnVuY3Rpb24gdihDLCBPLCBSLCBQLCBEKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcyAhPSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgcmV0dXJuIG5ldyBBKFwiUHJvcGVydHkgYFwiICsgRCArIFwiYCBvZiBjb21wb25lbnQgYFwiICsgUiArIFwiYCBoYXMgaW52YWxpZCBQcm9wVHlwZSBub3RhdGlvbiBpbnNpZGUgb2JqZWN0T2YuXCIpO1xuICAgICAgICB2YXIgSSA9IENbT10sIFUgPSB4KEkpO1xuICAgICAgICBpZiAoVSAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICByZXR1cm4gbmV3IEEoXCJJbnZhbGlkIFwiICsgUCArIFwiIGBcIiArIEQgKyBcImAgb2YgdHlwZSBcIiArIChcImBcIiArIFUgKyBcImAgc3VwcGxpZWQgdG8gYFwiICsgUiArIFwiYCwgZXhwZWN0ZWQgYW4gb2JqZWN0LlwiKSk7XG4gICAgICAgIGZvciAodmFyIEcgaW4gSSlcbiAgICAgICAgICBpZiAobihJLCBHKSkge1xuICAgICAgICAgICAgdmFyIEIgPSBzKEksIEcsIFIsIFAsIEQgKyBcIi5cIiArIEcsIHQpO1xuICAgICAgICAgICAgaWYgKEIgaW5zdGFuY2VvZiBFcnJvcilcbiAgICAgICAgICAgICAgcmV0dXJuIEI7XG4gICAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkKHYpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB5ZShzKSB7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkocykpXG4gICAgICAgIHJldHVybiBzZS5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIGkoXCJJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mVHlwZSwgZXhwZWN0ZWQgYW4gaW5zdGFuY2Ugb2YgYXJyYXkuXCIpLCBsO1xuICAgICAgZm9yICh2YXIgdiA9IDA7IHYgPCBzLmxlbmd0aDsgdisrKSB7XG4gICAgICAgIHZhciBDID0gc1t2XTtcbiAgICAgICAgaWYgKHR5cGVvZiBDICE9IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICByZXR1cm4gaShcbiAgICAgICAgICAgIFwiSW52YWxpZCBhcmd1bWVudCBzdXBwbGllZCB0byBvbmVPZlR5cGUuIEV4cGVjdGVkIGFuIGFycmF5IG9mIGNoZWNrIGZ1bmN0aW9ucywgYnV0IHJlY2VpdmVkIFwiICsgbShDKSArIFwiIGF0IGluZGV4IFwiICsgdiArIFwiLlwiXG4gICAgICAgICAgKSwgbDtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIE8oUiwgUCwgRCwgSSwgVSkge1xuICAgICAgICBmb3IgKHZhciBHID0gW10sIEIgPSAwOyBCIDwgcy5sZW5ndGg7IEIrKykge1xuICAgICAgICAgIHZhciByZSA9IHNbQl0sIGIgPSByZShSLCBQLCBELCBJLCBVLCB0KTtcbiAgICAgICAgICBpZiAoYiA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgYi5kYXRhICYmIG4oYi5kYXRhLCBcImV4cGVjdGVkVHlwZVwiKSAmJiBHLnB1c2goYi5kYXRhLmV4cGVjdGVkVHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGllID0gRy5sZW5ndGggPiAwID8gXCIsIGV4cGVjdGVkIG9uZSBvZiB0eXBlIFtcIiArIEcuam9pbihcIiwgXCIpICsgXCJdXCIgOiBcIlwiO1xuICAgICAgICByZXR1cm4gbmV3IEEoXCJJbnZhbGlkIFwiICsgSSArIFwiIGBcIiArIFUgKyBcImAgc3VwcGxpZWQgdG8gXCIgKyAoXCJgXCIgKyBEICsgXCJgXCIgKyBpZSArIFwiLlwiKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZChPKTtcbiAgICB9XG4gICAgZnVuY3Rpb24geGUoKSB7XG4gICAgICBmdW5jdGlvbiBzKHYsIEMsIE8sIFIsIFApIHtcbiAgICAgICAgcmV0dXJuIGcodltDXSkgPyBudWxsIDogbmV3IEEoXCJJbnZhbGlkIFwiICsgUiArIFwiIGBcIiArIFAgKyBcImAgc3VwcGxpZWQgdG8gXCIgKyAoXCJgXCIgKyBPICsgXCJgLCBleHBlY3RlZCBhIFJlYWN0Tm9kZS5cIikpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGQocyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIF9lKHMsIHYsIEMsIE8sIFIpIHtcbiAgICAgIHJldHVybiBuZXcgQShcbiAgICAgICAgKHMgfHwgXCJSZWFjdCBjbGFzc1wiKSArIFwiOiBcIiArIHYgKyBcIiB0eXBlIGBcIiArIEMgKyBcIi5cIiArIE8gKyBcImAgaXMgaW52YWxpZDsgaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLCBidXQgcmVjZWl2ZWQgYFwiICsgUiArIFwiYC5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2Uocykge1xuICAgICAgZnVuY3Rpb24gdihDLCBPLCBSLCBQLCBEKSB7XG4gICAgICAgIHZhciBJID0gQ1tPXSwgVSA9IHgoSSk7XG4gICAgICAgIGlmIChVICE9PSBcIm9iamVjdFwiKVxuICAgICAgICAgIHJldHVybiBuZXcgQShcIkludmFsaWQgXCIgKyBQICsgXCIgYFwiICsgRCArIFwiYCBvZiB0eXBlIGBcIiArIFUgKyBcImAgXCIgKyAoXCJzdXBwbGllZCB0byBgXCIgKyBSICsgXCJgLCBleHBlY3RlZCBgb2JqZWN0YC5cIikpO1xuICAgICAgICBmb3IgKHZhciBHIGluIHMpIHtcbiAgICAgICAgICB2YXIgQiA9IHNbR107XG4gICAgICAgICAgaWYgKHR5cGVvZiBCICE9IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICAgIHJldHVybiBfZShSLCBQLCBELCBHLCBUKEIpKTtcbiAgICAgICAgICB2YXIgcmUgPSBCKEksIEcsIFIsIFAsIEQgKyBcIi5cIiArIEcsIHQpO1xuICAgICAgICAgIGlmIChyZSlcbiAgICAgICAgICAgIHJldHVybiByZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkKHYpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBUZShzKSB7XG4gICAgICBmdW5jdGlvbiB2KEMsIE8sIFIsIFAsIEQpIHtcbiAgICAgICAgdmFyIEkgPSBDW09dLCBVID0geChJKTtcbiAgICAgICAgaWYgKFUgIT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgcmV0dXJuIG5ldyBBKFwiSW52YWxpZCBcIiArIFAgKyBcIiBgXCIgKyBEICsgXCJgIG9mIHR5cGUgYFwiICsgVSArIFwiYCBcIiArIChcInN1cHBsaWVkIHRvIGBcIiArIFIgKyBcImAsIGV4cGVjdGVkIGBvYmplY3RgLlwiKSk7XG4gICAgICAgIHZhciBHID0gcih7fSwgQ1tPXSwgcyk7XG4gICAgICAgIGZvciAodmFyIEIgaW4gRykge1xuICAgICAgICAgIHZhciByZSA9IHNbQl07XG4gICAgICAgICAgaWYgKG4ocywgQikgJiYgdHlwZW9mIHJlICE9IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICAgIHJldHVybiBfZShSLCBQLCBELCBCLCBUKHJlKSk7XG4gICAgICAgICAgaWYgKCFyZSlcbiAgICAgICAgICAgIHJldHVybiBuZXcgQShcbiAgICAgICAgICAgICAgXCJJbnZhbGlkIFwiICsgUCArIFwiIGBcIiArIEQgKyBcImAga2V5IGBcIiArIEIgKyBcImAgc3VwcGxpZWQgdG8gYFwiICsgUiArIFwiYC5cXG5CYWQgb2JqZWN0OiBcIiArIEpTT04uc3RyaW5naWZ5KENbT10sIG51bGwsIFwiICBcIikgKyBgXG5WYWxpZCBrZXlzOiBgICsgSlNPTi5zdHJpbmdpZnkoT2JqZWN0LmtleXMocyksIG51bGwsIFwiICBcIilcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgdmFyIGIgPSByZShJLCBCLCBSLCBQLCBEICsgXCIuXCIgKyBCLCB0KTtcbiAgICAgICAgICBpZiAoYilcbiAgICAgICAgICAgIHJldHVybiBiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGQodik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGcocykge1xuICAgICAgc3dpdGNoICh0eXBlb2Ygcykge1xuICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgY2FzZSBcInVuZGVmaW5lZFwiOlxuICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgICAgICByZXR1cm4gIXM7XG4gICAgICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzKSlcbiAgICAgICAgICAgIHJldHVybiBzLmV2ZXJ5KGcpO1xuICAgICAgICAgIGlmIChzID09PSBudWxsIHx8IG8ocykpXG4gICAgICAgICAgICByZXR1cm4gITA7XG4gICAgICAgICAgdmFyIHYgPSBoKHMpO1xuICAgICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgICB2YXIgQyA9IHYuY2FsbChzKSwgTztcbiAgICAgICAgICAgIGlmICh2ICE9PSBzLmVudHJpZXMpIHtcbiAgICAgICAgICAgICAgZm9yICg7ICEoTyA9IEMubmV4dCgpKS5kb25lOyApXG4gICAgICAgICAgICAgICAgaWYgKCFnKE8udmFsdWUpKVxuICAgICAgICAgICAgICAgICAgcmV0dXJuICExO1xuICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgIGZvciAoOyAhKE8gPSBDLm5leHQoKSkuZG9uZTsgKSB7XG4gICAgICAgICAgICAgICAgdmFyIFIgPSBPLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmIChSICYmICFnKFJbMV0pKVxuICAgICAgICAgICAgICAgICAgcmV0dXJuICExO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gRShzLCB2KSB7XG4gICAgICByZXR1cm4gcyA9PT0gXCJzeW1ib2xcIiA/ICEwIDogdiA/IHZbXCJAQHRvU3RyaW5nVGFnXCJdID09PSBcIlN5bWJvbFwiIHx8IHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIHYgaW5zdGFuY2VvZiBTeW1ib2wgOiAhMTtcbiAgICB9XG4gICAgZnVuY3Rpb24geChzKSB7XG4gICAgICB2YXIgdiA9IHR5cGVvZiBzO1xuICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkocykgPyBcImFycmF5XCIgOiBzIGluc3RhbmNlb2YgUmVnRXhwID8gXCJvYmplY3RcIiA6IEUodiwgcykgPyBcInN5bWJvbFwiIDogdjtcbiAgICB9XG4gICAgZnVuY3Rpb24gVChzKSB7XG4gICAgICBpZiAodHlwZW9mIHMgPiBcInVcIiB8fCBzID09PSBudWxsKVxuICAgICAgICByZXR1cm4gXCJcIiArIHM7XG4gICAgICB2YXIgdiA9IHgocyk7XG4gICAgICBpZiAodiA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBpZiAocyBpbnN0YW5jZW9mIERhdGUpXG4gICAgICAgICAgcmV0dXJuIFwiZGF0ZVwiO1xuICAgICAgICBpZiAocyBpbnN0YW5jZW9mIFJlZ0V4cClcbiAgICAgICAgICByZXR1cm4gXCJyZWdleHBcIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2O1xuICAgIH1cbiAgICBmdW5jdGlvbiBtKHMpIHtcbiAgICAgIHZhciB2ID0gVChzKTtcbiAgICAgIHN3aXRjaCAodikge1xuICAgICAgICBjYXNlIFwiYXJyYXlcIjpcbiAgICAgICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgICAgIHJldHVybiBcImFuIFwiICsgdjtcbiAgICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgICAgY2FzZSBcImRhdGVcIjpcbiAgICAgICAgY2FzZSBcInJlZ2V4cFwiOlxuICAgICAgICAgIHJldHVybiBcImEgXCIgKyB2O1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiB2O1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBMKHMpIHtcbiAgICAgIHJldHVybiAhcy5jb25zdHJ1Y3RvciB8fCAhcy5jb25zdHJ1Y3Rvci5uYW1lID8gXyA6IHMuY29uc3RydWN0b3IubmFtZTtcbiAgICB9XG4gICAgcmV0dXJuIE0uY2hlY2tQcm9wVHlwZXMgPSBjLCBNLnJlc2V0V2FybmluZ0NhY2hlID0gYy5yZXNldFdhcm5pbmdDYWNoZSwgTS5Qcm9wVHlwZXMgPSBNLCBNO1xuICB9LCBQcjtcbn1cbmlmIChzZS5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIHZhciAkYSA9IGZuKCksIG1hID0gITA7XG4gIFVyLmV4cG9ydHMgPSBiYSgpKCRhLmlzRWxlbWVudCwgbWEpO1xufSBlbHNlXG4gIFVyLmV4cG9ydHMgPSB2YSgpKCk7XG52YXIgeGEgPSBVci5leHBvcnRzO1xuY29uc3QgemUgPSAvKiBAX19QVVJFX18gKi8ga3IoeGEpO1xuZnVuY3Rpb24gX2EoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBbXSwgdGhpcy5zaXplID0gMDtcbn1cbnZhciBFYSA9IF9hO1xuZnVuY3Rpb24gd2EoZSwgcikge1xuICByZXR1cm4gZSA9PT0gciB8fCBlICE9PSBlICYmIHIgIT09IHI7XG59XG52YXIgS3IgPSB3YSwgVGEgPSBLcjtcbmZ1bmN0aW9uIENhKGUsIHIpIHtcbiAgZm9yICh2YXIgdCA9IGUubGVuZ3RoOyB0LS07IClcbiAgICBpZiAoVGEoZVt0XVswXSwgcikpXG4gICAgICByZXR1cm4gdDtcbiAgcmV0dXJuIC0xO1xufVxudmFyIGRyID0gQ2EsIFNhID0gZHIsIFJhID0gQXJyYXkucHJvdG90eXBlLCBPYSA9IFJhLnNwbGljZTtcbmZ1bmN0aW9uIEFhKGUpIHtcbiAgdmFyIHIgPSB0aGlzLl9fZGF0YV9fLCB0ID0gU2EociwgZSk7XG4gIGlmICh0IDwgMClcbiAgICByZXR1cm4gITE7XG4gIHZhciBuID0gci5sZW5ndGggLSAxO1xuICByZXR1cm4gdCA9PSBuID8gci5wb3AoKSA6IE9hLmNhbGwociwgdCwgMSksIC0tdGhpcy5zaXplLCAhMDtcbn1cbnZhciBqYSA9IEFhLCBQYSA9IGRyO1xuZnVuY3Rpb24gSWEoZSkge1xuICB2YXIgciA9IHRoaXMuX19kYXRhX18sIHQgPSBQYShyLCBlKTtcbiAgcmV0dXJuIHQgPCAwID8gdm9pZCAwIDogclt0XVsxXTtcbn1cbnZhciBEYSA9IElhLCBNYSA9IGRyO1xuZnVuY3Rpb24gTGEoZSkge1xuICByZXR1cm4gTWEodGhpcy5fX2RhdGFfXywgZSkgPiAtMTtcbn1cbnZhciBGYSA9IExhLCBOYSA9IGRyO1xuZnVuY3Rpb24gVWEoZSwgcikge1xuICB2YXIgdCA9IHRoaXMuX19kYXRhX18sIG4gPSBOYSh0LCBlKTtcbiAgcmV0dXJuIG4gPCAwID8gKCsrdGhpcy5zaXplLCB0LnB1c2goW2UsIHJdKSkgOiB0W25dWzFdID0gciwgdGhpcztcbn1cbnZhciBCYSA9IFVhLCBxYSA9IEVhLCBZYSA9IGphLCBHYSA9IERhLCBXYSA9IEZhLCBrYSA9IEJhO1xuZnVuY3Rpb24gTGUoZSkge1xuICB2YXIgciA9IC0xLCB0ID0gZSA9PSBudWxsID8gMCA6IGUubGVuZ3RoO1xuICBmb3IgKHRoaXMuY2xlYXIoKTsgKytyIDwgdDsgKSB7XG4gICAgdmFyIG4gPSBlW3JdO1xuICAgIHRoaXMuc2V0KG5bMF0sIG5bMV0pO1xuICB9XG59XG5MZS5wcm90b3R5cGUuY2xlYXIgPSBxYTtcbkxlLnByb3RvdHlwZS5kZWxldGUgPSBZYTtcbkxlLnByb3RvdHlwZS5nZXQgPSBHYTtcbkxlLnByb3RvdHlwZS5oYXMgPSBXYTtcbkxlLnByb3RvdHlwZS5zZXQgPSBrYTtcbnZhciB2ciA9IExlLCB6YSA9IHZyO1xuZnVuY3Rpb24gS2EoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuZXcgemEoKSwgdGhpcy5zaXplID0gMDtcbn1cbnZhciBIYSA9IEthO1xuZnVuY3Rpb24gVmEoZSkge1xuICB2YXIgciA9IHRoaXMuX19kYXRhX18sIHQgPSByLmRlbGV0ZShlKTtcbiAgcmV0dXJuIHRoaXMuc2l6ZSA9IHIuc2l6ZSwgdDtcbn1cbnZhciBKYSA9IFZhO1xuZnVuY3Rpb24gWGEoZSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5nZXQoZSk7XG59XG52YXIgWmEgPSBYYTtcbmZ1bmN0aW9uIFFhKGUpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKGUpO1xufVxudmFyIGVpID0gUWEsIHJpID0gdHlwZW9mIHJyID09IFwib2JqZWN0XCIgJiYgcnIgJiYgcnIuT2JqZWN0ID09PSBPYmplY3QgJiYgcnIsIHZuID0gcmksIHRpID0gdm4sIG5pID0gdHlwZW9mIHNlbGYgPT0gXCJvYmplY3RcIiAmJiBzZWxmICYmIHNlbGYuT2JqZWN0ID09PSBPYmplY3QgJiYgc2VsZiwgYWkgPSB0aSB8fCBuaSB8fCBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCksICRlID0gYWksIGlpID0gJGUsIG9pID0gaWkuU3ltYm9sLCBwciA9IG9pLCBfdCA9IHByLCBwbiA9IE9iamVjdC5wcm90b3R5cGUsIHNpID0gcG4uaGFzT3duUHJvcGVydHksIGNpID0gcG4udG9TdHJpbmcsIEtlID0gX3QgPyBfdC50b1N0cmluZ1RhZyA6IHZvaWQgMDtcbmZ1bmN0aW9uIGxpKGUpIHtcbiAgdmFyIHIgPSBzaS5jYWxsKGUsIEtlKSwgdCA9IGVbS2VdO1xuICB0cnkge1xuICAgIGVbS2VdID0gdm9pZCAwO1xuICAgIHZhciBuID0gITA7XG4gIH0gY2F0Y2gge1xuICB9XG4gIHZhciBjID0gY2kuY2FsbChlKTtcbiAgcmV0dXJuIG4gJiYgKHIgPyBlW0tlXSA9IHQgOiBkZWxldGUgZVtLZV0pLCBjO1xufVxudmFyIHVpID0gbGksIGZpID0gT2JqZWN0LnByb3RvdHlwZSwgZGkgPSBmaS50b1N0cmluZztcbmZ1bmN0aW9uIHZpKGUpIHtcbiAgcmV0dXJuIGRpLmNhbGwoZSk7XG59XG52YXIgcGkgPSB2aSwgRXQgPSBwciwgeWkgPSB1aSwgZ2kgPSBwaSwgaGkgPSBcIltvYmplY3QgTnVsbF1cIiwgYmkgPSBcIltvYmplY3QgVW5kZWZpbmVkXVwiLCB3dCA9IEV0ID8gRXQudG9TdHJpbmdUYWcgOiB2b2lkIDA7XG5mdW5jdGlvbiAkaShlKSB7XG4gIHJldHVybiBlID09IG51bGwgPyBlID09PSB2b2lkIDAgPyBiaSA6IGhpIDogd3QgJiYgd3QgaW4gT2JqZWN0KGUpID8geWkoZSkgOiBnaShlKTtcbn1cbnZhciB5ciA9ICRpO1xuZnVuY3Rpb24gbWkoZSkge1xuICB2YXIgciA9IHR5cGVvZiBlO1xuICByZXR1cm4gZSAhPSBudWxsICYmIChyID09IFwib2JqZWN0XCIgfHwgciA9PSBcImZ1bmN0aW9uXCIpO1xufVxudmFyIFZlID0gbWksIHhpID0geXIsIF9pID0gVmUsIEVpID0gXCJbb2JqZWN0IEFzeW5jRnVuY3Rpb25dXCIsIHdpID0gXCJbb2JqZWN0IEZ1bmN0aW9uXVwiLCBUaSA9IFwiW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl1cIiwgQ2kgPSBcIltvYmplY3QgUHJveHldXCI7XG5mdW5jdGlvbiBTaShlKSB7XG4gIGlmICghX2koZSkpXG4gICAgcmV0dXJuICExO1xuICB2YXIgciA9IHhpKGUpO1xuICByZXR1cm4gciA9PSB3aSB8fCByID09IFRpIHx8IHIgPT0gRWkgfHwgciA9PSBDaTtcbn1cbnZhciB5biA9IFNpLCBSaSA9ICRlLCBPaSA9IFJpW1wiX19jb3JlLWpzX3NoYXJlZF9fXCJdLCBBaSA9IE9pLCBJciA9IEFpLCBUdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgZSA9IC9bXi5dKyQvLmV4ZWMoSXIgJiYgSXIua2V5cyAmJiBJci5rZXlzLklFX1BST1RPIHx8IFwiXCIpO1xuICByZXR1cm4gZSA/IFwiU3ltYm9sKHNyYylfMS5cIiArIGUgOiBcIlwiO1xufSgpO1xuZnVuY3Rpb24gamkoZSkge1xuICByZXR1cm4gISFUdCAmJiBUdCBpbiBlO1xufVxudmFyIFBpID0gamksIElpID0gRnVuY3Rpb24ucHJvdG90eXBlLCBEaSA9IElpLnRvU3RyaW5nO1xuZnVuY3Rpb24gTWkoZSkge1xuICBpZiAoZSAhPSBudWxsKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBEaS5jYWxsKGUpO1xuICAgIH0gY2F0Y2gge1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGUgKyBcIlwiO1xuICAgIH0gY2F0Y2gge1xuICAgIH1cbiAgfVxuICByZXR1cm4gXCJcIjtcbn1cbnZhciBnbiA9IE1pLCBMaSA9IHluLCBGaSA9IFBpLCBOaSA9IFZlLCBVaSA9IGduLCBCaSA9IC9bXFxcXF4kLiorPygpW1xcXXt9fF0vZywgcWkgPSAvXlxcW29iamVjdCAuKz9Db25zdHJ1Y3RvclxcXSQvLCBZaSA9IEZ1bmN0aW9uLnByb3RvdHlwZSwgR2kgPSBPYmplY3QucHJvdG90eXBlLCBXaSA9IFlpLnRvU3RyaW5nLCBraSA9IEdpLmhhc093blByb3BlcnR5LCB6aSA9IFJlZ0V4cChcbiAgXCJeXCIgKyBXaS5jYWxsKGtpKS5yZXBsYWNlKEJpLCBcIlxcXFwkJlwiKS5yZXBsYWNlKC9oYXNPd25Qcm9wZXJ0eXwoZnVuY3Rpb24pLio/KD89XFxcXFxcKCl8IGZvciAuKz8oPz1cXFxcXFxdKS9nLCBcIiQxLio/XCIpICsgXCIkXCJcbik7XG5mdW5jdGlvbiBLaShlKSB7XG4gIGlmICghTmkoZSkgfHwgRmkoZSkpXG4gICAgcmV0dXJuICExO1xuICB2YXIgciA9IExpKGUpID8gemkgOiBxaTtcbiAgcmV0dXJuIHIudGVzdChVaShlKSk7XG59XG52YXIgSGkgPSBLaTtcbmZ1bmN0aW9uIFZpKGUsIHIpIHtcbiAgcmV0dXJuIGUgPT0gbnVsbCA/IHZvaWQgMCA6IGVbcl07XG59XG52YXIgSmkgPSBWaSwgWGkgPSBIaSwgWmkgPSBKaTtcbmZ1bmN0aW9uIFFpKGUsIHIpIHtcbiAgdmFyIHQgPSBaaShlLCByKTtcbiAgcmV0dXJuIFhpKHQpID8gdCA6IHZvaWQgMDtcbn1cbnZhciBJZSA9IFFpLCBlbyA9IEllLCBybyA9ICRlLCB0byA9IGVvKHJvLCBcIk1hcFwiKSwgSHIgPSB0bywgbm8gPSBJZSwgYW8gPSBubyhPYmplY3QsIFwiY3JlYXRlXCIpLCBnciA9IGFvLCBDdCA9IGdyO1xuZnVuY3Rpb24gaW8oKSB7XG4gIHRoaXMuX19kYXRhX18gPSBDdCA/IEN0KG51bGwpIDoge30sIHRoaXMuc2l6ZSA9IDA7XG59XG52YXIgb28gPSBpbztcbmZ1bmN0aW9uIHNvKGUpIHtcbiAgdmFyIHIgPSB0aGlzLmhhcyhlKSAmJiBkZWxldGUgdGhpcy5fX2RhdGFfX1tlXTtcbiAgcmV0dXJuIHRoaXMuc2l6ZSAtPSByID8gMSA6IDAsIHI7XG59XG52YXIgY28gPSBzbywgbG8gPSBnciwgdW8gPSBcIl9fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX19cIiwgZm8gPSBPYmplY3QucHJvdG90eXBlLCB2byA9IGZvLmhhc093blByb3BlcnR5O1xuZnVuY3Rpb24gcG8oZSkge1xuICB2YXIgciA9IHRoaXMuX19kYXRhX187XG4gIGlmIChsbykge1xuICAgIHZhciB0ID0gcltlXTtcbiAgICByZXR1cm4gdCA9PT0gdW8gPyB2b2lkIDAgOiB0O1xuICB9XG4gIHJldHVybiB2by5jYWxsKHIsIGUpID8gcltlXSA6IHZvaWQgMDtcbn1cbnZhciB5byA9IHBvLCBnbyA9IGdyLCBobyA9IE9iamVjdC5wcm90b3R5cGUsIGJvID0gaG8uaGFzT3duUHJvcGVydHk7XG5mdW5jdGlvbiAkbyhlKSB7XG4gIHZhciByID0gdGhpcy5fX2RhdGFfXztcbiAgcmV0dXJuIGdvID8gcltlXSAhPT0gdm9pZCAwIDogYm8uY2FsbChyLCBlKTtcbn1cbnZhciBtbyA9ICRvLCB4byA9IGdyLCBfbyA9IFwiX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfX1wiO1xuZnVuY3Rpb24gRW8oZSwgcikge1xuICB2YXIgdCA9IHRoaXMuX19kYXRhX187XG4gIHJldHVybiB0aGlzLnNpemUgKz0gdGhpcy5oYXMoZSkgPyAwIDogMSwgdFtlXSA9IHhvICYmIHIgPT09IHZvaWQgMCA/IF9vIDogciwgdGhpcztcbn1cbnZhciB3byA9IEVvLCBUbyA9IG9vLCBDbyA9IGNvLCBTbyA9IHlvLCBSbyA9IG1vLCBPbyA9IHdvO1xuZnVuY3Rpb24gRmUoZSkge1xuICB2YXIgciA9IC0xLCB0ID0gZSA9PSBudWxsID8gMCA6IGUubGVuZ3RoO1xuICBmb3IgKHRoaXMuY2xlYXIoKTsgKytyIDwgdDsgKSB7XG4gICAgdmFyIG4gPSBlW3JdO1xuICAgIHRoaXMuc2V0KG5bMF0sIG5bMV0pO1xuICB9XG59XG5GZS5wcm90b3R5cGUuY2xlYXIgPSBUbztcbkZlLnByb3RvdHlwZS5kZWxldGUgPSBDbztcbkZlLnByb3RvdHlwZS5nZXQgPSBTbztcbkZlLnByb3RvdHlwZS5oYXMgPSBSbztcbkZlLnByb3RvdHlwZS5zZXQgPSBPbztcbnZhciBBbyA9IEZlLCBTdCA9IEFvLCBqbyA9IHZyLCBQbyA9IEhyO1xuZnVuY3Rpb24gSW8oKSB7XG4gIHRoaXMuc2l6ZSA9IDAsIHRoaXMuX19kYXRhX18gPSB7XG4gICAgaGFzaDogbmV3IFN0KCksXG4gICAgbWFwOiBuZXcgKFBvIHx8IGpvKSgpLFxuICAgIHN0cmluZzogbmV3IFN0KClcbiAgfTtcbn1cbnZhciBEbyA9IElvO1xuZnVuY3Rpb24gTW8oZSkge1xuICB2YXIgciA9IHR5cGVvZiBlO1xuICByZXR1cm4gciA9PSBcInN0cmluZ1wiIHx8IHIgPT0gXCJudW1iZXJcIiB8fCByID09IFwic3ltYm9sXCIgfHwgciA9PSBcImJvb2xlYW5cIiA/IGUgIT09IFwiX19wcm90b19fXCIgOiBlID09PSBudWxsO1xufVxudmFyIExvID0gTW8sIEZvID0gTG87XG5mdW5jdGlvbiBObyhlLCByKSB7XG4gIHZhciB0ID0gZS5fX2RhdGFfXztcbiAgcmV0dXJuIEZvKHIpID8gdFt0eXBlb2YgciA9PSBcInN0cmluZ1wiID8gXCJzdHJpbmdcIiA6IFwiaGFzaFwiXSA6IHQubWFwO1xufVxudmFyIGhyID0gTm8sIFVvID0gaHI7XG5mdW5jdGlvbiBCbyhlKSB7XG4gIHZhciByID0gVW8odGhpcywgZSkuZGVsZXRlKGUpO1xuICByZXR1cm4gdGhpcy5zaXplIC09IHIgPyAxIDogMCwgcjtcbn1cbnZhciBxbyA9IEJvLCBZbyA9IGhyO1xuZnVuY3Rpb24gR28oZSkge1xuICByZXR1cm4gWW8odGhpcywgZSkuZ2V0KGUpO1xufVxudmFyIFdvID0gR28sIGtvID0gaHI7XG5mdW5jdGlvbiB6byhlKSB7XG4gIHJldHVybiBrbyh0aGlzLCBlKS5oYXMoZSk7XG59XG52YXIgS28gPSB6bywgSG8gPSBocjtcbmZ1bmN0aW9uIFZvKGUsIHIpIHtcbiAgdmFyIHQgPSBIbyh0aGlzLCBlKSwgbiA9IHQuc2l6ZTtcbiAgcmV0dXJuIHQuc2V0KGUsIHIpLCB0aGlzLnNpemUgKz0gdC5zaXplID09IG4gPyAwIDogMSwgdGhpcztcbn1cbnZhciBKbyA9IFZvLCBYbyA9IERvLCBabyA9IHFvLCBRbyA9IFdvLCBlcyA9IEtvLCBycyA9IEpvO1xuZnVuY3Rpb24gTmUoZSkge1xuICB2YXIgciA9IC0xLCB0ID0gZSA9PSBudWxsID8gMCA6IGUubGVuZ3RoO1xuICBmb3IgKHRoaXMuY2xlYXIoKTsgKytyIDwgdDsgKSB7XG4gICAgdmFyIG4gPSBlW3JdO1xuICAgIHRoaXMuc2V0KG5bMF0sIG5bMV0pO1xuICB9XG59XG5OZS5wcm90b3R5cGUuY2xlYXIgPSBYbztcbk5lLnByb3RvdHlwZS5kZWxldGUgPSBabztcbk5lLnByb3RvdHlwZS5nZXQgPSBRbztcbk5lLnByb3RvdHlwZS5oYXMgPSBlcztcbk5lLnByb3RvdHlwZS5zZXQgPSBycztcbnZhciBobiA9IE5lLCB0cyA9IHZyLCBucyA9IEhyLCBhcyA9IGhuLCBpcyA9IDIwMDtcbmZ1bmN0aW9uIG9zKGUsIHIpIHtcbiAgdmFyIHQgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAodCBpbnN0YW5jZW9mIHRzKSB7XG4gICAgdmFyIG4gPSB0Ll9fZGF0YV9fO1xuICAgIGlmICghbnMgfHwgbi5sZW5ndGggPCBpcyAtIDEpXG4gICAgICByZXR1cm4gbi5wdXNoKFtlLCByXSksIHRoaXMuc2l6ZSA9ICsrdC5zaXplLCB0aGlzO1xuICAgIHQgPSB0aGlzLl9fZGF0YV9fID0gbmV3IGFzKG4pO1xuICB9XG4gIHJldHVybiB0LnNldChlLCByKSwgdGhpcy5zaXplID0gdC5zaXplLCB0aGlzO1xufVxudmFyIHNzID0gb3MsIGNzID0gdnIsIGxzID0gSGEsIHVzID0gSmEsIGZzID0gWmEsIGRzID0gZWksIHZzID0gc3M7XG5mdW5jdGlvbiBVZShlKSB7XG4gIHZhciByID0gdGhpcy5fX2RhdGFfXyA9IG5ldyBjcyhlKTtcbiAgdGhpcy5zaXplID0gci5zaXplO1xufVxuVWUucHJvdG90eXBlLmNsZWFyID0gbHM7XG5VZS5wcm90b3R5cGUuZGVsZXRlID0gdXM7XG5VZS5wcm90b3R5cGUuZ2V0ID0gZnM7XG5VZS5wcm90b3R5cGUuaGFzID0gZHM7XG5VZS5wcm90b3R5cGUuc2V0ID0gdnM7XG52YXIgYm4gPSBVZTtcbmZ1bmN0aW9uIHBzKGUsIHIpIHtcbiAgZm9yICh2YXIgdCA9IC0xLCBuID0gZSA9PSBudWxsID8gMCA6IGUubGVuZ3RoOyArK3QgPCBuICYmIHIoZVt0XSwgdCwgZSkgIT09ICExOyApXG4gICAgO1xuICByZXR1cm4gZTtcbn1cbnZhciB5cyA9IHBzLCBncyA9IEllLCBocyA9IGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIHZhciBlID0gZ3MoT2JqZWN0LCBcImRlZmluZVByb3BlcnR5XCIpO1xuICAgIHJldHVybiBlKHt9LCBcIlwiLCB7fSksIGU7XG4gIH0gY2F0Y2gge1xuICB9XG59KCksIGJzID0gaHMsIFJ0ID0gYnM7XG5mdW5jdGlvbiAkcyhlLCByLCB0KSB7XG4gIHIgPT0gXCJfX3Byb3RvX19cIiAmJiBSdCA/IFJ0KGUsIHIsIHtcbiAgICBjb25maWd1cmFibGU6ICEwLFxuICAgIGVudW1lcmFibGU6ICEwLFxuICAgIHZhbHVlOiB0LFxuICAgIHdyaXRhYmxlOiAhMFxuICB9KSA6IGVbcl0gPSB0O1xufVxudmFyICRuID0gJHMsIG1zID0gJG4sIHhzID0gS3IsIF9zID0gT2JqZWN0LnByb3RvdHlwZSwgRXMgPSBfcy5oYXNPd25Qcm9wZXJ0eTtcbmZ1bmN0aW9uIHdzKGUsIHIsIHQpIHtcbiAgdmFyIG4gPSBlW3JdO1xuICAoIShFcy5jYWxsKGUsIHIpICYmIHhzKG4sIHQpKSB8fCB0ID09PSB2b2lkIDAgJiYgIShyIGluIGUpKSAmJiBtcyhlLCByLCB0KTtcbn1cbnZhciBtbiA9IHdzLCBUcyA9IG1uLCBDcyA9ICRuO1xuZnVuY3Rpb24gU3MoZSwgciwgdCwgbikge1xuICB2YXIgYyA9ICF0O1xuICB0IHx8ICh0ID0ge30pO1xuICBmb3IgKHZhciBpID0gLTEsIGwgPSByLmxlbmd0aDsgKytpIDwgbDsgKSB7XG4gICAgdmFyIG8gPSByW2ldLCBwID0gbiA/IG4odFtvXSwgZVtvXSwgbywgdCwgZSkgOiB2b2lkIDA7XG4gICAgcCA9PT0gdm9pZCAwICYmIChwID0gZVtvXSksIGMgPyBDcyh0LCBvLCBwKSA6IFRzKHQsIG8sIHApO1xuICB9XG4gIHJldHVybiB0O1xufVxudmFyIGJyID0gU3M7XG5mdW5jdGlvbiBScyhlLCByKSB7XG4gIGZvciAodmFyIHQgPSAtMSwgbiA9IEFycmF5KGUpOyArK3QgPCBlOyApXG4gICAgblt0XSA9IHIodCk7XG4gIHJldHVybiBuO1xufVxudmFyIE9zID0gUnM7XG5mdW5jdGlvbiBBcyhlKSB7XG4gIHJldHVybiBlICE9IG51bGwgJiYgdHlwZW9mIGUgPT0gXCJvYmplY3RcIjtcbn1cbnZhciBCZSA9IEFzLCBqcyA9IHlyLCBQcyA9IEJlLCBJcyA9IFwiW29iamVjdCBBcmd1bWVudHNdXCI7XG5mdW5jdGlvbiBEcyhlKSB7XG4gIHJldHVybiBQcyhlKSAmJiBqcyhlKSA9PSBJcztcbn1cbnZhciBNcyA9IERzLCBPdCA9IE1zLCBMcyA9IEJlLCB4biA9IE9iamVjdC5wcm90b3R5cGUsIEZzID0geG4uaGFzT3duUHJvcGVydHksIE5zID0geG4ucHJvcGVydHlJc0VudW1lcmFibGUsIFVzID0gT3QoZnVuY3Rpb24oKSB7XG4gIHJldHVybiBhcmd1bWVudHM7XG59KCkpID8gT3QgOiBmdW5jdGlvbihlKSB7XG4gIHJldHVybiBMcyhlKSAmJiBGcy5jYWxsKGUsIFwiY2FsbGVlXCIpICYmICFOcy5jYWxsKGUsIFwiY2FsbGVlXCIpO1xufSwgQnMgPSBVcywgcXMgPSBBcnJheS5pc0FycmF5LCAkciA9IHFzLCBjciA9IHsgZXhwb3J0czoge30gfTtcbmZ1bmN0aW9uIFlzKCkge1xuICByZXR1cm4gITE7XG59XG52YXIgR3MgPSBZcztcbmNyLmV4cG9ydHM7XG4oZnVuY3Rpb24oZSwgcikge1xuICB2YXIgdCA9ICRlLCBuID0gR3MsIGMgPSByICYmICFyLm5vZGVUeXBlICYmIHIsIGkgPSBjICYmICEwICYmIGUgJiYgIWUubm9kZVR5cGUgJiYgZSwgbCA9IGkgJiYgaS5leHBvcnRzID09PSBjLCBvID0gbCA/IHQuQnVmZmVyIDogdm9pZCAwLCBwID0gbyA/IG8uaXNCdWZmZXIgOiB2b2lkIDAsIHUgPSBwIHx8IG47XG4gIGUuZXhwb3J0cyA9IHU7XG59KShjciwgY3IuZXhwb3J0cyk7XG52YXIgVnIgPSBjci5leHBvcnRzLCBXcyA9IDkwMDcxOTkyNTQ3NDA5OTEsIGtzID0gL14oPzowfFsxLTldXFxkKikkLztcbmZ1bmN0aW9uIHpzKGUsIHIpIHtcbiAgdmFyIHQgPSB0eXBlb2YgZTtcbiAgcmV0dXJuIHIgPSByID8/IFdzLCAhIXIgJiYgKHQgPT0gXCJudW1iZXJcIiB8fCB0ICE9IFwic3ltYm9sXCIgJiYga3MudGVzdChlKSkgJiYgZSA+IC0xICYmIGUgJSAxID09IDAgJiYgZSA8IHI7XG59XG52YXIgS3MgPSB6cywgSHMgPSA5MDA3MTk5MjU0NzQwOTkxO1xuZnVuY3Rpb24gVnMoZSkge1xuICByZXR1cm4gdHlwZW9mIGUgPT0gXCJudW1iZXJcIiAmJiBlID4gLTEgJiYgZSAlIDEgPT0gMCAmJiBlIDw9IEhzO1xufVxudmFyIF9uID0gVnMsIEpzID0geXIsIFhzID0gX24sIFpzID0gQmUsIFFzID0gXCJbb2JqZWN0IEFyZ3VtZW50c11cIiwgZWMgPSBcIltvYmplY3QgQXJyYXldXCIsIHJjID0gXCJbb2JqZWN0IEJvb2xlYW5dXCIsIHRjID0gXCJbb2JqZWN0IERhdGVdXCIsIG5jID0gXCJbb2JqZWN0IEVycm9yXVwiLCBhYyA9IFwiW29iamVjdCBGdW5jdGlvbl1cIiwgaWMgPSBcIltvYmplY3QgTWFwXVwiLCBvYyA9IFwiW29iamVjdCBOdW1iZXJdXCIsIHNjID0gXCJbb2JqZWN0IE9iamVjdF1cIiwgY2MgPSBcIltvYmplY3QgUmVnRXhwXVwiLCBsYyA9IFwiW29iamVjdCBTZXRdXCIsIHVjID0gXCJbb2JqZWN0IFN0cmluZ11cIiwgZmMgPSBcIltvYmplY3QgV2Vha01hcF1cIiwgZGMgPSBcIltvYmplY3QgQXJyYXlCdWZmZXJdXCIsIHZjID0gXCJbb2JqZWN0IERhdGFWaWV3XVwiLCBwYyA9IFwiW29iamVjdCBGbG9hdDMyQXJyYXldXCIsIHljID0gXCJbb2JqZWN0IEZsb2F0NjRBcnJheV1cIiwgZ2MgPSBcIltvYmplY3QgSW50OEFycmF5XVwiLCBoYyA9IFwiW29iamVjdCBJbnQxNkFycmF5XVwiLCBiYyA9IFwiW29iamVjdCBJbnQzMkFycmF5XVwiLCAkYyA9IFwiW29iamVjdCBVaW50OEFycmF5XVwiLCBtYyA9IFwiW29iamVjdCBVaW50OENsYW1wZWRBcnJheV1cIiwgeGMgPSBcIltvYmplY3QgVWludDE2QXJyYXldXCIsIF9jID0gXCJbb2JqZWN0IFVpbnQzMkFycmF5XVwiLCBIID0ge307XG5IW3BjXSA9IEhbeWNdID0gSFtnY10gPSBIW2hjXSA9IEhbYmNdID0gSFskY10gPSBIW21jXSA9IEhbeGNdID0gSFtfY10gPSAhMDtcbkhbUXNdID0gSFtlY10gPSBIW2RjXSA9IEhbcmNdID0gSFt2Y10gPSBIW3RjXSA9IEhbbmNdID0gSFthY10gPSBIW2ljXSA9IEhbb2NdID0gSFtzY10gPSBIW2NjXSA9IEhbbGNdID0gSFt1Y10gPSBIW2ZjXSA9ICExO1xuZnVuY3Rpb24gRWMoZSkge1xuICByZXR1cm4gWnMoZSkgJiYgWHMoZS5sZW5ndGgpICYmICEhSFtKcyhlKV07XG59XG52YXIgd2MgPSBFYztcbmZ1bmN0aW9uIFRjKGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHIpIHtcbiAgICByZXR1cm4gZShyKTtcbiAgfTtcbn1cbnZhciBKciA9IFRjLCBsciA9IHsgZXhwb3J0czoge30gfTtcbmxyLmV4cG9ydHM7XG4oZnVuY3Rpb24oZSwgcikge1xuICB2YXIgdCA9IHZuLCBuID0gciAmJiAhci5ub2RlVHlwZSAmJiByLCBjID0gbiAmJiAhMCAmJiBlICYmICFlLm5vZGVUeXBlICYmIGUsIGkgPSBjICYmIGMuZXhwb3J0cyA9PT0gbiwgbCA9IGkgJiYgdC5wcm9jZXNzLCBvID0gZnVuY3Rpb24oKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBwID0gYyAmJiBjLnJlcXVpcmUgJiYgYy5yZXF1aXJlKFwidXRpbFwiKS50eXBlcztcbiAgICAgIHJldHVybiBwIHx8IGwgJiYgbC5iaW5kaW5nICYmIGwuYmluZGluZyhcInV0aWxcIik7XG4gICAgfSBjYXRjaCB7XG4gICAgfVxuICB9KCk7XG4gIGUuZXhwb3J0cyA9IG87XG59KShsciwgbHIuZXhwb3J0cyk7XG52YXIgWHIgPSBsci5leHBvcnRzLCBDYyA9IHdjLCBTYyA9IEpyLCBBdCA9IFhyLCBqdCA9IEF0ICYmIEF0LmlzVHlwZWRBcnJheSwgUmMgPSBqdCA/IFNjKGp0KSA6IENjLCBFbiA9IFJjLCBPYyA9IE9zLCBBYyA9IEJzLCBqYyA9ICRyLCBQYyA9IFZyLCBJYyA9IEtzLCBEYyA9IEVuLCBNYyA9IE9iamVjdC5wcm90b3R5cGUsIExjID0gTWMuaGFzT3duUHJvcGVydHk7XG5mdW5jdGlvbiBGYyhlLCByKSB7XG4gIHZhciB0ID0gamMoZSksIG4gPSAhdCAmJiBBYyhlKSwgYyA9ICF0ICYmICFuICYmIFBjKGUpLCBpID0gIXQgJiYgIW4gJiYgIWMgJiYgRGMoZSksIGwgPSB0IHx8IG4gfHwgYyB8fCBpLCBvID0gbCA/IE9jKGUubGVuZ3RoLCBTdHJpbmcpIDogW10sIHAgPSBvLmxlbmd0aDtcbiAgZm9yICh2YXIgdSBpbiBlKVxuICAgIChyIHx8IExjLmNhbGwoZSwgdSkpICYmICEobCAmJiAvLyBTYWZhcmkgOSBoYXMgZW51bWVyYWJsZSBgYXJndW1lbnRzLmxlbmd0aGAgaW4gc3RyaWN0IG1vZGUuXG4gICAgKHUgPT0gXCJsZW5ndGhcIiB8fCAvLyBOb2RlLmpzIDAuMTAgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gYnVmZmVycy5cbiAgICBjICYmICh1ID09IFwib2Zmc2V0XCIgfHwgdSA9PSBcInBhcmVudFwiKSB8fCAvLyBQaGFudG9tSlMgMiBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiB0eXBlZCBhcnJheXMuXG4gICAgaSAmJiAodSA9PSBcImJ1ZmZlclwiIHx8IHUgPT0gXCJieXRlTGVuZ3RoXCIgfHwgdSA9PSBcImJ5dGVPZmZzZXRcIikgfHwgLy8gU2tpcCBpbmRleCBwcm9wZXJ0aWVzLlxuICAgIEljKHUsIHApKSkgJiYgby5wdXNoKHUpO1xuICByZXR1cm4gbztcbn1cbnZhciB3biA9IEZjLCBOYyA9IE9iamVjdC5wcm90b3R5cGU7XG5mdW5jdGlvbiBVYyhlKSB7XG4gIHZhciByID0gZSAmJiBlLmNvbnN0cnVjdG9yLCB0ID0gdHlwZW9mIHIgPT0gXCJmdW5jdGlvblwiICYmIHIucHJvdG90eXBlIHx8IE5jO1xuICByZXR1cm4gZSA9PT0gdDtcbn1cbnZhciBaciA9IFVjO1xuZnVuY3Rpb24gQmMoZSwgcikge1xuICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgIHJldHVybiBlKHIodCkpO1xuICB9O1xufVxudmFyIFRuID0gQmMsIHFjID0gVG4sIFljID0gcWMoT2JqZWN0LmtleXMsIE9iamVjdCksIEdjID0gWWMsIFdjID0gWnIsIGtjID0gR2MsIHpjID0gT2JqZWN0LnByb3RvdHlwZSwgS2MgPSB6Yy5oYXNPd25Qcm9wZXJ0eTtcbmZ1bmN0aW9uIEhjKGUpIHtcbiAgaWYgKCFXYyhlKSlcbiAgICByZXR1cm4ga2MoZSk7XG4gIHZhciByID0gW107XG4gIGZvciAodmFyIHQgaW4gT2JqZWN0KGUpKVxuICAgIEtjLmNhbGwoZSwgdCkgJiYgdCAhPSBcImNvbnN0cnVjdG9yXCIgJiYgci5wdXNoKHQpO1xuICByZXR1cm4gcjtcbn1cbnZhciBWYyA9IEhjLCBKYyA9IHluLCBYYyA9IF9uO1xuZnVuY3Rpb24gWmMoZSkge1xuICByZXR1cm4gZSAhPSBudWxsICYmIFhjKGUubGVuZ3RoKSAmJiAhSmMoZSk7XG59XG52YXIgQ24gPSBaYywgUWMgPSB3biwgZWwgPSBWYywgcmwgPSBDbjtcbmZ1bmN0aW9uIHRsKGUpIHtcbiAgcmV0dXJuIHJsKGUpID8gUWMoZSkgOiBlbChlKTtcbn1cbnZhciBRciA9IHRsLCBubCA9IGJyLCBhbCA9IFFyO1xuZnVuY3Rpb24gaWwoZSwgcikge1xuICByZXR1cm4gZSAmJiBubChyLCBhbChyKSwgZSk7XG59XG52YXIgb2wgPSBpbDtcbmZ1bmN0aW9uIHNsKGUpIHtcbiAgdmFyIHIgPSBbXTtcbiAgaWYgKGUgIT0gbnVsbClcbiAgICBmb3IgKHZhciB0IGluIE9iamVjdChlKSlcbiAgICAgIHIucHVzaCh0KTtcbiAgcmV0dXJuIHI7XG59XG52YXIgY2wgPSBzbCwgbGwgPSBWZSwgdWwgPSBaciwgZmwgPSBjbCwgZGwgPSBPYmplY3QucHJvdG90eXBlLCB2bCA9IGRsLmhhc093blByb3BlcnR5O1xuZnVuY3Rpb24gcGwoZSkge1xuICBpZiAoIWxsKGUpKVxuICAgIHJldHVybiBmbChlKTtcbiAgdmFyIHIgPSB1bChlKSwgdCA9IFtdO1xuICBmb3IgKHZhciBuIGluIGUpXG4gICAgbiA9PSBcImNvbnN0cnVjdG9yXCIgJiYgKHIgfHwgIXZsLmNhbGwoZSwgbikpIHx8IHQucHVzaChuKTtcbiAgcmV0dXJuIHQ7XG59XG52YXIgeWwgPSBwbCwgZ2wgPSB3biwgaGwgPSB5bCwgYmwgPSBDbjtcbmZ1bmN0aW9uICRsKGUpIHtcbiAgcmV0dXJuIGJsKGUpID8gZ2woZSwgITApIDogaGwoZSk7XG59XG52YXIgZXQgPSAkbCwgbWwgPSBiciwgeGwgPSBldDtcbmZ1bmN0aW9uIF9sKGUsIHIpIHtcbiAgcmV0dXJuIGUgJiYgbWwociwgeGwociksIGUpO1xufVxudmFyIEVsID0gX2wsIHVyID0geyBleHBvcnRzOiB7fSB9O1xudXIuZXhwb3J0cztcbihmdW5jdGlvbihlLCByKSB7XG4gIHZhciB0ID0gJGUsIG4gPSByICYmICFyLm5vZGVUeXBlICYmIHIsIGMgPSBuICYmICEwICYmIGUgJiYgIWUubm9kZVR5cGUgJiYgZSwgaSA9IGMgJiYgYy5leHBvcnRzID09PSBuLCBsID0gaSA/IHQuQnVmZmVyIDogdm9pZCAwLCBvID0gbCA/IGwuYWxsb2NVbnNhZmUgOiB2b2lkIDA7XG4gIGZ1bmN0aW9uIHAodSwgZikge1xuICAgIGlmIChmKVxuICAgICAgcmV0dXJuIHUuc2xpY2UoKTtcbiAgICB2YXIgaCA9IHUubGVuZ3RoLCBfID0gbyA/IG8oaCkgOiBuZXcgdS5jb25zdHJ1Y3RvcihoKTtcbiAgICByZXR1cm4gdS5jb3B5KF8pLCBfO1xuICB9XG4gIGUuZXhwb3J0cyA9IHA7XG59KSh1ciwgdXIuZXhwb3J0cyk7XG52YXIgd2wgPSB1ci5leHBvcnRzO1xuZnVuY3Rpb24gVGwoZSwgcikge1xuICB2YXIgdCA9IC0xLCBuID0gZS5sZW5ndGg7XG4gIGZvciAociB8fCAociA9IEFycmF5KG4pKTsgKyt0IDwgbjsgKVxuICAgIHJbdF0gPSBlW3RdO1xuICByZXR1cm4gcjtcbn1cbnZhciBDbCA9IFRsO1xuZnVuY3Rpb24gU2woZSwgcikge1xuICBmb3IgKHZhciB0ID0gLTEsIG4gPSBlID09IG51bGwgPyAwIDogZS5sZW5ndGgsIGMgPSAwLCBpID0gW107ICsrdCA8IG47ICkge1xuICAgIHZhciBsID0gZVt0XTtcbiAgICByKGwsIHQsIGUpICYmIChpW2MrK10gPSBsKTtcbiAgfVxuICByZXR1cm4gaTtcbn1cbnZhciBSbCA9IFNsO1xuZnVuY3Rpb24gT2woKSB7XG4gIHJldHVybiBbXTtcbn1cbnZhciBTbiA9IE9sLCBBbCA9IFJsLCBqbCA9IFNuLCBQbCA9IE9iamVjdC5wcm90b3R5cGUsIElsID0gUGwucHJvcGVydHlJc0VudW1lcmFibGUsIFB0ID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scywgRGwgPSBQdCA/IGZ1bmN0aW9uKGUpIHtcbiAgcmV0dXJuIGUgPT0gbnVsbCA/IFtdIDogKGUgPSBPYmplY3QoZSksIEFsKFB0KGUpLCBmdW5jdGlvbihyKSB7XG4gICAgcmV0dXJuIElsLmNhbGwoZSwgcik7XG4gIH0pKTtcbn0gOiBqbCwgcnQgPSBEbCwgTWwgPSBiciwgTGwgPSBydDtcbmZ1bmN0aW9uIEZsKGUsIHIpIHtcbiAgcmV0dXJuIE1sKGUsIExsKGUpLCByKTtcbn1cbnZhciBObCA9IEZsO1xuZnVuY3Rpb24gVWwoZSwgcikge1xuICBmb3IgKHZhciB0ID0gLTEsIG4gPSByLmxlbmd0aCwgYyA9IGUubGVuZ3RoOyArK3QgPCBuOyApXG4gICAgZVtjICsgdF0gPSByW3RdO1xuICByZXR1cm4gZTtcbn1cbnZhciBSbiA9IFVsLCBCbCA9IFRuLCBxbCA9IEJsKE9iamVjdC5nZXRQcm90b3R5cGVPZiwgT2JqZWN0KSwgT24gPSBxbCwgWWwgPSBSbiwgR2wgPSBPbiwgV2wgPSBydCwga2wgPSBTbiwgemwgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzLCBLbCA9IHpsID8gZnVuY3Rpb24oZSkge1xuICBmb3IgKHZhciByID0gW107IGU7IClcbiAgICBZbChyLCBXbChlKSksIGUgPSBHbChlKTtcbiAgcmV0dXJuIHI7XG59IDoga2wsIEFuID0gS2wsIEhsID0gYnIsIFZsID0gQW47XG5mdW5jdGlvbiBKbChlLCByKSB7XG4gIHJldHVybiBIbChlLCBWbChlKSwgcik7XG59XG52YXIgWGwgPSBKbCwgWmwgPSBSbiwgUWwgPSAkcjtcbmZ1bmN0aW9uIGV1KGUsIHIsIHQpIHtcbiAgdmFyIG4gPSByKGUpO1xuICByZXR1cm4gUWwoZSkgPyBuIDogWmwobiwgdChlKSk7XG59XG52YXIgam4gPSBldSwgcnUgPSBqbiwgdHUgPSBydCwgbnUgPSBRcjtcbmZ1bmN0aW9uIGF1KGUpIHtcbiAgcmV0dXJuIHJ1KGUsIG51LCB0dSk7XG59XG52YXIgUG4gPSBhdSwgaXUgPSBqbiwgb3UgPSBBbiwgc3UgPSBldDtcbmZ1bmN0aW9uIGN1KGUpIHtcbiAgcmV0dXJuIGl1KGUsIHN1LCBvdSk7XG59XG52YXIgbHUgPSBjdSwgdXUgPSBJZSwgZnUgPSAkZSwgZHUgPSB1dShmdSwgXCJEYXRhVmlld1wiKSwgdnUgPSBkdSwgcHUgPSBJZSwgeXUgPSAkZSwgZ3UgPSBwdSh5dSwgXCJQcm9taXNlXCIpLCBodSA9IGd1LCBidSA9IEllLCAkdSA9ICRlLCBtdSA9IGJ1KCR1LCBcIlNldFwiKSwgeHUgPSBtdSwgX3UgPSBJZSwgRXUgPSAkZSwgd3UgPSBfdShFdSwgXCJXZWFrTWFwXCIpLCBUdSA9IHd1LCBCciA9IHZ1LCBxciA9IEhyLCBZciA9IGh1LCBHciA9IHh1LCBXciA9IFR1LCBJbiA9IHlyLCBxZSA9IGduLCBJdCA9IFwiW29iamVjdCBNYXBdXCIsIEN1ID0gXCJbb2JqZWN0IE9iamVjdF1cIiwgRHQgPSBcIltvYmplY3QgUHJvbWlzZV1cIiwgTXQgPSBcIltvYmplY3QgU2V0XVwiLCBMdCA9IFwiW29iamVjdCBXZWFrTWFwXVwiLCBGdCA9IFwiW29iamVjdCBEYXRhVmlld11cIiwgU3UgPSBxZShCciksIFJ1ID0gcWUocXIpLCBPdSA9IHFlKFlyKSwgQXUgPSBxZShHciksIGp1ID0gcWUoV3IpLCBqZSA9IEluO1xuKEJyICYmIGplKG5ldyBCcihuZXcgQXJyYXlCdWZmZXIoMSkpKSAhPSBGdCB8fCBxciAmJiBqZShuZXcgcXIoKSkgIT0gSXQgfHwgWXIgJiYgamUoWXIucmVzb2x2ZSgpKSAhPSBEdCB8fCBHciAmJiBqZShuZXcgR3IoKSkgIT0gTXQgfHwgV3IgJiYgamUobmV3IFdyKCkpICE9IEx0KSAmJiAoamUgPSBmdW5jdGlvbihlKSB7XG4gIHZhciByID0gSW4oZSksIHQgPSByID09IEN1ID8gZS5jb25zdHJ1Y3RvciA6IHZvaWQgMCwgbiA9IHQgPyBxZSh0KSA6IFwiXCI7XG4gIGlmIChuKVxuICAgIHN3aXRjaCAobikge1xuICAgICAgY2FzZSBTdTpcbiAgICAgICAgcmV0dXJuIEZ0O1xuICAgICAgY2FzZSBSdTpcbiAgICAgICAgcmV0dXJuIEl0O1xuICAgICAgY2FzZSBPdTpcbiAgICAgICAgcmV0dXJuIER0O1xuICAgICAgY2FzZSBBdTpcbiAgICAgICAgcmV0dXJuIE10O1xuICAgICAgY2FzZSBqdTpcbiAgICAgICAgcmV0dXJuIEx0O1xuICAgIH1cbiAgcmV0dXJuIHI7XG59KTtcbnZhciBtciA9IGplLCBQdSA9IE9iamVjdC5wcm90b3R5cGUsIEl1ID0gUHUuaGFzT3duUHJvcGVydHk7XG5mdW5jdGlvbiBEdShlKSB7XG4gIHZhciByID0gZS5sZW5ndGgsIHQgPSBuZXcgZS5jb25zdHJ1Y3RvcihyKTtcbiAgcmV0dXJuIHIgJiYgdHlwZW9mIGVbMF0gPT0gXCJzdHJpbmdcIiAmJiBJdS5jYWxsKGUsIFwiaW5kZXhcIikgJiYgKHQuaW5kZXggPSBlLmluZGV4LCB0LmlucHV0ID0gZS5pbnB1dCksIHQ7XG59XG52YXIgTXUgPSBEdSwgTHUgPSAkZSwgRnUgPSBMdS5VaW50OEFycmF5LCBEbiA9IEZ1LCBOdCA9IERuO1xuZnVuY3Rpb24gTnUoZSkge1xuICB2YXIgciA9IG5ldyBlLmNvbnN0cnVjdG9yKGUuYnl0ZUxlbmd0aCk7XG4gIHJldHVybiBuZXcgTnQocikuc2V0KG5ldyBOdChlKSksIHI7XG59XG52YXIgdHQgPSBOdSwgVXUgPSB0dDtcbmZ1bmN0aW9uIEJ1KGUsIHIpIHtcbiAgdmFyIHQgPSByID8gVXUoZS5idWZmZXIpIDogZS5idWZmZXI7XG4gIHJldHVybiBuZXcgZS5jb25zdHJ1Y3Rvcih0LCBlLmJ5dGVPZmZzZXQsIGUuYnl0ZUxlbmd0aCk7XG59XG52YXIgcXUgPSBCdSwgWXUgPSAvXFx3KiQvO1xuZnVuY3Rpb24gR3UoZSkge1xuICB2YXIgciA9IG5ldyBlLmNvbnN0cnVjdG9yKGUuc291cmNlLCBZdS5leGVjKGUpKTtcbiAgcmV0dXJuIHIubGFzdEluZGV4ID0gZS5sYXN0SW5kZXgsIHI7XG59XG52YXIgV3UgPSBHdSwgVXQgPSBwciwgQnQgPSBVdCA/IFV0LnByb3RvdHlwZSA6IHZvaWQgMCwgcXQgPSBCdCA/IEJ0LnZhbHVlT2YgOiB2b2lkIDA7XG5mdW5jdGlvbiBrdShlKSB7XG4gIHJldHVybiBxdCA/IE9iamVjdChxdC5jYWxsKGUpKSA6IHt9O1xufVxudmFyIHp1ID0ga3UsIEt1ID0gdHQ7XG5mdW5jdGlvbiBIdShlLCByKSB7XG4gIHZhciB0ID0gciA/IEt1KGUuYnVmZmVyKSA6IGUuYnVmZmVyO1xuICByZXR1cm4gbmV3IGUuY29uc3RydWN0b3IodCwgZS5ieXRlT2Zmc2V0LCBlLmxlbmd0aCk7XG59XG52YXIgVnUgPSBIdSwgSnUgPSB0dCwgWHUgPSBxdSwgWnUgPSBXdSwgUXUgPSB6dSwgZWYgPSBWdSwgcmYgPSBcIltvYmplY3QgQm9vbGVhbl1cIiwgdGYgPSBcIltvYmplY3QgRGF0ZV1cIiwgbmYgPSBcIltvYmplY3QgTWFwXVwiLCBhZiA9IFwiW29iamVjdCBOdW1iZXJdXCIsIG9mID0gXCJbb2JqZWN0IFJlZ0V4cF1cIiwgc2YgPSBcIltvYmplY3QgU2V0XVwiLCBjZiA9IFwiW29iamVjdCBTdHJpbmddXCIsIGxmID0gXCJbb2JqZWN0IFN5bWJvbF1cIiwgdWYgPSBcIltvYmplY3QgQXJyYXlCdWZmZXJdXCIsIGZmID0gXCJbb2JqZWN0IERhdGFWaWV3XVwiLCBkZiA9IFwiW29iamVjdCBGbG9hdDMyQXJyYXldXCIsIHZmID0gXCJbb2JqZWN0IEZsb2F0NjRBcnJheV1cIiwgcGYgPSBcIltvYmplY3QgSW50OEFycmF5XVwiLCB5ZiA9IFwiW29iamVjdCBJbnQxNkFycmF5XVwiLCBnZiA9IFwiW29iamVjdCBJbnQzMkFycmF5XVwiLCBoZiA9IFwiW29iamVjdCBVaW50OEFycmF5XVwiLCBiZiA9IFwiW29iamVjdCBVaW50OENsYW1wZWRBcnJheV1cIiwgJGYgPSBcIltvYmplY3QgVWludDE2QXJyYXldXCIsIG1mID0gXCJbb2JqZWN0IFVpbnQzMkFycmF5XVwiO1xuZnVuY3Rpb24geGYoZSwgciwgdCkge1xuICB2YXIgbiA9IGUuY29uc3RydWN0b3I7XG4gIHN3aXRjaCAocikge1xuICAgIGNhc2UgdWY6XG4gICAgICByZXR1cm4gSnUoZSk7XG4gICAgY2FzZSByZjpcbiAgICBjYXNlIHRmOlxuICAgICAgcmV0dXJuIG5ldyBuKCtlKTtcbiAgICBjYXNlIGZmOlxuICAgICAgcmV0dXJuIFh1KGUsIHQpO1xuICAgIGNhc2UgZGY6XG4gICAgY2FzZSB2ZjpcbiAgICBjYXNlIHBmOlxuICAgIGNhc2UgeWY6XG4gICAgY2FzZSBnZjpcbiAgICBjYXNlIGhmOlxuICAgIGNhc2UgYmY6XG4gICAgY2FzZSAkZjpcbiAgICBjYXNlIG1mOlxuICAgICAgcmV0dXJuIGVmKGUsIHQpO1xuICAgIGNhc2UgbmY6XG4gICAgICByZXR1cm4gbmV3IG4oKTtcbiAgICBjYXNlIGFmOlxuICAgIGNhc2UgY2Y6XG4gICAgICByZXR1cm4gbmV3IG4oZSk7XG4gICAgY2FzZSBvZjpcbiAgICAgIHJldHVybiBadShlKTtcbiAgICBjYXNlIHNmOlxuICAgICAgcmV0dXJuIG5ldyBuKCk7XG4gICAgY2FzZSBsZjpcbiAgICAgIHJldHVybiBRdShlKTtcbiAgfVxufVxudmFyIF9mID0geGYsIEVmID0gVmUsIFl0ID0gT2JqZWN0LmNyZWF0ZSwgd2YgPSBmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gZSgpIHtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24ocikge1xuICAgIGlmICghRWYocikpXG4gICAgICByZXR1cm4ge307XG4gICAgaWYgKFl0KVxuICAgICAgcmV0dXJuIFl0KHIpO1xuICAgIGUucHJvdG90eXBlID0gcjtcbiAgICB2YXIgdCA9IG5ldyBlKCk7XG4gICAgcmV0dXJuIGUucHJvdG90eXBlID0gdm9pZCAwLCB0O1xuICB9O1xufSgpLCBUZiA9IHdmLCBDZiA9IFRmLCBTZiA9IE9uLCBSZiA9IFpyO1xuZnVuY3Rpb24gT2YoZSkge1xuICByZXR1cm4gdHlwZW9mIGUuY29uc3RydWN0b3IgPT0gXCJmdW5jdGlvblwiICYmICFSZihlKSA/IENmKFNmKGUpKSA6IHt9O1xufVxudmFyIEFmID0gT2YsIGpmID0gbXIsIFBmID0gQmUsIElmID0gXCJbb2JqZWN0IE1hcF1cIjtcbmZ1bmN0aW9uIERmKGUpIHtcbiAgcmV0dXJuIFBmKGUpICYmIGpmKGUpID09IElmO1xufVxudmFyIE1mID0gRGYsIExmID0gTWYsIEZmID0gSnIsIEd0ID0gWHIsIFd0ID0gR3QgJiYgR3QuaXNNYXAsIE5mID0gV3QgPyBGZihXdCkgOiBMZiwgVWYgPSBOZiwgQmYgPSBtciwgcWYgPSBCZSwgWWYgPSBcIltvYmplY3QgU2V0XVwiO1xuZnVuY3Rpb24gR2YoZSkge1xuICByZXR1cm4gcWYoZSkgJiYgQmYoZSkgPT0gWWY7XG59XG52YXIgV2YgPSBHZiwga2YgPSBXZiwgemYgPSBKciwga3QgPSBYciwgenQgPSBrdCAmJiBrdC5pc1NldCwgS2YgPSB6dCA/IHpmKHp0KSA6IGtmLCBIZiA9IEtmLCBWZiA9IGJuLCBKZiA9IHlzLCBYZiA9IG1uLCBaZiA9IG9sLCBRZiA9IEVsLCBlZCA9IHdsLCByZCA9IENsLCB0ZCA9IE5sLCBuZCA9IFhsLCBhZCA9IFBuLCBpZCA9IGx1LCBvZCA9IG1yLCBzZCA9IE11LCBjZCA9IF9mLCBsZCA9IEFmLCB1ZCA9ICRyLCBmZCA9IFZyLCBkZCA9IFVmLCB2ZCA9IFZlLCBwZCA9IEhmLCB5ZCA9IFFyLCBnZCA9IGV0LCBoZCA9IDEsIGJkID0gMiwgJGQgPSA0LCBNbiA9IFwiW29iamVjdCBBcmd1bWVudHNdXCIsIG1kID0gXCJbb2JqZWN0IEFycmF5XVwiLCB4ZCA9IFwiW29iamVjdCBCb29sZWFuXVwiLCBfZCA9IFwiW29iamVjdCBEYXRlXVwiLCBFZCA9IFwiW29iamVjdCBFcnJvcl1cIiwgTG4gPSBcIltvYmplY3QgRnVuY3Rpb25dXCIsIHdkID0gXCJbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXVwiLCBUZCA9IFwiW29iamVjdCBNYXBdXCIsIENkID0gXCJbb2JqZWN0IE51bWJlcl1cIiwgRm4gPSBcIltvYmplY3QgT2JqZWN0XVwiLCBTZCA9IFwiW29iamVjdCBSZWdFeHBdXCIsIFJkID0gXCJbb2JqZWN0IFNldF1cIiwgT2QgPSBcIltvYmplY3QgU3RyaW5nXVwiLCBBZCA9IFwiW29iamVjdCBTeW1ib2xdXCIsIGpkID0gXCJbb2JqZWN0IFdlYWtNYXBdXCIsIFBkID0gXCJbb2JqZWN0IEFycmF5QnVmZmVyXVwiLCBJZCA9IFwiW29iamVjdCBEYXRhVmlld11cIiwgRGQgPSBcIltvYmplY3QgRmxvYXQzMkFycmF5XVwiLCBNZCA9IFwiW29iamVjdCBGbG9hdDY0QXJyYXldXCIsIExkID0gXCJbb2JqZWN0IEludDhBcnJheV1cIiwgRmQgPSBcIltvYmplY3QgSW50MTZBcnJheV1cIiwgTmQgPSBcIltvYmplY3QgSW50MzJBcnJheV1cIiwgVWQgPSBcIltvYmplY3QgVWludDhBcnJheV1cIiwgQmQgPSBcIltvYmplY3QgVWludDhDbGFtcGVkQXJyYXldXCIsIHFkID0gXCJbb2JqZWN0IFVpbnQxNkFycmF5XVwiLCBZZCA9IFwiW29iamVjdCBVaW50MzJBcnJheV1cIiwgeiA9IHt9O1xueltNbl0gPSB6W21kXSA9IHpbUGRdID0geltJZF0gPSB6W3hkXSA9IHpbX2RdID0geltEZF0gPSB6W01kXSA9IHpbTGRdID0geltGZF0gPSB6W05kXSA9IHpbVGRdID0geltDZF0gPSB6W0ZuXSA9IHpbU2RdID0geltSZF0gPSB6W09kXSA9IHpbQWRdID0geltVZF0gPSB6W0JkXSA9IHpbcWRdID0geltZZF0gPSAhMDtcbnpbRWRdID0geltMbl0gPSB6W2pkXSA9ICExO1xuZnVuY3Rpb24gaXIoZSwgciwgdCwgbiwgYywgaSkge1xuICB2YXIgbCwgbyA9IHIgJiBoZCwgcCA9IHIgJiBiZCwgdSA9IHIgJiAkZDtcbiAgaWYgKHQgJiYgKGwgPSBjID8gdChlLCBuLCBjLCBpKSA6IHQoZSkpLCBsICE9PSB2b2lkIDApXG4gICAgcmV0dXJuIGw7XG4gIGlmICghdmQoZSkpXG4gICAgcmV0dXJuIGU7XG4gIHZhciBmID0gdWQoZSk7XG4gIGlmIChmKSB7XG4gICAgaWYgKGwgPSBzZChlKSwgIW8pXG4gICAgICByZXR1cm4gcmQoZSwgbCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGggPSBvZChlKSwgXyA9IGggPT0gTG4gfHwgaCA9PSB3ZDtcbiAgICBpZiAoZmQoZSkpXG4gICAgICByZXR1cm4gZWQoZSwgbyk7XG4gICAgaWYgKGggPT0gRm4gfHwgaCA9PSBNbiB8fCBfICYmICFjKSB7XG4gICAgICBpZiAobCA9IHAgfHwgXyA/IHt9IDogbGQoZSksICFvKVxuICAgICAgICByZXR1cm4gcCA/IG5kKGUsIFFmKGwsIGUpKSA6IHRkKGUsIFpmKGwsIGUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCF6W2hdKVxuICAgICAgICByZXR1cm4gYyA/IGUgOiB7fTtcbiAgICAgIGwgPSBjZChlLCBoLCBvKTtcbiAgICB9XG4gIH1cbiAgaSB8fCAoaSA9IG5ldyBWZigpKTtcbiAgdmFyIE0gPSBpLmdldChlKTtcbiAgaWYgKE0pXG4gICAgcmV0dXJuIE07XG4gIGkuc2V0KGUsIGwpLCBwZChlKSA/IGUuZm9yRWFjaChmdW5jdGlvbihkKSB7XG4gICAgbC5hZGQoaXIoZCwgciwgdCwgZCwgZSwgaSkpO1xuICB9KSA6IGRkKGUpICYmIGUuZm9yRWFjaChmdW5jdGlvbihkLCBZKSB7XG4gICAgbC5zZXQoWSwgaXIoZCwgciwgdCwgWSwgZSwgaSkpO1xuICB9KTtcbiAgdmFyIEYgPSB1ID8gcCA/IGlkIDogYWQgOiBwID8gZ2QgOiB5ZCwgQSA9IGYgPyB2b2lkIDAgOiBGKGUpO1xuICByZXR1cm4gSmYoQSB8fCBlLCBmdW5jdGlvbihkLCBZKSB7XG4gICAgQSAmJiAoWSA9IGQsIGQgPSBlW1ldKSwgWGYobCwgWSwgaXIoZCwgciwgdCwgWSwgZSwgaSkpO1xuICB9KSwgbDtcbn1cbnZhciBHZCA9IGlyLCBXZCA9IEdkLCBrZCA9IDEsIHpkID0gNDtcbmZ1bmN0aW9uIEtkKGUpIHtcbiAgcmV0dXJuIFdkKGUsIGtkIHwgemQpO1xufVxudmFyIEhkID0gS2Q7XG5jb25zdCBLdCA9IC8qIEBfX1BVUkVfXyAqLyBrcihIZCk7XG52YXIgVmQgPSBcIl9fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX19cIjtcbmZ1bmN0aW9uIEpkKGUpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uc2V0KGUsIFZkKSwgdGhpcztcbn1cbnZhciBYZCA9IEpkO1xuZnVuY3Rpb24gWmQoZSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXMoZSk7XG59XG52YXIgUWQgPSBaZCwgZXYgPSBobiwgcnYgPSBYZCwgdHYgPSBRZDtcbmZ1bmN0aW9uIGZyKGUpIHtcbiAgdmFyIHIgPSAtMSwgdCA9IGUgPT0gbnVsbCA/IDAgOiBlLmxlbmd0aDtcbiAgZm9yICh0aGlzLl9fZGF0YV9fID0gbmV3IGV2KCk7ICsrciA8IHQ7IClcbiAgICB0aGlzLmFkZChlW3JdKTtcbn1cbmZyLnByb3RvdHlwZS5hZGQgPSBmci5wcm90b3R5cGUucHVzaCA9IHJ2O1xuZnIucHJvdG90eXBlLmhhcyA9IHR2O1xudmFyIG52ID0gZnI7XG5mdW5jdGlvbiBhdihlLCByKSB7XG4gIGZvciAodmFyIHQgPSAtMSwgbiA9IGUgPT0gbnVsbCA/IDAgOiBlLmxlbmd0aDsgKyt0IDwgbjsgKVxuICAgIGlmIChyKGVbdF0sIHQsIGUpKVxuICAgICAgcmV0dXJuICEwO1xuICByZXR1cm4gITE7XG59XG52YXIgaXYgPSBhdjtcbmZ1bmN0aW9uIG92KGUsIHIpIHtcbiAgcmV0dXJuIGUuaGFzKHIpO1xufVxudmFyIHN2ID0gb3YsIGN2ID0gbnYsIGx2ID0gaXYsIHV2ID0gc3YsIGZ2ID0gMSwgZHYgPSAyO1xuZnVuY3Rpb24gdnYoZSwgciwgdCwgbiwgYywgaSkge1xuICB2YXIgbCA9IHQgJiBmdiwgbyA9IGUubGVuZ3RoLCBwID0gci5sZW5ndGg7XG4gIGlmIChvICE9IHAgJiYgIShsICYmIHAgPiBvKSlcbiAgICByZXR1cm4gITE7XG4gIHZhciB1ID0gaS5nZXQoZSksIGYgPSBpLmdldChyKTtcbiAgaWYgKHUgJiYgZilcbiAgICByZXR1cm4gdSA9PSByICYmIGYgPT0gZTtcbiAgdmFyIGggPSAtMSwgXyA9ICEwLCBNID0gdCAmIGR2ID8gbmV3IGN2KCkgOiB2b2lkIDA7XG4gIGZvciAoaS5zZXQoZSwgciksIGkuc2V0KHIsIGUpOyArK2ggPCBvOyApIHtcbiAgICB2YXIgRiA9IGVbaF0sIEEgPSByW2hdO1xuICAgIGlmIChuKVxuICAgICAgdmFyIGQgPSBsID8gbihBLCBGLCBoLCByLCBlLCBpKSA6IG4oRiwgQSwgaCwgZSwgciwgaSk7XG4gICAgaWYgKGQgIT09IHZvaWQgMCkge1xuICAgICAgaWYgKGQpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgXyA9ICExO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmIChNKSB7XG4gICAgICBpZiAoIWx2KHIsIGZ1bmN0aW9uKFksIFEpIHtcbiAgICAgICAgaWYgKCF1dihNLCBRKSAmJiAoRiA9PT0gWSB8fCBjKEYsIFksIHQsIG4sIGkpKSlcbiAgICAgICAgICByZXR1cm4gTS5wdXNoKFEpO1xuICAgICAgfSkpIHtcbiAgICAgICAgXyA9ICExO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCEoRiA9PT0gQSB8fCBjKEYsIEEsIHQsIG4sIGkpKSkge1xuICAgICAgXyA9ICExO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBpLmRlbGV0ZShlKSwgaS5kZWxldGUociksIF87XG59XG52YXIgTm4gPSB2djtcbmZ1bmN0aW9uIHB2KGUpIHtcbiAgdmFyIHIgPSAtMSwgdCA9IEFycmF5KGUuc2l6ZSk7XG4gIHJldHVybiBlLmZvckVhY2goZnVuY3Rpb24obiwgYykge1xuICAgIHRbKytyXSA9IFtjLCBuXTtcbiAgfSksIHQ7XG59XG52YXIgeXYgPSBwdjtcbmZ1bmN0aW9uIGd2KGUpIHtcbiAgdmFyIHIgPSAtMSwgdCA9IEFycmF5KGUuc2l6ZSk7XG4gIHJldHVybiBlLmZvckVhY2goZnVuY3Rpb24obikge1xuICAgIHRbKytyXSA9IG47XG4gIH0pLCB0O1xufVxudmFyIGh2ID0gZ3YsIEh0ID0gcHIsIFZ0ID0gRG4sIGJ2ID0gS3IsICR2ID0gTm4sIG12ID0geXYsIHh2ID0gaHYsIF92ID0gMSwgRXYgPSAyLCB3diA9IFwiW29iamVjdCBCb29sZWFuXVwiLCBUdiA9IFwiW29iamVjdCBEYXRlXVwiLCBDdiA9IFwiW29iamVjdCBFcnJvcl1cIiwgU3YgPSBcIltvYmplY3QgTWFwXVwiLCBSdiA9IFwiW29iamVjdCBOdW1iZXJdXCIsIE92ID0gXCJbb2JqZWN0IFJlZ0V4cF1cIiwgQXYgPSBcIltvYmplY3QgU2V0XVwiLCBqdiA9IFwiW29iamVjdCBTdHJpbmddXCIsIFB2ID0gXCJbb2JqZWN0IFN5bWJvbF1cIiwgSXYgPSBcIltvYmplY3QgQXJyYXlCdWZmZXJdXCIsIER2ID0gXCJbb2JqZWN0IERhdGFWaWV3XVwiLCBKdCA9IEh0ID8gSHQucHJvdG90eXBlIDogdm9pZCAwLCBEciA9IEp0ID8gSnQudmFsdWVPZiA6IHZvaWQgMDtcbmZ1bmN0aW9uIE12KGUsIHIsIHQsIG4sIGMsIGksIGwpIHtcbiAgc3dpdGNoICh0KSB7XG4gICAgY2FzZSBEdjpcbiAgICAgIGlmIChlLmJ5dGVMZW5ndGggIT0gci5ieXRlTGVuZ3RoIHx8IGUuYnl0ZU9mZnNldCAhPSByLmJ5dGVPZmZzZXQpXG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIGUgPSBlLmJ1ZmZlciwgciA9IHIuYnVmZmVyO1xuICAgIGNhc2UgSXY6XG4gICAgICByZXR1cm4gIShlLmJ5dGVMZW5ndGggIT0gci5ieXRlTGVuZ3RoIHx8ICFpKG5ldyBWdChlKSwgbmV3IFZ0KHIpKSk7XG4gICAgY2FzZSB3djpcbiAgICBjYXNlIFR2OlxuICAgIGNhc2UgUnY6XG4gICAgICByZXR1cm4gYnYoK2UsICtyKTtcbiAgICBjYXNlIEN2OlxuICAgICAgcmV0dXJuIGUubmFtZSA9PSByLm5hbWUgJiYgZS5tZXNzYWdlID09IHIubWVzc2FnZTtcbiAgICBjYXNlIE92OlxuICAgIGNhc2UganY6XG4gICAgICByZXR1cm4gZSA9PSByICsgXCJcIjtcbiAgICBjYXNlIFN2OlxuICAgICAgdmFyIG8gPSBtdjtcbiAgICBjYXNlIEF2OlxuICAgICAgdmFyIHAgPSBuICYgX3Y7XG4gICAgICBpZiAobyB8fCAobyA9IHh2KSwgZS5zaXplICE9IHIuc2l6ZSAmJiAhcClcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgdmFyIHUgPSBsLmdldChlKTtcbiAgICAgIGlmICh1KVxuICAgICAgICByZXR1cm4gdSA9PSByO1xuICAgICAgbiB8PSBFdiwgbC5zZXQoZSwgcik7XG4gICAgICB2YXIgZiA9ICR2KG8oZSksIG8ociksIG4sIGMsIGksIGwpO1xuICAgICAgcmV0dXJuIGwuZGVsZXRlKGUpLCBmO1xuICAgIGNhc2UgUHY6XG4gICAgICBpZiAoRHIpXG4gICAgICAgIHJldHVybiBEci5jYWxsKGUpID09IERyLmNhbGwocik7XG4gIH1cbiAgcmV0dXJuICExO1xufVxudmFyIEx2ID0gTXYsIFh0ID0gUG4sIEZ2ID0gMSwgTnYgPSBPYmplY3QucHJvdG90eXBlLCBVdiA9IE52Lmhhc093blByb3BlcnR5O1xuZnVuY3Rpb24gQnYoZSwgciwgdCwgbiwgYywgaSkge1xuICB2YXIgbCA9IHQgJiBGdiwgbyA9IFh0KGUpLCBwID0gby5sZW5ndGgsIHUgPSBYdChyKSwgZiA9IHUubGVuZ3RoO1xuICBpZiAocCAhPSBmICYmICFsKVxuICAgIHJldHVybiAhMTtcbiAgZm9yICh2YXIgaCA9IHA7IGgtLTsgKSB7XG4gICAgdmFyIF8gPSBvW2hdO1xuICAgIGlmICghKGwgPyBfIGluIHIgOiBVdi5jYWxsKHIsIF8pKSlcbiAgICAgIHJldHVybiAhMTtcbiAgfVxuICB2YXIgTSA9IGkuZ2V0KGUpLCBGID0gaS5nZXQocik7XG4gIGlmIChNICYmIEYpXG4gICAgcmV0dXJuIE0gPT0gciAmJiBGID09IGU7XG4gIHZhciBBID0gITA7XG4gIGkuc2V0KGUsIHIpLCBpLnNldChyLCBlKTtcbiAgZm9yICh2YXIgZCA9IGw7ICsraCA8IHA7ICkge1xuICAgIF8gPSBvW2hdO1xuICAgIHZhciBZID0gZVtfXSwgUSA9IHJbX107XG4gICAgaWYgKG4pXG4gICAgICB2YXIgdyA9IGwgPyBuKFEsIFksIF8sIHIsIGUsIGkpIDogbihZLCBRLCBfLCBlLCByLCBpKTtcbiAgICBpZiAoISh3ID09PSB2b2lkIDAgPyBZID09PSBRIHx8IGMoWSwgUSwgdCwgbiwgaSkgOiB3KSkge1xuICAgICAgQSA9ICExO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGQgfHwgKGQgPSBfID09IFwiY29uc3RydWN0b3JcIik7XG4gIH1cbiAgaWYgKEEgJiYgIWQpIHtcbiAgICB2YXIgTiA9IGUuY29uc3RydWN0b3IsIHkgPSByLmNvbnN0cnVjdG9yO1xuICAgIE4gIT0geSAmJiBcImNvbnN0cnVjdG9yXCIgaW4gZSAmJiBcImNvbnN0cnVjdG9yXCIgaW4gciAmJiAhKHR5cGVvZiBOID09IFwiZnVuY3Rpb25cIiAmJiBOIGluc3RhbmNlb2YgTiAmJiB0eXBlb2YgeSA9PSBcImZ1bmN0aW9uXCIgJiYgeSBpbnN0YW5jZW9mIHkpICYmIChBID0gITEpO1xuICB9XG4gIHJldHVybiBpLmRlbGV0ZShlKSwgaS5kZWxldGUociksIEE7XG59XG52YXIgcXYgPSBCdiwgTXIgPSBibiwgWXYgPSBObiwgR3YgPSBMdiwgV3YgPSBxdiwgWnQgPSBtciwgUXQgPSAkciwgZW4gPSBWciwga3YgPSBFbiwgenYgPSAxLCBybiA9IFwiW29iamVjdCBBcmd1bWVudHNdXCIsIHRuID0gXCJbb2JqZWN0IEFycmF5XVwiLCBuciA9IFwiW29iamVjdCBPYmplY3RdXCIsIEt2ID0gT2JqZWN0LnByb3RvdHlwZSwgbm4gPSBLdi5oYXNPd25Qcm9wZXJ0eTtcbmZ1bmN0aW9uIEh2KGUsIHIsIHQsIG4sIGMsIGkpIHtcbiAgdmFyIGwgPSBRdChlKSwgbyA9IFF0KHIpLCBwID0gbCA/IHRuIDogWnQoZSksIHUgPSBvID8gdG4gOiBadChyKTtcbiAgcCA9IHAgPT0gcm4gPyBuciA6IHAsIHUgPSB1ID09IHJuID8gbnIgOiB1O1xuICB2YXIgZiA9IHAgPT0gbnIsIGggPSB1ID09IG5yLCBfID0gcCA9PSB1O1xuICBpZiAoXyAmJiBlbihlKSkge1xuICAgIGlmICghZW4ocikpXG4gICAgICByZXR1cm4gITE7XG4gICAgbCA9ICEwLCBmID0gITE7XG4gIH1cbiAgaWYgKF8gJiYgIWYpXG4gICAgcmV0dXJuIGkgfHwgKGkgPSBuZXcgTXIoKSksIGwgfHwga3YoZSkgPyBZdihlLCByLCB0LCBuLCBjLCBpKSA6IEd2KGUsIHIsIHAsIHQsIG4sIGMsIGkpO1xuICBpZiAoISh0ICYgenYpKSB7XG4gICAgdmFyIE0gPSBmICYmIG5uLmNhbGwoZSwgXCJfX3dyYXBwZWRfX1wiKSwgRiA9IGggJiYgbm4uY2FsbChyLCBcIl9fd3JhcHBlZF9fXCIpO1xuICAgIGlmIChNIHx8IEYpIHtcbiAgICAgIHZhciBBID0gTSA/IGUudmFsdWUoKSA6IGUsIGQgPSBGID8gci52YWx1ZSgpIDogcjtcbiAgICAgIHJldHVybiBpIHx8IChpID0gbmV3IE1yKCkpLCBjKEEsIGQsIHQsIG4sIGkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gXyA/IChpIHx8IChpID0gbmV3IE1yKCkpLCBXdihlLCByLCB0LCBuLCBjLCBpKSkgOiAhMTtcbn1cbnZhciBWdiA9IEh2LCBKdiA9IFZ2LCBhbiA9IEJlO1xuZnVuY3Rpb24gVW4oZSwgciwgdCwgbiwgYykge1xuICByZXR1cm4gZSA9PT0gciA/ICEwIDogZSA9PSBudWxsIHx8IHIgPT0gbnVsbCB8fCAhYW4oZSkgJiYgIWFuKHIpID8gZSAhPT0gZSAmJiByICE9PSByIDogSnYoZSwgciwgdCwgbiwgVW4sIGMpO1xufVxudmFyIFh2ID0gVW4sIFp2ID0gWHY7XG5mdW5jdGlvbiBRdihlLCByKSB7XG4gIHJldHVybiBadihlLCByKTtcbn1cbnZhciBlcCA9IFF2O1xuY29uc3QgcnAgPSAvKiBAX19QVVJFX18gKi8ga3IoZXApO1xuZnVuY3Rpb24gY3AoZSkge1xuICBjb25zdCByID0gSGUobnVsbCk7XG4gIHJldHVybiBzcigoKSA9PiB7XG4gICAgKGFzeW5jICgpID0+IGNvbnNvbGUubG9nKFwiVGVzdFJlZi5jdXJycmVudFwiLCByLmN1cnJlbnQpKSgpO1xuICB9LCBbXSksIC8qIEBfX1BVUkVfXyAqLyBqLmpzeChcImRpdlwiLCB7IHJlZjogciwgY2hpbGRyZW46IFwidGVzdCBjb21wb25lbnRcIiB9KTtcbn1cbmZ1bmN0aW9uIHRwKCkge1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGouanN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInNwbGFzaFwiLCBzdHlsZToge1xuICAgIGZvbnRTaXplOiBcIjM2cHhcIixcbiAgICBib3JkZXI6IFwiMTBweCBzb2xpZCAjMDk2MGE1XCIsXG4gICAgd2lkdGg6IFwiMTAwJVwiLFxuICAgIGhlaWdodDogXCIxMDAlXCIsXG4gICAgbWFyZ2luOiAwLFxuICAgIHBhZGRpbmc6IDAsXG4gICAgYm94U2l6aW5nOiBcImJvcmRlci1ib3hcIixcbiAgICBvdmVyZmxvdzogXCJoaWRkZW5cIixcbiAgICBkaXNwbGF5OiBcImZsZXhcIixcbiAgICBmbGV4RGlyZWN0aW9uOiBcImNvbHVtblwiLFxuICAgIGZsZXg6IDEsXG4gICAganVzdGlmeUNvbnRlbnQ6IFwiY2VudGVyXCIsXG4gICAgYWxpZ25JdGVtczogXCJjZW50ZXJcIlxuICB9LCBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGouanN4KFwiaW1nXCIsIHsgc3R5bGU6IHsgaGVpZ2h0OiA1MDAsIHdpZHRoOiAxZTMgfSwgc3JjOiBcIi4vUmVFeHQvUmVFeHQucG5nXCIgfSkgfSk7XG59XG5mdW5jdGlvbiBscCh7IGNoaWxkcmVuOiBlLCBSZUV4dERhdGE6IHIsIHNwbGFzaDogdCwgZmlsbDogbiB9KSB7XG4gIHIgPT09IHZvaWQgMCAmJiAociA9IHtcbiAgICBzZGt2ZXJzaW9uOiBcIjcuOC4wXCIsXG4gICAgdG9vbGtpdDogXCJjbGFzc2ljXCIsXG4gICAgdGhlbWU6IFwiY2xhc3NpY1wiLFxuICAgIHBhY2thZ2VzOiB7XG4gICAgICBjaGFydHM6ICExLFxuICAgICAgZm9udGF3ZXNvbWU6ICExLFxuICAgICAgdXg6ICExLFxuICAgICAgY2FsZW5kYXI6ICExLFxuICAgICAgZDM6ICExLFxuICAgICAgZXhwb3J0ZXI6ICExLFxuICAgICAgcGl2b3Q6ICExLFxuICAgICAgcGl2b3RkMzogITEsXG4gICAgICBwaXZvdGxvY2FsZTogITEsXG4gICAgICBmcm9hbGFlZGl0b3I6ICExXG4gICAgfSxcbiAgICBkZWJ1ZzogITEsXG4gICAgbGljZW5zZTogXCJiMTE2ZTMyZS0wODQ3LTQ3NjQtOTRlZi1hMTY5ODcwNzA0MDlcIixcbiAgICB1cmw6IFwiZGVmYXVsdFwiXG4gIH0pO1xuICBjb25zdCBbYywgaV0gPSBEZSghMSk7XG4gIHJldHVybiBuICE9PSB2b2lkIDAgJiYgYXAoKSwgc3IoKCkgPT4ge1xuICAgIChhc3luYyAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBCbihyKSwgaSghMCk7XG4gICAgICB9IGNhdGNoIChvKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJmYWlsXCIsIG8pO1xuICAgICAgfVxuICAgIH0pKCk7XG4gIH0sIFtdKSwgYyA/IC8qIEBfX1BVUkVfXyAqLyBqLmpzeChqLkZyYWdtZW50LCB7IGNoaWxkcmVuOiBlIH0pIDogdCA9PT0gITAgPyAvKiBAX19QVVJFX18gKi8gai5qc3godHAsIHt9KSA6IG51bGw7XG59XG5mdW5jdGlvbiBucChlKSB7XG4gIGNvbnN0IFtyLCB0XSA9IERlKG51bGwpLCBbbl0gPSBEZSghMCksIFtjLCBpXSA9IERlKG51bGwpO1xuICB2YXIgbCA9IEhlKCk7XG4gIGwuY3VycmVudCA9IGM7XG4gIGNvbnN0IG8gPSAoKSA9PiBsLmN1cnJlbnQsIFtwLCB1XSA9IERlKG51bGwpO1xuICB2YXIgZiA9IEhlKCk7XG4gIGYuY3VycmVudCA9IHA7XG4gIGNvbnN0IGggPSAoKSA9PiBmLmN1cnJlbnQsIF8gPSBIZShudWxsKTtcbiAgd2luZG93LkV4dCA9PT0gdm9pZCAwICYmIHdpbmRvdy5SZUV4dExvYWQgPT09IHZvaWQgMCAmJiAod2luZG93LlJlRXh0TG9hZCA9ICEwLCBCbigpKTtcbiAgY29uc3QgTSA9IG5ldyBSZXNpemVPYnNlcnZlcigoZykgPT4ge1xuICAgIGZvciAoY29uc3QgcyBvZiBnKSB7XG4gICAgICB2YXIgRTtcbiAgICAgIHdpbmRvdy5FeHQuUmVFeHRMID09PSAhMCA/IEUgPSBzLnRhcmdldC5jaGlsZHJlbi5sZW5ndGggLSAxIDogRSA9IHMudGFyZ2V0LmNoaWxkcmVuLmxlbmd0aCAtIDI7XG4gICAgICB2YXIgeCA9IHMudGFyZ2V0LmNoaWxkcmVuLml0ZW0oRSk7XG4gICAgICBpZiAoeCAhPT0gbnVsbCAmJiBzLmNvbnRlbnRCb3hTaXplKSB7XG4gICAgICAgIGNvbnN0IHYgPSBzLmNvbnRlbnRCb3hTaXplWzBdO1xuICAgICAgICB2YXIgVCA9IHYuaW5saW5lU2l6ZSwgbSA9IHdpbmRvdy5FeHQuZ2V0Q21wKHguaWQpO1xuICAgICAgICBpZiAobSAhPT0gdm9pZCAwKVxuICAgICAgICAgIHdpbmRvdy5FeHQuZ2V0Q21wKHguaWQpLnNldFdpZHRoKFQpLCB3aW5kb3cuRXh0LmdldENtcCh4LmlkKS5zZXRIZWlnaHQodi5ibG9ja1NpemUpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB2YXIgTCA9IHguZ2V0QXR0cmlidXRlKFwid1wiKTtcbiAgICAgICAgICBMICE9PSBcIndcIiAmJiBjb25zb2xlLmxvZyhcImNoaWxkIG5vdCByZXNpemVkXCIsIHgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgc3IoKCkgPT4ge1xuICAgIHZhciBnLCBFID0gXCJmYWxzZVwiO1xuICAgIHJldHVybiAoYXN5bmMgKCkgPT4ge1xuICAgICAgYXdhaXQgTigpLCBlLmNoaWxkcmVuICE9PSB2b2lkIDAgJiYgZS5jb25maWcuaXRlbXMgPT09IHZvaWQgMCAmJiAoZS5jb25maWcuaXRlbXMgPSBbXSk7XG4gICAgICB2YXIgeCA9IDFlNDtcbiAgICAgIGlmIChFID09PSBcImZhbHNlXCIgJiYgZS54dHlwZSAhPT0gXCJsb2dvXCIgJiYgZS54dHlwZSAhPT0gXCJsb2dvc21hbGxcIiAmJiBlLnh0eXBlICE9PSBcImxvYWRlclwiKSB7XG4gICAgICAgIHZhciBUO1xuICAgICAgICBoKCkgPT0gbnVsbCA/IFQgPSBlLmNvbmZpZyA6IFQgPSBoKCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIG0gPSBBKGUueHR5cGUsIFQsIGUpLCBMID0gRXh0LkNsYXNzTWFuYWdlci5nZXRCeUFsaWFzKFwid2lkZ2V0LlwiICsgbS54dHlwZSk7XG4gICAgICAgICAgaWYgKEwgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgdmFyIHMgPSBtLnh0eXBlICsgXCIgY291bGQgbm90IGJlIGNyZWF0ZWRcIjtcbiAgICAgICAgICAgIG0gPSB7IHh0eXBlOiBcImJ1dHRvblwiLCBkaXNhYmxlZDogITAsIHRleHQ6IHMsIHN0eWxlOiB7IGZvbnRTaXplOiBcIjM2cHhcIiwgY29sb3I6IFwicmVkXCIgfSB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobS5oZWlnaHQgPT09IHZvaWQgMCAmJiAod2luZG93LkV4dC5pc0NsYXNzaWMgPT09ICEwICYmIG0ueHR5cGUgPT09IFwiZ3JpZFwiID8gbS5oZWlnaHQgPSAwIDogbS5oZWlnaHQgPSBcIjEwMCVcIiksIG0ud2lkdGggPT09IHZvaWQgMCAmJiAod2luZG93LkV4dC5pc0NsYXNzaWMgPT09ICEwICYmIG0ueHR5cGUgPT09IFwiZ3JpZFwiID8gbS53aWR0aCA9IDAgOiBtLndpZHRoID0gXCIxMDAlXCIpLCB3aW5kb3cuRXh0LmlzQ2xhc3NpYyA9PT0gITApIHtcbiAgICAgICAgICAgIGNvbnN0IHYgPSAoQykgPT4ge1xuICAgICAgICAgICAgICB2YXIgTyA9IEMuZWwuZG9tLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgIE0ub2JzZXJ2ZShPKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBtLmxpc3RlbmVycyA9PT0gdm9pZCAwID8gbS5saXN0ZW5lcnMgPSB7IGJveHJlYWR5OiB2IH0gOiBtLmxpc3RlbmVycy5ib3hyZWFkeSA9IHY7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChZKHgpKSB7XG4gICAgICAgICAgICBhbGVydChcIlJlRXh0IHRyaWFsIGxpbWl0OlwiICsgeCArIFwiIGNvbXBvbmVudHNcIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIG0ucmVuZGVyVG8gPSBfLmN1cnJlbnQsIGcgPSB3aW5kb3cuRXh0LmNyZWF0ZShtKSwgaShnKSwgbC5jdXJyZW50ID0gZywgZS5jb25maWcgIT09IHZvaWQgMCAmJiBlLmNvbmZpZy5yZWZlcmVuY2UgIT09IHZvaWQgMCAmJiBlLlJlRXh0UGFyZW50ICE9PSB2b2lkIDAgJiYgKGUuUmVFeHRQYXJlbnQuUmVFeHRDaGlsZHJlbiA9PT0gdm9pZCAwICYmIChlLlJlRXh0UGFyZW50LlJlRXh0Q2hpbGRyZW4gPSBbXSksIGUuUmVFeHRQYXJlbnQuUmVFeHRDaGlsZHJlbi5wdXNoKGcpKSwgXy5jdXJyZW50ID09PSBudWxsID8gY29uc29sZS5sb2coXCJSZUV4dFJvb3RSZWYuY3VycmVudCxwcm9wc1wiLCBfLmN1cnJlbnQsIGUpIDogKF8uY3VycmVudC5zdHlsZS5iYWNrZ3JvdW5kID0gXCJ0cmFuc3BhcmVudFwiLCBfLmN1cnJlbnQuZmlyc3RDaGlsZC5yZW1vdmUoKSksIGQoZS5jaGlsZHJlbiwgZyksIHkoZywgXCJSZUV4dCBcIiArIG0ueHR5cGUsIF8uY3VycmVudCksIGUucmVhZHkgIT09IHZvaWQgMCAmJiBlLnJlYWR5KGcpO1xuICAgICAgICB9IGNhdGNoICh2KSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcih2KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pKCksICgpID0+IHtcbiAgICAgIEUgPSBcInRydWVcIiwgd2luZG93LkV4dCAhPT0gdm9pZCAwICYmIHdpbmRvdy5FeHQuZGVzdHJveSAhPT0gdm9pZCAwICYmIGcgIT0gbnVsbCAmJiAod2luZG93LkV4dC5SZUV4dENvdW50ID0gd2luZG93LkV4dC5SZUV4dENvdW50IC0gMSwgaShudWxsKSwgd2luZG93LkV4dC5kZXN0cm95KGcpKTtcbiAgICB9O1xuICB9LCBbXSk7XG4gIGNvbnN0IEYgPSAoZywgRSwgeCkgPT4ge1xuICAgIHZhciBUID0gKEwpID0+IHtcbiAgICAgIGNvbnN0IHYgPSBMLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpLCBDID0gTC5zbGljZSgxKTtcbiAgICAgIHZhciBSID0gXCJzZXRcIiArICh2ICsgQyk7XG4gICAgICByZXR1cm4gUjtcbiAgICB9LCBtO1xuICAgIHdpbmRvdy5FeHQuaXNDbGFzc2ljID09PSAhMCA/IEUgPT09IFwiaXRlbXNcIiA/IChnLnJlbW92ZUFsbCghMCksIGcuYWRkKHgpKSA6IEUgIT09IFwibGF5b3V0XCIgJiYgKG0gPSBUKEUpLCBnW21dICE9PSB2b2lkIDAgPyBnW21dKHgpIDogZ1tFXSA9IHgpIDogKG0gPSBUKEUpLCBnW21dICE9PSB2b2lkIDAgJiYgZ1ttXSh4KSk7XG4gIH07XG4gIHNyKCgpID0+IHtcbiAgICBpZiAoZS5jb25maWcgIT09IHZvaWQgMCkge1xuICAgICAgaWYgKGwuY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgICBlLmNoaWxkcmVuICE9PSB2b2lkIDAgJiYgZS5jb25maWcuaXRlbXMgPT09IHZvaWQgMCAmJiAoZS5jb25maWcuaXRlbXMgPSBbXSk7XG4gICAgICAgIGZvciAoY29uc3QgW0xdIG9mIE9iamVjdC5lbnRyaWVzKGYuY3VycmVudCkpIHtcbiAgICAgICAgICBpZiAoUShMKSAhPSBudWxsIHx8IEwgPT09IFwieHR5cGVcIilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB2YXIgZyA9IEt0KGYuY3VycmVudFtMXSksIEUgPSBLdChlLmNvbmZpZ1tMXSk7XG4gICAgICAgICAgZyAhPSBudWxsICYmIGRlbGV0ZSBnLmxpc3RlbmVycywgRSAhPT0gdm9pZCAwICYmIGcgIT09IG51bGwgJiYgZGVsZXRlIEUubGlzdGVuZXJzO1xuICAgICAgICAgIGNvbnN0IHMgPSAodikgPT4ge1xuICAgICAgICAgICAgbGV0IEMgPSBbXSwgTyA9IEpTT04uc3RyaW5naWZ5KHYsIGZ1bmN0aW9uKFIsIFApIHtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBQID09IFwib2JqZWN0XCIgJiYgUCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChDLmluZGV4T2YoUCkgIT09IC0xKVxuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIEMucHVzaChQKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gUDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIEMgPSBudWxsLCBPO1xuICAgICAgICAgIH07XG4gICAgICAgICAgdmFyIHggPSBzKGcpLCBUID0gcyhFKSwgbSA9IHJwKHgsIFQpO1xuICAgICAgICAgIG0gfHwgKEYobC5jdXJyZW50LCBMLCBFKSwgTCA9PT0gXCJpdGVtc1wiICYmIGQoZS5jaGlsZHJlbiwgbC5jdXJyZW50KSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHUoZS5jb25maWcpLCBmLmN1cnJlbnQgPSBlLmNvbmZpZztcbiAgICB9XG4gIH0sIFtlLmNvbmZpZ10pO1xuICBjb25zdCBBID0gKGcsIEUsIHgpID0+IHtcbiAgICB2YXIgVCA9IHt9O1xuICAgIGlmIChULnh0eXBlID0gZywgRSAhPT0gdm9pZCAwKVxuICAgICAgZm9yIChjb25zdCBbTCwgc10gb2YgT2JqZWN0LmVudHJpZXMoRSkpXG4gICAgICAgIFRbTF0gPSBzO1xuICAgIGlmICh4LnJlZmVyZW5jZXMgPT09ICEwICYmIChULmNvbnRyb2xsZXIgPSB3aW5kb3cuRXh0LmNyZWF0ZShcIkV4dC5hcHAuVmlld0NvbnRyb2xsZXJcIikpLCBULnN0b3JlICE9PSB2b2lkIDAgJiYgKFQuc3RvcmUubGlzdGVuZXJzICE9PSB2b2lkIDAgPyBULnN0b3JlLmxpc3RlbmVycy5sb2FkID09PSB2b2lkIDAgJiYgKFQuc3RvcmUubGlzdGVuZXJzLmxvYWQgPSAoTCkgPT4ge1xuICAgICAgeC5zdG9yZWxvYWRlZCAhPT0gdm9pZCAwICYmIHguc3RvcmVsb2FkZWQoTCwgbygpKTtcbiAgICB9KSA6IFQuc3RvcmUubGlzdGVuZXJzID0ge1xuICAgICAgbG9hZDogKEwpID0+IHtcbiAgICAgICAgeC5zdG9yZWxvYWRlZCAhPT0gdm9pZCAwICYmIHguc3RvcmVsb2FkZWQoTCwgbygpKTtcbiAgICAgIH1cbiAgICB9KSwgVC5saXN0ZW5lcnMgPT09IHZvaWQgMCkge1xuICAgICAgVC5saXN0ZW5lcnMgPSB7fTtcbiAgICAgIGZvciAoY29uc3QgW0wsIHNdIG9mIE9iamVjdC5lbnRyaWVzKHgpKSB7XG4gICAgICAgIHZhciBtID0gUShMKTtcbiAgICAgICAgbSAhPT0gbnVsbCAmJiAoVC5saXN0ZW5lcnNbbV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICBzKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgT2JqZWN0LmtleXMoVC5saXN0ZW5lcnMpLmxlbmd0aCA9PT0gMCAmJiBkZWxldGUgVC5saXN0ZW5lcnM7XG4gICAgfVxuICAgIHJldHVybiBUO1xuICB9LCBkID0gKGcsIEUpID0+IHtcbiAgICB2YXIgeCA9IFtdLCBUID0gW107XG4gICAgaWYgKGcgIT09IHZvaWQgMCkge1xuICAgICAgZS5jaGlsZHJlbi5sZW5ndGggPT09IHZvaWQgMCA/IFQucHVzaChnKSA6IFQgPSBnO1xuICAgICAgdHJ5IHtcbiAgICAgICAgVC5tYXAoKG0pID0+IHtcbiAgICAgICAgICB2YXIgTCwgcztcbiAgICAgICAgICBpZiAoRS54dHlwZSA9PT0gXCJ0YWJwYW5lbFwiKSB7XG4gICAgICAgICAgICB2YXIgdjtcbiAgICAgICAgICAgIHdpbmRvdy5FeHQuUmVFeHRUaGVtZSA9PT0gXCJjbGFzc2ljXCIgPyB2ID0gXCJFeHQucGFuZWwuUGFuZWxcIiA6IHYgPSBcIkV4dC5QYW5lbFwiLCBMID0gd2luZG93LkV4dC5jcmVhdGUodiwge1xuICAgICAgICAgICAgICBsYXlvdXQ6IFwiZml0XCIsXG4gICAgICAgICAgICAgIHRpdGxlOiBtLnByb3BzLnRpdGxlLFxuICAgICAgICAgICAgICBjbHM6IFwiUmVFeHRUYWJDaGlsZFJvb3RcIixcbiAgICAgICAgICAgICAgaXRlbXM6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICB4dHlwZTogXCJjb21wb25lbnRcIixcbiAgICAgICAgICAgICAgICAgIGxpc3RlbmVyczoge1xuICAgICAgICAgICAgICAgICAgICBib3hyZWFkeTogKFIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICBzID0gZXIobSwgUi5lbC5kb20pLCB4LnB1c2gocyk7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIFAgPSBSLmVsLmRvbS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgICAgICAgIE0ub2JzZXJ2ZShQKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIHN0eWxlOiB7IGJhY2tncm91bmRDb2xvcjogXCJ0cmFuc3BhcmVudFwiLCBkaXNwbGF5OiBcImZsZXhcIiwgaGVpZ2h0OiBcIjEwMCVcIiwgd2lkdGg6IFwiMTAwJVwiIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH0pLCB5KEwsIFwiUmVFeHQgdGFiIGNoaWxkXCIsIG51bGwpLCBFLmFkZChMKSwgd2luZG93LkV4dC5pc0NsYXNzaWMgPT09ICEwID8gQyA9IFwiRXh0LmNvbnRhaW5lci5Db250YWluZXJcIiA6IEMgPSBcIkV4dC5Db250YWluZXJcIiwgd2luZG93LkV4dC5pc0NsYXNzaWMgIT09ICEwICYmIChzID0gZXIobSwgTC5pdGVtcy5pdGVtc1swXS5lbC5kb20pLCB4LnB1c2gocykpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgQztcbiAgICAgICAgICAgIHdpbmRvdy5FeHQuaXNDbGFzc2ljID09PSAhMCA/IEMgPSBcIkV4dC5jb250YWluZXIuQ29udGFpbmVyXCIgOiBDID0gXCJFeHQuQ29udGFpbmVyXCIsIEwgPSB3aW5kb3cuRXh0LmNyZWF0ZShDLCB7XG4gICAgICAgICAgICAgIGNsczogXCJSZUV4dFdpZGdldFJvb3RcIlxuICAgICAgICAgICAgICAvL3N0eWxlOntiYWNrZ3JvdW5kOid5ZWxsb3cnLGJvcmRlcjonNXB4IHNvbGlkIHJlZCd9XG4gICAgICAgICAgICB9KSwgRS5hZGQoTCk7XG4gICAgICAgICAgICB2YXIgTyA9IG9hKG0sIHsgUmVFeHRQYXJlbnQ6IEUgfSk7XG4gICAgICAgICAgICB3aW5kb3cuRXh0LmlzQ2xhc3NpYyA9PT0gITAgPyBzID0gZXIoTywgTC5lbC5kb20pIDogcyA9IGVyKE8sIEwuaW5uZXJFbGVtZW50LmRvbSksIHgucHVzaChzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pLCB0KHgpO1xuICAgICAgfSBjYXRjaCAobSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiaXRlcmF0ZU92ZXJDaGlsZHJlbjpcIiwgbS50b1N0cmluZygpKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIGZ1bmN0aW9uIFkoZykge1xuICAgIHJldHVybiB3aW5kb3cuRXh0LlJlRXh0Q291bnQgPT09IHZvaWQgMCA/IHdpbmRvdy5FeHQuUmVFeHRDb3VudCA9IDEgOiB3aW5kb3cuRXh0LlJlRXh0Q291bnQgPSB3aW5kb3cuRXh0LlJlRXh0Q291bnQgKyAxLCB3aW5kb3cuRXh0LlJlRXh0Q291bnQgPiBnO1xuICB9XG4gIHZhciBRID0gKGcpID0+IHtcbiAgICB2YXIgRSA9IG51bGwsIHggPSBnLnNsaWNlKDAsIDIpO1xuICAgIGlmICh4ID09PSBcIm9uXCIpIHtcbiAgICAgIHZhciBUID0gZy5jaGFyQXQoMiksIG0gPSBnLmNoYXJBdCgyKS50b1VwcGVyQ2FzZSgpO1xuICAgICAgVCA9PT0gbSAmJiAoRSA9IGcuc2xpY2UoMikudG9Mb3dlckNhc2UoKSk7XG4gICAgfVxuICAgIHJldHVybiB3aW5kb3cuRXh0LmlzQ2xhc3NpYyA9PT0gITAgJiYgRSA9PT0gXCJ0YXBcIiAmJiAoRSA9IFwiY2xpY2tcIiksIEU7XG4gIH07XG4gIGZ1bmN0aW9uIHcoZykge1xuICAgIGxldCBFID0gMiwgeCA9IFwiXCI7XG4gICAgZm9yIChsZXQgbSA9IGcubGVuZ3RoIC0gRTsgbSA+PSBFOyBtLS0pXG4gICAgICB4ICs9IGdbbV07XG4gICAgdmFyIFQgPSBnWzFdICsgZ1swXSArIHg7XG4gICAgcmV0dXJuIFQ7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gTigpIHtcbiAgICByZXR1cm4gYXdhaXQgbmV3IFByb21pc2UoKHgpID0+IHtcbiAgICAgIGZ1bmN0aW9uIFQoKSB7XG4gICAgICAgIHdpbmRvdy5FeHQgIT09IHZvaWQgMCAmJiB3aW5kb3cuRXh0Lm9uUmVhZHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIGNsZWFySW50ZXJ2YWwobSksIHgoMSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdmFyIG0gPSBzZXRJbnRlcnZhbChULCA1KTtcbiAgICB9KTtcbiAgfVxuICBjb25zdCB5ID0gKGcsIEUsIHgpID0+IHtcbiAgICBpZiAoeCA9PT0gbnVsbCB8fCB3aW5kb3cuRXh0LlJlRXh0TCA9PT0gITAgfHwgbiA9PT0gITEpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgVCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksIG0gPSBkb2N1bWVudC5jcmVhdGVBdHRyaWJ1dGUoXCJ3XCIpO1xuICAgIG0udmFsdWUgPSBcIndcIiwgVC5zZXRBdHRyaWJ1dGVOb2RlKG0pO1xuICAgIGNvbnN0IEwgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShFKTtcbiAgICBULmFwcGVuZENoaWxkKEwpO1xuICAgIHZhciBzO1xuICAgIHggIT09IG51bGwgPyBzID0geC5hcHBlbmRDaGlsZChUKSA6IGcuZWwgIT09IHZvaWQgMCAmJiAocyA9IGcuZWwuZG9tLmFwcGVuZENoaWxkKFQpKSwgdmUocyk7XG4gIH07XG4gIGZ1bmN0aW9uIHZlKGcpIHtcbiAgICB2YXIgRSA9IHcoXCJ0c2VseXhcIik7XG4gICAgZ1tFXVt3KFwiaWR5YWxwc3hcIildID0gdyhcImxia2NveFwiKSwgZ1tFXVt3KFwib2ZlemlTdG54XCIpXSA9IHcoXCJwOHh4XCIpLCBnW0VdW3coXCJvYnJlZHJ4XCIpXSA9IHcoXCJwMXlhcmd0aGdpbCBkaWxvcyB4eFwiKSwgZ1tFXVt3KFwib2ZlbHl0U3RueFwiKV0gPSB3KFwidGljaWxheFwiKSwgZ1tFXVt3KFwiYXBnbmlkZHhcIildID0gdyhcInA0eHhcIiksIGdbRV1bdyhcImFiZG51b3Jna2N4XCIpXSA9IHcoXCJFI0NERkZDeFwiKSwgZ1tFXVt3KFwib2Nyb2x4XCIpXSA9IHcoXCJsYmtjYXhcIiksIGdbRV1bdyhcInBveXRpY2F4XCIpXSA9IHcoXCJwMXh4XCIpLCBnW0VdW3coXCJJenhlZG54XCIpXSA9IHcoXCIwMTAwMHhcIiksIGdbRV1bdyhcIm9ibW90dHhcIildID0gdyhcInAweHhcIiksIGdbRV1bdyhcIm9wbm9pdGlzeFwiKV0gPSB3KFwiYmFldHVsb3N4XCIpLCBnW0VdW3coXCJpcnRoZ3hcIildID0gdyhcInAweHhcIiksIGdbRV1bdyhcImlsdGhnaWVoLWVueFwiKV0gPSB3KFwicDF4eFwiKTtcbiAgfVxuICB2YXIgcGUgPSBcIlwiLCBtZSA9IFwiXCIsIHllID0gXCJcIiwgeGUgPSBcIlwiO1xuICBpZiAod2luZG93LkV4dCAhPT0gdm9pZCAwICYmIHdpbmRvdy5FeHQudmVyc2lvbnMgIT09IG51bGwpIHtcbiAgICBtZSA9IHdpbmRvdy5FeHQudmVyc2lvbnMuY29yZS52ZXJzaW9uLCB4ZSA9IHdpbmRvdy5FeHQuUmVFeHRUaGVtZSwgd2luZG93LkV4dC5SZUV4dFVybCA9PT0gXCJcIiA/IHBlID0gXCJsb2NhbFwiIDogcGUgPSBcInJlbW90ZVwiO1xuICAgIHZhciBfZSA9IHdpbmRvdy5FeHQuaXNDbGFzc2ljO1xuICAgIF9lID09PSAhMCA/IHllID0gXCJjbGFzc2ljXCIgOiB5ZSA9IFwibW9kZXJuXCI7XG4gIH1cbiAgaWYgKGUueHR5cGUgPT09IFwibG9nb1wiKVxuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gai5qc3hzKFxuICAgICAgXCJkaXZcIixcbiAgICAgIHtcbiAgICAgICAgbmFtZTogXCJSZUV4dFJvb3RMb2dvXCIsXG4gICAgICAgIFwiZGF0YS1yaWRcIjogZS5yaWQsXG4gICAgICAgIGNsYXNzTmFtZTogXCJjZW50ZXJcIixcbiAgICAgICAgc3R5bGU6IHsgYm9yZGVyQm90dG9tOiBcIjFweCBzb2xpZCBncmF5XCIsIGRpc3BsYXk6IFwiZmxleFwiLCBoZWlnaHQ6IFwiODBweFwiLCBjb2xvcjogXCJibGFja1wiLCBwYWRkaW5nOiAxMCwgLi4uZS5zdHlsZSB9LFxuICAgICAgICBjaGlsZHJlbjogW1xuICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyBqLmpzeChcImltZ1wiLCB7IHN0eWxlOiB7IGhlaWdodDogODAsIHdpZHRoOiA4OCB9LCBzcmM6IFwiLi9SZUV4dC9SZUV4dC5wbmdcIiB9KSxcbiAgICAgICAgICAvKiBAX19QVVJFX18gKi8gai5qc3hzKFwiZGl2XCIsIHsgc3R5bGU6IHsgbWFyZ2luOiA1IH0sIGNoaWxkcmVuOiBbXG4gICAgICAgICAgICAvKiBAX19QVVJFX18gKi8gai5qc3hzKFwiZGl2XCIsIHsgc3R5bGU6IHsgbWFyZ2luOiBcIjAgMCAwIDFweFwiLCBmb250U2l6ZTogMjYgfSwgY2hpbGRyZW46IFtcbiAgICAgICAgICAgICAgLyogQF9fUFVSRV9fICovIGouanN4KFwiaVwiLCB7IGNoaWxkcmVuOiBcIlJlYWN0IFJlRXh0XCIgfSksXG4gICAgICAgICAgICAgIFwiIC0gUmVhY3QgQ29tcG9uZW50cyBmb3IgRXh0SlNcIlxuICAgICAgICAgICAgXSB9KSxcbiAgICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyBqLmpzeChcImRpdlwiLCB7IHN0eWxlOiB7IG1hcmdpbjogXCIwIDAgMCAxcHhcIiwgZm9udFNpemU6IDE4LCBjb2xvcjogXCJibGFja1wiIH0sIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gai5qc3goXCJhXCIsIHsgdGFyZ2V0OiBcIl9ibGFua1wiLCByZWw6IFwibm9yZWZlcnJlclwiLCBocmVmOiBcImh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL0BndXNtYW5vL3JlZXh0XCIsIGNoaWxkcmVuOiBcImh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL0BndXNtYW5vL3JlZXh0XCIgfSkgfSksXG4gICAgICAgICAgICAvKiBAX19QVVJFX18gKi8gai5qc3hzKFwiZGl2XCIsIHsgc3R5bGU6IHsgZm9udFNpemU6IFwiMTJweFwiLCBtYXJnaW46IFwiNXB4IDAgMCAwXCIgfSwgY2hpbGRyZW46IFtcbiAgICAgICAgICAgICAgLyogQF9fUFVSRV9fICovIGouanN4cyhcInNwYW5cIiwgeyBzdHlsZTogeyBtYXJnaW46IFwiMCAwIDAgMFwiIH0sIGNoaWxkcmVuOiBbXG4gICAgICAgICAgICAgICAgXCJSZUV4dDogXCIsXG4gICAgICAgICAgICAgICAgLyogQF9fUFVSRV9fICovIGouanN4KFwiYlwiLCB7IGNoaWxkcmVuOiBcIjAuMC4zMzlcIiB9KVxuICAgICAgICAgICAgICBdIH0pLFxuICAgICAgICAgICAgICAvKiBAX19QVVJFX18gKi8gai5qc3hzKFwic3BhblwiLCB7IHN0eWxlOiB7IG1hcmdpbjogXCIwIDAgMCAxMHB4XCIgfSwgY2hpbGRyZW46IFtcbiAgICAgICAgICAgICAgICBcIlJlYWN0OiBcIixcbiAgICAgICAgICAgICAgICAvKiBAX19QVVJFX18gKi8gai5qc3goXCJiXCIsIHsgY2hpbGRyZW46IG9yLnZlcnNpb24gfSlcbiAgICAgICAgICAgICAgXSB9KSxcbiAgICAgICAgICAgICAgLyogQF9fUFVSRV9fICovIGouanN4cyhcInNwYW5cIiwgeyBzdHlsZTogeyBtYXJnaW46IFwiMCAwIDAgMTBweFwiIH0sIGNoaWxkcmVuOiBbXG4gICAgICAgICAgICAgICAgXCJFeHRKUzogXCIsXG4gICAgICAgICAgICAgICAgLyogQF9fUFVSRV9fICovIGouanN4cyhcImJcIiwgeyBjaGlsZHJlbjogW1xuICAgICAgICAgICAgICAgICAgbWUsXG4gICAgICAgICAgICAgICAgICBcIiAoXCIsXG4gICAgICAgICAgICAgICAgICBwZSxcbiAgICAgICAgICAgICAgICAgIFwiKVwiXG4gICAgICAgICAgICAgICAgXSB9KVxuICAgICAgICAgICAgICBdIH0pLFxuICAgICAgICAgICAgICAvKiBAX19QVVJFX18gKi8gai5qc3hzKFwic3BhblwiLCB7IHN0eWxlOiB7IG1hcmdpbjogXCIwIDAgMCAxMHB4XCIgfSwgY2hpbGRyZW46IFtcbiAgICAgICAgICAgICAgICBcInRvb2xraXQ6IFwiLFxuICAgICAgICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyBqLmpzeChcImJcIiwgeyBjaGlsZHJlbjogeWUgfSlcbiAgICAgICAgICAgICAgXSB9KSxcbiAgICAgICAgICAgICAgLyogQF9fUFVSRV9fICovIGouanN4cyhcInNwYW5cIiwgeyBzdHlsZTogeyBtYXJnaW46IFwiMCAwIDAgMTBweFwiIH0sIGNoaWxkcmVuOiBbXG4gICAgICAgICAgICAgICAgXCJ0aGVtZTogXCIsXG4gICAgICAgICAgICAgICAgLyogQF9fUFVSRV9fICovIGouanN4KFwiYlwiLCB7IGNoaWxkcmVuOiB4ZSB9KVxuICAgICAgICAgICAgICBdIH0pXG4gICAgICAgICAgICBdIH0pXG4gICAgICAgICAgXSB9KVxuICAgICAgICBdXG4gICAgICB9XG4gICAgKTtcbiAgaWYgKGUueHR5cGUgPT09IFwibG9nb3NtYWxsXCIpXG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqLmpzeHMoXG4gICAgICBcImRpdlwiLFxuICAgICAge1xuICAgICAgICBuYW1lOiBcIlJlRXh0Um9vdExvZ29cIixcbiAgICAgICAgXCJkYXRhLXJpZFwiOiBlLnJpZCxcbiAgICAgICAgY2xhc3NOYW1lOiBcImNlbnRlclwiLFxuICAgICAgICBzdHlsZTogeyBib3JkZXJCb3R0b206IFwiMHB4IHNvbGlkIGdyYXlcIiwgZGlzcGxheTogXCJmbGV4XCIsIGhlaWdodDogXCI0NnB4XCIsIGNvbG9yOiBcImJsYWNrXCIsIHBhZGRpbmc6IDUsIC4uLmUuc3R5bGUgfSxcbiAgICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgICAvKiBAX19QVVJFX18gKi8gai5qc3goXCJpbWdcIiwgeyBzdHlsZTogeyBoZWlnaHQ6IDQwLCB3aWR0aDogODAgfSwgc3JjOiBcIi4vUmVFeHQvUmVFeHQucG5nXCIgfSksXG4gICAgICAgICAgLyogQF9fUFVSRV9fICovIGouanN4cyhcImRpdlwiLCB7IHN0eWxlOiB7IG1hcmdpbjogXCIwIDAgMCAzcHhcIiB9LCBjaGlsZHJlbjogW1xuICAgICAgICAgICAgLyogQF9fUFVSRV9fICovIGouanN4KFwiZGl2XCIsIHsgc3R5bGU6IHsgbWFyZ2luOiBcIjAgMCAwIDFweFwiLCBmb250U2l6ZTogMTIsIGNvbG9yOiBcImJsYWNrXCIgfSwgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqLmpzeChcImFcIiwgeyBzdHlsZTogZS5zdHlsZSwgdGFyZ2V0OiBcIl9ibGFua1wiLCByZWw6IFwibm9yZWZlcnJlclwiLCBocmVmOiBcImh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL0BndXNtYW5vL3JlZXh0XCIsIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gai5qc3goXCJpXCIsIHsgY2hpbGRyZW46IFwiUmVhY3QgUmVFeHRcIiB9KSB9KSB9KSxcbiAgICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyBqLmpzeHMoXCJkaXZcIiwgeyBzdHlsZTogeyBmb250U2l6ZTogXCIxMHB4XCIsIG1hcmdpbjogXCIycHggMCAwIDBcIiB9LCBjaGlsZHJlbjogW1xuICAgICAgICAgICAgICAvKiBAX19QVVJFX18gKi8gai5qc3hzKFwic3BhblwiLCB7IHN0eWxlOiB7IG1hcmdpbjogXCIwIDAgMCAwXCIgfSwgY2hpbGRyZW46IFtcbiAgICAgICAgICAgICAgICBcIlJlRXh0OiBcIixcbiAgICAgICAgICAgICAgICAvKiBAX19QVVJFX18gKi8gai5qc3goXCJiXCIsIHsgY2hpbGRyZW46IFwiMC4wLjMzOVwiIH0pXG4gICAgICAgICAgICAgIF0gfSksXG4gICAgICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyBqLmpzeHMoXCJzcGFuXCIsIHsgc3R5bGU6IHsgbWFyZ2luOiBcIjAgMCAwIDVweFwiIH0sIGNoaWxkcmVuOiBbXG4gICAgICAgICAgICAgICAgXCJSZWFjdDogXCIsXG4gICAgICAgICAgICAgICAgLyogQF9fUFVSRV9fICovIGouanN4KFwiYlwiLCB7IGNoaWxkcmVuOiBvci52ZXJzaW9uIH0pXG4gICAgICAgICAgICAgIF0gfSlcbiAgICAgICAgICAgIF0gfSksXG4gICAgICAgICAgICAvKiBAX19QVVJFX18gKi8gai5qc3goXCJkaXZcIiwgeyBzdHlsZTogeyBmb250U2l6ZTogXCIxMHB4XCIsIG1hcmdpbjogXCIycHggMCAwIDBcIiB9LCBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGouanN4cyhcInNwYW5cIiwgeyBzdHlsZTogeyBtYXJnaW46IFwiMCAwIDAgMFwiIH0sIGNoaWxkcmVuOiBbXG4gICAgICAgICAgICAgIFwiRXh0SlM6IFwiLFxuICAgICAgICAgICAgICAvKiBAX19QVVJFX18gKi8gai5qc3hzKFwiYlwiLCB7IGNoaWxkcmVuOiBbXG4gICAgICAgICAgICAgICAgbWUsXG4gICAgICAgICAgICAgICAgXCIgKFwiLFxuICAgICAgICAgICAgICAgIHBlLFxuICAgICAgICAgICAgICAgIFwiKVwiXG4gICAgICAgICAgICAgIF0gfSlcbiAgICAgICAgICAgIF0gfSkgfSksXG4gICAgICAgICAgICAvKiBAX19QVVJFX18gKi8gai5qc3hzKFwiZGl2XCIsIHsgc3R5bGU6IHsgZm9udFNpemU6IFwiMTBweFwiLCBtYXJnaW46IFwiMnB4IDAgMCAwXCIgfSwgY2hpbGRyZW46IFtcbiAgICAgICAgICAgICAgLyogQF9fUFVSRV9fICovIGouanN4cyhcInNwYW5cIiwgeyBzdHlsZTogeyBtYXJnaW46IFwiMCAwIDAgMFwiIH0sIGNoaWxkcmVuOiBbXG4gICAgICAgICAgICAgICAgXCJ0b29sa2l0OiBcIixcbiAgICAgICAgICAgICAgICAvKiBAX19QVVJFX18gKi8gai5qc3goXCJiXCIsIHsgY2hpbGRyZW46IHllIH0pXG4gICAgICAgICAgICAgIF0gfSksXG4gICAgICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyBqLmpzeHMoXCJzcGFuXCIsIHsgc3R5bGU6IHsgbWFyZ2luOiBcIjAgMCAwIDNweFwiIH0sIGNoaWxkcmVuOiBbXG4gICAgICAgICAgICAgICAgXCJ0aGVtZTogXCIsXG4gICAgICAgICAgICAgICAgLyogQF9fUFVSRV9fICovIGouanN4KFwiYlwiLCB7IGNoaWxkcmVuOiB4ZSB9KVxuICAgICAgICAgICAgICBdIH0pXG4gICAgICAgICAgICBdIH0pXG4gICAgICAgICAgXSB9KVxuICAgICAgICBdXG4gICAgICB9XG4gICAgKTtcbiAgdmFyIGdlO1xuICBlLnN0eWxlID09PSB2b2lkIDAgfHwgZS5zdHlsZS5oZWlnaHQgPT09IHZvaWQgMCA/IGdlID0gMSA6IGdlID0gXCJub25lXCI7XG4gIHZhciBUZSA9IFwiXCI7XG4gIHJldHVybiBlLmNsYXNzTmFtZSAhPT0gdm9pZCAwICYmIChUZSA9IGUuY2xhc3NOYW1lKSwgLyogQF9fUFVSRV9fICovIGouanN4cyhcbiAgICBcImRpdlwiLFxuICAgIHtcbiAgICAgIG5hbWU6IFwiUmVFeHRSb290LVwiICsgZS54dHlwZSxcbiAgICAgIFwiZGF0YS1yaWRcIjogZS5yaWQsXG4gICAgICBjbGFzc05hbWU6IFRlICsgXCIgZmlsbFwiLFxuICAgICAgc3R5bGU6IHsgLi4uZS5zdHlsZSwgZmxleDogZ2UsIHBvc2l0aW9uOiBcInJlbGF0aXZlXCIsIGJhY2tncm91bmQ6IFwid2hpdGVcIiwgZGlzcGxheTogXCJmbGV4XCIgfSxcbiAgICAgIHJlZjogXyxcbiAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgIC8qIEBfX1BVUkVfXyAqLyBqLmpzeChcImRpdlwiLCB7IHN0eWxlOiB7IGRpc3BsYXk6IFwiZmxleFwiLCBmbGV4OiAxLCBhbGlnbkl0ZW1zOiBcImNlbnRlclwiLCBqdXN0aWZ5Q29udGVudDogXCJjZW50ZXJcIiwgYmFja2dyb3VuZDogXCIjRjhGOEY4XCIgfSB9KSxcbiAgICAgICAgciAhPT0gbnVsbCAmJiByLm1hcCgoZykgPT4gZylcbiAgICAgIF1cbiAgICB9XG4gICk7XG59XG5ucC5wcm9wVHlwZXMgPSB7XG4gIGNsYXNzTmFtZTogemUuc3RyaW5nLFxuICBzdHlsZTogemUub2JqZWN0LFxuICB4dHlwZTogemUuc3RyaW5nLFxuICBjb25maWc6IHplLm9iamVjdCxcbiAgcmVhZHk6IHplLmZ1bmNcbn07XG5hc3luYyBmdW5jdGlvbiBhcCgpIHtcbiAgZnVuY3Rpb24gZShyKSB7XG4gICAgci5zdHlsZS53aWR0aCA9IFwiMTAwJVwiLCByLnN0eWxlLmhlaWdodCA9IFwiMTAwJVwiLCByLnN0eWxlLm1hcmdpbiA9IFwiMFwiLCByLnN0eWxlLnBhZGRpbmcgPSBcIjBcIiwgci5zdHlsZS5wYWRkaW5nID0gXCIwXCIsIHIuc3R5bGUuYm94U2l6aW5nID0gXCJib3JkZXItYm94XCIsIHIuc3R5bGUub3ZlcmZsb3cgPSBcImhpZGRlblwiO1xuICB9XG4gIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiBlKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCksIGRvY3VtZW50LmJvZHkgJiYgZShkb2N1bWVudC5ib2R5KSwgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJyb290XCIpICYmIGUoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJyb290XCIpKTtcbn1cbmNvbnN0IHVwID0gKGUpID0+IHtcbiAgY29uc3QgW3IsIHRdID0gRGUoZSk7XG4gIHZhciBuID0gSGUoKTtcbiAgcmV0dXJuIG4uY3VycmVudCA9IHIsIFsoKSA9PiBuLmN1cnJlbnQsIHRdO1xufTtcbmZ1bmN0aW9uIGZwKGUpIHtcbiAgZm9yICh2YXIgciwgdCA9IGUuZ2V0Q29udHJvbGxlcigpLCBuID0gZTsgdCA9PT0gdm9pZCAwOyApXG4gICAgdCA9IGUucGFyZW50LmdldENvbnRyb2xsZXIoKSwgbiA9IGUucGFyZW50O1xuICBpZiAociA9IHQuZ2V0UmVmZXJlbmNlcygpLCByID09PSBudWxsICYmIChyID0ge30pLCBuLlJlRXh0Q2hpbGRyZW4gIT09IHZvaWQgMClcbiAgICBmb3IgKHZhciBjID0gMDsgYyA8IG4uUmVFeHRDaGlsZHJlbi5sZW5ndGg7IGMrKylcbiAgICAgIG4uUmVFeHRDaGlsZHJlbltjXS5yZWZlcmVuY2UgIT09IG51bGwgJiYgKHJbbi5SZUV4dENoaWxkcmVuW2NdLnJlZmVyZW5jZV0gPSBuLlJlRXh0Q2hpbGRyZW5bY10pO1xuICByZXR1cm4gcjtcbn1cbmNvbnN0IGRlID0gYXN5bmMgKGUpID0+IGF3YWl0IG5ldyBQcm9taXNlKChuLCBjKSA9PiB7XG4gIGxldCBpID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJIRUFEXCIpWzBdO1xuICB2YXIgbCA9ICExO1xuICBmb3IgKGxldCBvID0gMDsgbyA8IGkuY2hpbGROb2Rlcy5sZW5ndGg7IG8rKylcbiAgICBpLmNoaWxkTm9kZXNbb10uc3JjID09PSBlICYmIChsID0gITApO1xuICBpZiAobCA9PT0gITEpIHtcbiAgICBjb25zdCBvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtcbiAgICBvLmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsICgpID0+IG4oMSkpLCBvLmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCAoKSA9PiB7XG4gICAgICB2YXIgcCA9IGAke2V9IGNvdWxkIG5vdCBiZSBsb2FkZWQgLSBjb3B5IHRoZSBub2RlX21vZHVsZXMvQGd1c21hbm8vcmVleHQvZXh0IGZvbGRlciB0byB0aGUgcHJvamVjdCdzIHB1YmxpYyBmb2xkZXJgO1xuICAgICAgY29uc29sZS5lcnJvcihwKSwgYyhwKTtcbiAgICB9KSwgby5zcmMgPSBlLCBpLmFwcGVuZENoaWxkKG8pO1xuICB9XG59KSwgSyA9IGFzeW5jIChlKSA9PiBhd2FpdCBuZXcgUHJvbWlzZSgobiwgYykgPT4ge1xuICBsZXQgaSA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiSEVBRFwiKVswXSwgbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIpO1xuICBsLnJlbCA9IFwic3R5bGVzaGVldFwiLCBsLnR5cGUgPSBcInRleHQvY3NzXCIsIGwuaHJlZiA9IGUsIGwuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsICgpID0+IHtcbiAgICB2YXIgbyA9IGAke2V9IGNvdWxkIG5vdCBiZSBsb2FkZWQgLSBjb3B5IHRoZSBub2RlX21vZHVsZXMvQGd1c21hbm8vcmVleHQvZXh0IGZvbGRlciB0byB0aGUgcHJvamVjdCdzIHB1YmxpYyBmb2xkZXJgO1xuICAgIHJldHVybiBjb25zb2xlLmVycm9yKG8pLCBjKG8pO1xuICB9KSwgbC5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCAoKSA9PiBuKDEpKSwgaS5hcHBlbmRDaGlsZChsKTtcbn0pLCBvbiA9IGFzeW5jIChlLCByLCB0KSA9PiBhd2FpdCBuZXcgUHJvbWlzZSgoaSkgPT4ge1xuICB3aW5kb3cuRXh0Lm9uUmVhZHkoZnVuY3Rpb24oKSB7XG4gICAgd2luZG93LkV4dC5SZUV4dFVybCA9IHQsIHdpbmRvdy5FeHQuUmVFeHRUaGVtZSA9IGU7XG4gICAgdmFyIGwgPSByLnN1YnN0cihyLmxlbmd0aCAtIDQpO1xuICAgIHJldHVybiBbLi4ubF0ucmV2ZXJzZSgpLmpvaW4oXCJcIikgPT09IFwiNzA0MFwiID8gd2luZG93LkV4dC5SZUV4dEwgPSAhMCA6IHdpbmRvdy5FeHQuUmVFeHRMID0gITEsIGkoMSk7XG4gIH0pO1xufSksIGlwID0gYXN5bmMgKGUpID0+IGF3YWl0IG5ldyBQcm9taXNlKChuLCBjKSA9PiB7XG4gIGxldCBpID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJIRUFEXCIpWzBdO1xuICBjb25zdCBsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtcbiAgbC5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCAoKSA9PiBuKDEpKSwgbC5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgKCkgPT4ge1xuICAgIHZhciBvID0gYCR7ZX0gY291bGQgbm90IGJlIGxvYWRlZGA7XG4gICAgY29uc29sZS5lcnJvcihvKSwgYyhvKTtcbiAgfSksIGwuc3JjID0gZSwgaS5hcHBlbmRDaGlsZChsKTtcbn0pO1xuYXN5bmMgZnVuY3Rpb24gQm4oZSkge1xuICB2YXIgciA9IGUuc2RrdmVyc2lvbiwgdCA9IGUudG9vbGtpdCwgbiA9IGUudGhlbWUsIGMgPSBlLnBhY2thZ2VzLCBpID0gZS5kZWJ1ZywgbCA9IGUubGljZW5zZSwgbyA9IGUudXJsO1xuICAobiA9PSBudWxsIHx8IG4gPT09IFwiXCIpICYmIChuID0gXCJtYXRlcmlhbFwiKSwgKHQgPT0gbnVsbCB8fCB0ID09PSBcIlwiKSAmJiAodCA9IFwibW9kZXJuXCIpO1xuICB2YXIgcDtcbiAgc3dpdGNoIChyKSB7XG4gICAgY2FzZSBcIjcuMC4wXCI6XG4gICAgICBwID0gciArIFwiLjE1NlwiLCByID0gciArIFwiLjE1NlwiO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIjcuMS4wXCI6XG4gICAgICBwID0gciArIFwiLjQ2XCIsIHIgPSByICsgXCIuNDZcIjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCI3LjguMFwiOlxuICAgICAgcCA9IHIgKyBcIi4zM1wiLCByID0gciArIFwiLjMzXCI7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiNy4yLjBcIjpcbiAgICBjYXNlIFwiNy4zLjBcIjpcbiAgICBjYXNlIFwiNy4zLjFcIjpcbiAgICBjYXNlIFwiNy40LjBcIjpcbiAgICBjYXNlIFwiNy41LjBcIjpcbiAgICBjYXNlIFwiNy41LjFcIjpcbiAgICBjYXNlIFwiNy42LjBcIjpcbiAgICBjYXNlIFwiNy43LjBcIjpcbiAgICAgIHAgPSByO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IGBTREsgdmVyc2lvbiAke3J9IGlzIG5vdCB2YWxpZGA7XG4gIH1cbiAgKG8gPT09IFwiZGVmYXVsdFwiIHx8IG8gPT09IG51bGwpICYmIChvID0gXCJodHRwOi8vbWFyY2d1c21hbm8uY29tL1JlRXh0L1wiKSwgKG8gPT09IFwibG9jYWxcIiB8fCBvID09PSBcIlwiKSAmJiAobyA9IFwiXCIpO1xuICB2YXIgdSA9IG8gKyBcImV4dC1cIiArIHIsIGYgPSBvICsgXCJleHQtYWRkb25zLVwiICsgcDtcbiAgaSA9PT0gITAgPyBpID0gXCItZGVidWdcIiA6IGkgPSBcIlwiO1xuICB2YXIgaCA9IFwiXCI7XG4gIHQgPT09IFwibW9kZXJuXCIgJiYgKGggPSBcIi1tb2Rlcm5cIik7XG4gIHZhciBfID0gW1wiaW9zXCIsIFwibWF0ZXJpYWxcIiwgXCJuZXB0dW5lXCIsIFwidHJpdG9uXCJdO1xuICBpZiAodCA9PT0gXCJtb2Rlcm5cIiAmJiAhXy5pbmNsdWRlcyhuKSlcbiAgICB0aHJvdyBgJHtufSB0aGVtZSBpcyBub3QgaW4gJHt0fSB0b29sa2l0IGZvciBTREsgdmVyc2lvbiAke3J9YDtcbiAgdmFyIE0gPSBbXCJjbGFzc2ljXCIsIFwiY3Jpc3BcIiwgXCJncmFwaGl0ZVwiLCBcImdyYXlcIiwgXCJtYXRlcmlhbFwiLCBcIm5lcHR1bmVcIiwgXCJ0cml0b25cIl07XG4gIGlmICh0ID09PSBcImNsYXNzaWNcIiAmJiAhTS5pbmNsdWRlcyhuKSlcbiAgICB0aHJvdyBgJHtufSB0aGVtZSBpcyBub3QgaW4gJHt0fSB0b29sa2l0IGZvciBTREsgdmVyc2lvbiAke3J9YDtcbiAgdmFyIEYgPSAhMTtcbiAgaWYgKChjLmNhbGVuZGFyID09PSAhMCB8fCBjLmQzID09PSAhMCB8fCBjLmV4cG9ydGVyID09PSAhMCB8fCBjLnBpdm90ID09PSAhMCB8fCBjLnBpdm90ZDMgPT09ICEwIHx8IGMucGl2b3Rsb2NhbGUgPT09ICEwIHx8IGMuZnJvYWxhZWRpdG9yID09PSAhMCkgJiYgKEYgPSAhMCksIGUuZGVidWcgPT09ICEwICYmIGF3YWl0IGlwKFwibm9kZV9tb2R1bGVzL0BndXNtYW5vL3JlZXh0L2Rpc3QvZXhhbXBsZS9kZWJ1Zy5qc1wiKSwgdSA9IHUgKyBcIi9idWlsZFwiLCByLnNsaWNlKC0xKSA9PT0gXCJjXCIpIHtcbiAgICBhd2FpdCBkZShgJHt1fS9leHQtJHtyfS10b29sa2l0LSR7dH0tc2RrLmpzYCksIGF3YWl0IEsoYCR7dX0vZXh0LSR7cn0tdGhlbWUtJHtufS1zZGsuY3NzYCksIEYgPT09ICEwICYmIChhd2FpdCBkZShgJHt1fS9leHQtJHtyfS10b29sa2l0LSR7dH0tYWRkb25zLmpzYCksIGF3YWl0IEsoYCR7dX0vZXh0LSR7cn0tdGhlbWUtJHtufS1hZGRvbnMuY3NzYCkpLCBhd2FpdCBvbihuLCBsLCBvKTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGF3YWl0IGRlKGAke3V9L2V4dCR7aH0tYWxsJHtpfS5qc2ApLCBhd2FpdCBLKGAke3V9LyR7dH0vdGhlbWUtJHtufS9yZXNvdXJjZXMvdGhlbWUtJHtufS1hbGwuY3NzYCksIGMuZm9udGF3ZXNvbWUgPT09ICEwICYmIGF3YWl0IEsoYCR7dX0vcGFja2FnZXMvZm9udC1hd2Vzb21lL3Jlc291cmNlcy9mb250LWF3ZXNvbWUtYWxsJHtpfS5jc3NgKSwgYy51eCA9PT0gITAgJiYgKGF3YWl0IGRlKGAke3V9L3BhY2thZ2VzL3V4LyR7dH0vdXgke2l9LmpzYCksIHIgPT09IFwiNy4wLjBcIiAmJiB0ID09PSBcIm1vZGVyblwiICYmIG4gPT09IFwibmVwdHVuZVwiICYmIGF3YWl0IEsoYCR7dX0vcGFja2FnZXMvdXgvJHt0fS8ke3R9LSR7bn0vcmVzb3VyY2VzL3V4LWFsbCR7aX0uY3NzYCksIHIgPT09IFwiNy4wLjBcIiAmJiB0ID09PSBcImNsYXNzaWNcIiAmJiBhd2FpdCBLKGAke3V9L3BhY2thZ2VzL3V4LyR7dH0vJHtufS9yZXNvdXJjZXMvdXgtYWxsJHtpfS5jc3NgKSwgciAhPT0gXCI3LjAuMFwiICYmIHQgPT09IFwiY2xhc3NpY1wiICYmIG4gPT09IFwibWF0ZXJpYWxcIiAmJiBhd2FpdCBLKGAke3V9L3BhY2thZ2VzL3V4LyR7dH0vJHt0fS0ke259L3Jlc291cmNlcy91eC1hbGwke2l9LmNzc2ApLCByICE9PSBcIjcuMC4wXCIgJiYgdCA9PT0gXCJjbGFzc2ljXCIgJiYgbiAhPT0gXCJtYXRlcmlhbFwiICYmIG4gIT09IFwiZ3JheVwiICYmIGF3YWl0IEsoYCR7dX0vcGFja2FnZXMvdXgvJHt0fS8ke259L3Jlc291cmNlcy91eC1hbGwke2l9LmNzc2ApKSwgYy5jaGFydHMgPT09ICEwKSB7XG4gICAgYXdhaXQgZGUoYCR7dX0vcGFja2FnZXMvY2hhcnRzLyR7dH0vY2hhcnRzJHtpfS5qc2ApO1xuICAgIHZhciBBID0gITA7XG4gICAgKHQgPT09IFwibW9kZXJuXCIgJiYgbiA9PT0gXCJpb3NcIiAmJiByID09PSBcIjcuMC4wXCIgfHwgbiA9PT0gXCJncmF5XCIpICYmIChBID0gITEpLCBBID09PSAhMCAmJiAodCA9PT0gXCJjbGFzc2ljXCIgJiYgbiAhPT0gXCJtYXRlcmlhbFwiID8gYXdhaXQgSyhgJHt1fS9wYWNrYWdlcy9jaGFydHMvJHt0fS8ke259L3Jlc291cmNlcy9jaGFydHMtYWxsJHtpfS5jc3NgKSA6IGF3YWl0IEsoYCR7dX0vcGFja2FnZXMvY2hhcnRzLyR7dH0vJHt0fS0ke259L3Jlc291cmNlcy9jaGFydHMtYWxsJHtpfS5jc3NgKSk7XG4gIH1cbiAgaWYgKEYgPT09ICEwKSB7XG4gICAgdmFyIGQ7XG4gICAgZiA9IGYgKyBcIi9wYWNrYWdlc1wiLCBjLmNhbGVuZGFyID09PSAhMCAmJiAoZCA9IFwiY2FsZW5kYXJcIiwgYXdhaXQgZGUoYCR7Zn0vJHtkfS9idWlsZC8ke3R9LyR7ZH0ke2l9LmpzYCksIHQgPT09IFwibW9kZXJuXCIgJiYgbiA9PT0gXCJpb3NcIiB8fCBwID09PSBcIjcuMC4wLjE1NlwiID8gYXdhaXQgSyhgJHtmfS8ke2R9L2J1aWxkLyR7dH0vJHtufS9yZXNvdXJjZXMvJHtkfS1hbGwke2l9LmNzc2ApIDogbiAhPT0gXCJncmF5XCIgJiYgbiAhPT0gXCJncmFwaGl0ZVwiICYmICh0ID09PSBcImNsYXNzaWNcIiAmJiBuICE9PSBcIm1hdGVyaWFsXCIgPyBhd2FpdCBLKGAke2Z9LyR7ZH0vYnVpbGQvJHt0fS8ke259L3Jlc291cmNlcy8ke2R9LWFsbCR7aX0uY3NzYCkgOiBhd2FpdCBLKGAke2Z9LyR7ZH0vYnVpbGQvJHt0fS8ke3R9LSR7bn0vcmVzb3VyY2VzLyR7ZH0tYWxsJHtpfS5jc3NgKSkpLCBjLmQzID09PSAhMCAmJiAoZCA9IFwiZDNcIiwgYXdhaXQgZGUoYCR7Zn0vJHtkfS9idWlsZC8ke3R9LyR7ZH0ke2l9LmpzYCksIHQgPT09IFwibW9kZXJuXCIgJiYgKG4gPT09IFwiaW9zXCIgfHwgbiA9PT0gXCJtYXRlcmlhbFwiKSA/IGF3YWl0IEsoYCR7Zn0vJHtkfS9idWlsZC8ke3R9LyR7bn0vcmVzb3VyY2VzLyR7ZH0tYWxsJHtpfS5jc3NgKSA6IG4gIT09IFwiZ3JheVwiICYmIG4gIT09IFwiZ3JhcGhpdGVcIiAmJiAodCA9PT0gXCJjbGFzc2ljXCIgJiYgbiAhPT0gXCJtYXRlcmlhbFwiID8gYXdhaXQgSyhgJHtmfS8ke2R9L2J1aWxkLyR7dH0vJHtufS9yZXNvdXJjZXMvJHtkfS1hbGwke2l9LmNzc2ApIDogYXdhaXQgSyhgJHtmfS8ke2R9L2J1aWxkLyR7dH0vJHt0fS0ke259L3Jlc291cmNlcy8ke2R9LWFsbCR7aX0uY3NzYCkpKSwgYy5leHBvcnRlciA9PT0gITAgJiYgKGQgPSBcImV4cG9ydGVyXCIsIGF3YWl0IGRlKGAke2Z9LyR7ZH0vYnVpbGQvJHt0fS8ke2R9JHtpfS5qc2ApLCBhd2FpdCBLKGAke2Z9LyR7ZH0vYnVpbGQvJHt0fS9yZXNvdXJjZXMvJHtkfS1hbGwke2l9LmNzc2ApKSwgYy5waXZvdCA9PT0gITAgJiYgKGQgPSBcInBpdm90XCIsIGF3YWl0IGRlKGAke2Z9LyR7ZH0vYnVpbGQvJHt0fS8ke2R9JHtpfS5qc2ApLCB0ID09PSBcIm1vZGVyblwiICYmIChuID09PSBcImlvc1wiIHx8IG4gPT09IFwibWF0ZXJpYWxcIikgPyBhd2FpdCBLKGAke2Z9LyR7ZH0vYnVpbGQvJHt0fS8ke259L3Jlc291cmNlcy8ke2R9LWFsbCR7aX0uY3NzYCkgOiBuICE9PSBcImdyYXlcIiAmJiBuICE9PSBcImdyYXBoaXRlXCIgJiYgKHQgPT09IFwiY2xhc3NpY1wiICYmIG4gIT09IFwibWF0ZXJpYWxcIiA/IGF3YWl0IEsoYCR7Zn0vJHtkfS9idWlsZC8ke3R9LyR7bn0vcmVzb3VyY2VzLyR7ZH0tYWxsJHtpfS5jc3NgKSA6IGF3YWl0IEsoYCR7Zn0vJHtkfS9idWlsZC8ke3R9LyR7dH0tJHtufS9yZXNvdXJjZXMvJHtkfS1hbGwke2l9LmNzc2ApKSksIGMucGl2b3RkMyA9PT0gITAgJiYgKGQgPSBcInBpdm90LWQzXCIsIGF3YWl0IGRlKGAke2Z9LyR7ZH0vYnVpbGQvJHt0fS8ke2R9JHtpfS5qc2ApLCB0ID09PSBcIm1vZGVyblwiICYmIChuID09PSBcImlvc1wiIHx8IG4gPT09IFwibWF0ZXJpYWxcIikgPyBhd2FpdCBLKGAke2Z9LyR7ZH0vYnVpbGQvJHt0fS8ke259L3Jlc291cmNlcy8ke2R9LWFsbCR7aX0uY3NzYCkgOiBuICE9PSBcImdyYXlcIiAmJiBuICE9PSBcImdyYXBoaXRlXCIgJiYgKHQgPT09IFwiY2xhc3NpY1wiICYmIG4gIT09IFwibWF0ZXJpYWxcIiA/IGF3YWl0IEsoYCR7Zn0vJHtkfS9idWlsZC8ke3R9LyR7bn0vcmVzb3VyY2VzLyR7ZH0tYWxsJHtpfS5jc3NgKSA6IGF3YWl0IEsoYCR7Zn0vJHtkfS9idWlsZC8ke3R9LyR7dH0tJHtufS9yZXNvdXJjZXMvJHtkfS1hbGwke2l9LmNzc2ApKSksIGMuZnJvYWxhZWRpdG9yID09PSAhMCAmJiB0ID09PSBcIm1vZGVyblwiICYmIChhd2FpdCBkZShgJHtmfS9mcm9hbGEtZWRpdG9yL2Zyb2FsYS1lZGl0b3Ike2l9LmpzYCksIGF3YWl0IEsoYCR7Zn0vZnJvYWxhLWVkaXRvci9idWlsZC9yZXNvdXJjZXMvZnJvYWxhLWVkaXRvci1hbGwke2l9LmNzc2ApLCBhd2FpdCBkZShgJHtmfS9mcm9hbGEtZWRpdG9yL2RldmVsb3BtZW50L2Zyb2FsYWVkaXRvci5wa2dkLmpzYCksIGF3YWl0IEsoYCR7Zn0vZnJvYWxhLWVkaXRvci9kZXZlbG9wbWVudC9mcm9hbGFlZGl0b3IucGtnZC5jc3NgKSksIGMucGl2b3Rsb2NhbGU7XG4gIH1cbiAgYXdhaXQgb24obiwgbCwgbyk7XG59XG5jb25zdCBkcCA9IChlLCByLCB0KSA9PiAoRXh0LkNsYXNzTWFuYWdlci5pc0NyZWF0ZWQoZSkgJiYgKGNvbnNvbGUubG9nKGUsIFwiYWxyZWFkeSBjcmVhdGVkXCIpLCBFeHQudW5kZWZpbmUoZSkpLCBFeHQuZGVmaW5lKGUsIHIsIHQpKTtcbmV4cG9ydCB7XG4gIGRwIGFzIEV4dF9kZWZpbmUsXG4gIGFwIGFzIEZpbGwsXG4gIEJuIGFzIFJlRXh0TG9hZGVyLFxuICBscCBhcyBSZUV4dFByb3ZpZGVyLFxuICBmcCBhcyBSZUV4dFJlZmVyZW5jZXMsXG4gIHRwIGFzIFJlRXh0U3BsYXNoLFxuICBjcCBhcyBUZXN0LFxuICBucCBhcyBkZWZhdWx0LFxuICB1cCBhcyB1c2VSZUV4dFN0YXRlXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@gusmano/reext/dist/reext.es.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./app/reextgrid/page.js":
/*!*******************************!*\
  !*** ./app/reextgrid/page.js ***!
  \*******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ ReExtGrid; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var _gusmano_reext__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @gusmano/reext */ \"(app-pages-browser)/./node_modules/@gusmano/reext/dist/reext.es.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\nfunction ReExtGrid() {\n    _s();\n    const [ready, setReady] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(false);\n    (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)(()=>{\n        const doAsync = async ()=>{\n            await __webpack_require__.e(/*! import() */ \"_app-pages-browser_app_reextgrid_BigDataStore_js\").then(__webpack_require__.t.bind(__webpack_require__, /*! ./BigDataStore.js */ \"(app-pages-browser)/./app/reextgrid/BigDataStore.js\", 23));\n            setReady(true);\n        };\n        doAsync();\n    }, []);\n    const onSelect = (grid, selected)=>{\n        var row = selected.data;\n        alert(JSON.stringify(row));\n    };\n    if (!ready) {\n        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            children: \"Loading...\"\n        }, void 0, false, {\n            fileName: \"/Users/marcgusmano/@/webinars/ReExtNext/reextnext/app/reextgrid/page.js\",\n            lineNumber: 21,\n            columnNumber: 12\n        }, this);\n    } else {\n        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            className: \"zcol\",\n            children: [\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_gusmano_reext__WEBPACK_IMPORTED_MODULE_1__[\"default\"], {\n                    xtype: \"logosmall\",\n                    style: {\n                        height: 50,\n                        margin: \"5px\"\n                    }\n                }, void 0, false, {\n                    fileName: \"/Users/marcgusmano/@/webinars/ReExtNext/reextnext/app/reextgrid/page.js\",\n                    lineNumber: 26,\n                    columnNumber: 9\n                }, this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_gusmano_reext__WEBPACK_IMPORTED_MODULE_1__[\"default\"], {\n                    xtype: \"grid\",\n                    style: {\n                        padding: 10\n                    },\n                    onSelect: onSelect,\n                    config: {\n                        title: \"Big Data / Infinite Grid - 50,000 rows\",\n                        store: {\n                            type: \"virtualforum\"\n                        },\n                        grouped: false,\n                        columns: [\n                            {\n                                text: \"First Name\",\n                                width: 100,\n                                dataIndex: \"firstName\"\n                            },\n                            {\n                                text: \"Last Name\",\n                                width: 100,\n                                dataIndex: \"lastName\"\n                            },\n                            {\n                                text: \"Title\",\n                                width: 200,\n                                dataIndex: \"title\"\n                            },\n                            {\n                                text: \"Address\",\n                                flex: 1,\n                                dataIndex: \"address\"\n                            },\n                            {\n                                text: \"Company\",\n                                flex: 1,\n                                dataIndex: \"company\"\n                            }\n                        ]\n                    }\n                }, void 0, false, {\n                    fileName: \"/Users/marcgusmano/@/webinars/ReExtNext/reextnext/app/reextgrid/page.js\",\n                    lineNumber: 28,\n                    columnNumber: 9\n                }, this)\n            ]\n        }, void 0, true, {\n            fileName: \"/Users/marcgusmano/@/webinars/ReExtNext/reextnext/app/reextgrid/page.js\",\n            lineNumber: 24,\n            columnNumber: 7\n        }, this);\n    }\n}\n_s(ReExtGrid, \"KuazqYXqOk+6VRk8yHVvoClyoeE=\");\n_c = ReExtGrid;\nvar _c;\n$RefreshReg$(_c, \"ReExtGrid\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9yZWV4dGdyaWQvcGFnZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQ21DO0FBQ1M7QUFDN0IsU0FBU0c7O0lBQ3RCLE1BQU0sQ0FBQ0MsT0FBT0MsU0FBUyxHQUFHSiwrQ0FBUUEsQ0FBQztJQUVuQ0MsZ0RBQVNBLENBQUM7UUFDUixNQUFNSSxVQUFVO1lBQ2QsTUFBTSxtT0FBTztZQUNiRCxTQUFTO1FBQ1g7UUFDQUM7SUFDRixHQUFHLEVBQUU7SUFFTCxNQUFNQyxXQUFXLENBQUNDLE1BQU1DO1FBQ3RCLElBQUlDLE1BQU1ELFNBQVNFLElBQUk7UUFDdkJDLE1BQU1DLEtBQUtDLFNBQVMsQ0FBQ0o7SUFDdkI7SUFFQSxJQUFJLENBQUNOLE9BQU87UUFDVixxQkFBTyw4REFBQ1c7c0JBQUk7Ozs7OztJQUNkLE9BQU87UUFDTCxxQkFDRSw4REFBQ0E7WUFBSUMsV0FBVTs7OEJBRWIsOERBQUNoQixzREFBS0E7b0JBQUNpQixPQUFNO29CQUFZQyxPQUFPO3dCQUFFQyxRQUFRO3dCQUFJQyxRQUFRO29CQUFNOzs7Ozs7OEJBRTVELDhEQUFDcEIsc0RBQUtBO29CQUFDaUIsT0FBTTtvQkFDWEMsT0FBTzt3QkFBRUcsU0FBUztvQkFBRztvQkFDckJkLFVBQVVBO29CQUNWZSxRQUFRO3dCQUNOQyxPQUFPO3dCQUNQQyxPQUFPOzRCQUFFQyxNQUFNO3dCQUFlO3dCQUM5QkMsU0FBUzt3QkFDVEMsU0FBUzs0QkFDUDtnQ0FBRUMsTUFBTTtnQ0FBY0MsT0FBTztnQ0FBS0MsV0FBVzs0QkFBWTs0QkFDekQ7Z0NBQUVGLE1BQU07Z0NBQWFDLE9BQU87Z0NBQUtDLFdBQVc7NEJBQVc7NEJBQ3ZEO2dDQUFFRixNQUFNO2dDQUFTQyxPQUFPO2dDQUFLQyxXQUFXOzRCQUFROzRCQUNoRDtnQ0FBRUYsTUFBTTtnQ0FBV0csTUFBTTtnQ0FBR0QsV0FBVzs0QkFBVTs0QkFDakQ7Z0NBQUVGLE1BQU07Z0NBQVdHLE1BQU07Z0NBQUdELFdBQVc7NEJBQVU7eUJBQUU7b0JBRXZEOzs7Ozs7Ozs7Ozs7SUFJUjtBQUVGO0dBNUN3QjNCO0tBQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2FwcC9yZWV4dGdyaWQvcGFnZS5qcz85MDcxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiO1xuaW1wb3J0IFJlRXh0IGZyb20gJ0BndXNtYW5vL3JlZXh0JztcbmltcG9ydCB7IHVzZVN0YXRlLCB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCc7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBSZUV4dEdyaWQoKSB7XG4gIGNvbnN0IFtyZWFkeSwgc2V0UmVhZHldID0gdXNlU3RhdGUoZmFsc2UpO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgZG9Bc3luYyA9IGFzeW5jICgpID0+IHtcbiAgICAgIGF3YWl0IGltcG9ydCgnLi9CaWdEYXRhU3RvcmUuanMnKTtcbiAgICAgIHNldFJlYWR5KHRydWUpO1xuICAgIH07XG4gICAgZG9Bc3luYygpO1xuICB9LCBbXSk7XG5cbiAgY29uc3Qgb25TZWxlY3QgPSAoZ3JpZCwgc2VsZWN0ZWQpID0+IHtcbiAgICB2YXIgcm93ID0gc2VsZWN0ZWQuZGF0YTtcbiAgICBhbGVydChKU09OLnN0cmluZ2lmeShyb3cpKVxuICB9O1xuXG4gIGlmICghcmVhZHkpIHtcbiAgICByZXR1cm4gPGRpdj5Mb2FkaW5nLi4uPC9kaXY+O1xuICB9IGVsc2UgeyAgXG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiemNvbFwiPlxuXG4gICAgICAgIDxSZUV4dCB4dHlwZT0nbG9nb3NtYWxsJyBzdHlsZT17eyBoZWlnaHQ6IDUwLCBtYXJnaW46ICc1cHgnIH19IC8+XG5cbiAgICAgICAgPFJlRXh0IHh0eXBlPSdncmlkJ1xuICAgICAgICAgIHN0eWxlPXt7IHBhZGRpbmc6IDEwIH19XG4gICAgICAgICAgb25TZWxlY3Q9e29uU2VsZWN0fVxuICAgICAgICAgIGNvbmZpZz17e1xuICAgICAgICAgICAgdGl0bGU6ICdCaWcgRGF0YSAvIEluZmluaXRlIEdyaWQgLSA1MCwwMDAgcm93cycsXG4gICAgICAgICAgICBzdG9yZTogeyB0eXBlOiAndmlydHVhbGZvcnVtJyB9LFxuICAgICAgICAgICAgZ3JvdXBlZDogZmFsc2UsXG4gICAgICAgICAgICBjb2x1bW5zOiBbXG4gICAgICAgICAgICAgIHsgdGV4dDogJ0ZpcnN0IE5hbWUnLCB3aWR0aDogMTAwLCBkYXRhSW5kZXg6ICdmaXJzdE5hbWUnIH0sXG4gICAgICAgICAgICAgIHsgdGV4dDogJ0xhc3QgTmFtZScsIHdpZHRoOiAxMDAsIGRhdGFJbmRleDogJ2xhc3ROYW1lJyB9LFxuICAgICAgICAgICAgICB7IHRleHQ6ICdUaXRsZScsIHdpZHRoOiAyMDAsIGRhdGFJbmRleDogJ3RpdGxlJyB9LFxuICAgICAgICAgICAgICB7IHRleHQ6ICdBZGRyZXNzJywgZmxleDogMSwgZGF0YUluZGV4OiAnYWRkcmVzcycgfSxcbiAgICAgICAgICAgICAgeyB0ZXh0OiAnQ29tcGFueScsIGZsZXg6IDEsIGRhdGFJbmRleDogJ2NvbXBhbnknIH1dXG5cbiAgICAgICAgICB9fVxuICAgICAgICAvPlxuXG4gICAgICA8L2Rpdj4pO1xuICB9XG5cbn0iXSwibmFtZXMiOlsiUmVFeHQiLCJ1c2VTdGF0ZSIsInVzZUVmZmVjdCIsIlJlRXh0R3JpZCIsInJlYWR5Iiwic2V0UmVhZHkiLCJkb0FzeW5jIiwib25TZWxlY3QiLCJncmlkIiwic2VsZWN0ZWQiLCJyb3ciLCJkYXRhIiwiYWxlcnQiLCJKU09OIiwic3RyaW5naWZ5IiwiZGl2IiwiY2xhc3NOYW1lIiwieHR5cGUiLCJzdHlsZSIsImhlaWdodCIsIm1hcmdpbiIsInBhZGRpbmciLCJjb25maWciLCJ0aXRsZSIsInN0b3JlIiwidHlwZSIsImdyb3VwZWQiLCJjb2x1bW5zIiwidGV4dCIsIndpZHRoIiwiZGF0YUluZGV4IiwiZmxleCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/reextgrid/page.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js ***!
  \****************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nif (true) {\n  (function() {\n'use strict';\n\nvar React = __webpack_require__(/*! next/dist/compiled/react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n\n// ATTENTION\n// When adding new symbols to this file,\n// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n// The Symbol used to tag the ReactElement-like types.\nvar REACT_ELEMENT_TYPE = Symbol.for('react.element');\nvar REACT_PORTAL_TYPE = Symbol.for('react.portal');\nvar REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');\nvar REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');\nvar REACT_PROFILER_TYPE = Symbol.for('react.profiler');\nvar REACT_PROVIDER_TYPE = Symbol.for('react.provider'); // TODO: Delete with enableRenderableContext\n\nvar REACT_CONSUMER_TYPE = Symbol.for('react.consumer');\nvar REACT_CONTEXT_TYPE = Symbol.for('react.context');\nvar REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');\nvar REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');\nvar REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');\nvar REACT_MEMO_TYPE = Symbol.for('react.memo');\nvar REACT_LAZY_TYPE = Symbol.for('react.lazy');\nvar REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');\nvar REACT_CACHE_TYPE = Symbol.for('react.cache');\nvar MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\nvar FAUX_ITERATOR_SYMBOL = '@@iterator';\nfunction getIteratorFn(maybeIterable) {\n  if (maybeIterable === null || typeof maybeIterable !== 'object') {\n    return null;\n  }\n\n  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n\n  if (typeof maybeIterator === 'function') {\n    return maybeIterator;\n  }\n\n  return null;\n}\n\nvar ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\nfunction error(format) {\n  {\n    {\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      printWarning('error', format, args);\n    }\n  }\n}\n\nfunction printWarning(level, format, args) {\n  // When changing this logic, you might want to also\n  // update consoleWithStackDev.www.js as well.\n  {\n    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n    var stack = ReactDebugCurrentFrame.getStackAddendum();\n\n    if (stack !== '') {\n      format += '%s';\n      args = args.concat([stack]);\n    } // eslint-disable-next-line react-internal/safe-string-coercion\n\n\n    var argsWithFormat = args.map(function (item) {\n      return String(item);\n    }); // Careful: RN currently depends on this prefix\n\n    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n    // breaks IE9: https://github.com/facebook/react/issues/13610\n    // eslint-disable-next-line react-internal/no-production-logging\n\n    Function.prototype.apply.call(console[level], console, argsWithFormat);\n  }\n}\n\n// -----------------------------------------------------------------------------\n\nvar enableScopeAPI = false; // Experimental Create Event Handle API.\nvar enableCacheElement = false;\nvar enableTransitionTracing = false; // No known bugs, but needs performance testing\n\nvar enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\nvar enableRenderableContext = false;\n// stuff. Intended to enable React core members to more easily debug scheduling\n// issues in DEV builds.\n\nvar enableDebugTracing = false;\n\nfunction getWrappedName(outerType, innerType, wrapperName) {\n  var displayName = outerType.displayName;\n\n  if (displayName) {\n    return displayName;\n  }\n\n  var functionName = innerType.displayName || innerType.name || '';\n  return functionName !== '' ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n} // Keep in sync with react-reconciler/getComponentNameFromFiber\n\n\nfunction getContextName(type) {\n  return type.displayName || 'Context';\n}\n\nvar REACT_CLIENT_REFERENCE$2 = Symbol.for('react.client.reference'); // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n\nfunction getComponentNameFromType(type) {\n  if (type == null) {\n    // Host root, text node or just invalid type.\n    return null;\n  }\n\n  if (typeof type === 'function') {\n    if (type.$$typeof === REACT_CLIENT_REFERENCE$2) {\n      // TODO: Create a convention for naming client references with debug info.\n      return null;\n    }\n\n    return type.displayName || type.name || null;\n  }\n\n  if (typeof type === 'string') {\n    return type;\n  }\n\n  switch (type) {\n    case REACT_FRAGMENT_TYPE:\n      return 'Fragment';\n\n    case REACT_PORTAL_TYPE:\n      return 'Portal';\n\n    case REACT_PROFILER_TYPE:\n      return 'Profiler';\n\n    case REACT_STRICT_MODE_TYPE:\n      return 'StrictMode';\n\n    case REACT_SUSPENSE_TYPE:\n      return 'Suspense';\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return 'SuspenseList';\n\n    case REACT_CACHE_TYPE:\n      {\n        return 'Cache';\n      }\n\n  }\n\n  if (typeof type === 'object') {\n    {\n      if (typeof type.tag === 'number') {\n        error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');\n      }\n    }\n\n    switch (type.$$typeof) {\n      case REACT_PROVIDER_TYPE:\n        {\n          var provider = type;\n          return getContextName(provider._context) + '.Provider';\n        }\n\n      case REACT_CONTEXT_TYPE:\n        var context = type;\n\n        {\n          return getContextName(context) + '.Consumer';\n        }\n\n      case REACT_CONSUMER_TYPE:\n        {\n          return null;\n        }\n\n      case REACT_FORWARD_REF_TYPE:\n        return getWrappedName(type, type.render, 'ForwardRef');\n\n      case REACT_MEMO_TYPE:\n        var outerName = type.displayName || null;\n\n        if (outerName !== null) {\n          return outerName;\n        }\n\n        return getComponentNameFromType(type.type) || 'Memo';\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            return getComponentNameFromType(init(payload));\n          } catch (x) {\n            return null;\n          }\n        }\n    }\n  }\n\n  return null;\n}\n\n// $FlowFixMe[method-unbinding]\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar assign = Object.assign;\n\n/*\n * The `'' + value` pattern (used in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */\n// $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\nfunction typeName(value) {\n  {\n    // toStringTag is needed for namespaced types like Temporal.Instant\n    var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;\n    var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object'; // $FlowFixMe[incompatible-return]\n\n    return type;\n  }\n} // $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\n\n\nfunction willCoercionThrow(value) {\n  {\n    try {\n      testStringCoercion(value);\n      return false;\n    } catch (e) {\n      return true;\n    }\n  }\n}\n\nfunction testStringCoercion(value) {\n  // If you ended up here by following an exception call stack, here's what's\n  // happened: you supplied an object or symbol value to React (as a prop, key,\n  // DOM attribute, CSS property, string ref, etc.) and when React tried to\n  // coerce it to a string using `'' + value`, an exception was thrown.\n  //\n  // The most common types that will cause this exception are `Symbol` instances\n  // and Temporal objects like `Temporal.Instant`. But any object that has a\n  // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n  // exception. (Library authors do this to prevent users from using built-in\n  // numeric operators like `+` or comparison operators like `>=` because custom\n  // methods are needed to perform accurate arithmetic or comparison.)\n  //\n  // To fix the problem, coerce this object or symbol value to a string before\n  // passing it to React. The most reliable way is usually `String(value)`.\n  //\n  // To find which value is throwing, check the browser or debugger console.\n  // Before this exception was thrown, there should be `console.error` output\n  // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n  // problem and how that type was used: key, atrribute, input value prop, etc.\n  // In most cases, this console output also shows the component and its\n  // ancestor components where the exception happened.\n  //\n  // eslint-disable-next-line react-internal/safe-string-coercion\n  return '' + value;\n}\nfunction checkKeyStringCoercion(value) {\n  {\n    if (willCoercionThrow(value)) {\n      error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before using it here.', typeName(value));\n\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n\nvar REACT_CLIENT_REFERENCE$1 = Symbol.for('react.client.reference');\nfunction isValidElementType(type) {\n  if (typeof type === 'string' || typeof type === 'function') {\n    return true;\n  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n\n\n  if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing  || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden  || type === REACT_OFFSCREEN_TYPE || enableScopeAPI  || enableCacheElement  || enableTransitionTracing ) {\n    return true;\n  }\n\n  if (typeof type === 'object' && type !== null) {\n    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || enableRenderableContext  || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n    // types supported by any Flight configuration anywhere since\n    // we don't know which Flight build this will end up being used\n    // with.\n    type.$$typeof === REACT_CLIENT_REFERENCE$1 || type.getModuleId !== undefined) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nvar isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n\nfunction isArray(a) {\n  return isArrayImpl(a);\n}\n\n// Helpers to patch console.logs to avoid logging during side-effect free\n// replaying on render function. This currently only patches the object\n// lazily which won't cover if the log function was extracted eagerly.\n// We could also eagerly patch the method.\nvar disabledDepth = 0;\nvar prevLog;\nvar prevInfo;\nvar prevWarn;\nvar prevError;\nvar prevGroup;\nvar prevGroupCollapsed;\nvar prevGroupEnd;\n\nfunction disabledLog() {}\n\ndisabledLog.__reactDisabledLog = true;\nfunction disableLogs() {\n  {\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      prevLog = console.log;\n      prevInfo = console.info;\n      prevWarn = console.warn;\n      prevError = console.error;\n      prevGroup = console.group;\n      prevGroupCollapsed = console.groupCollapsed;\n      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n\n      var props = {\n        configurable: true,\n        enumerable: true,\n        value: disabledLog,\n        writable: true\n      }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        info: props,\n        log: props,\n        warn: props,\n        error: props,\n        group: props,\n        groupCollapsed: props,\n        groupEnd: props\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    disabledDepth++;\n  }\n}\nfunction reenableLogs() {\n  {\n    disabledDepth--;\n\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      var props = {\n        configurable: true,\n        enumerable: true,\n        writable: true\n      }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        log: assign({}, props, {\n          value: prevLog\n        }),\n        info: assign({}, props, {\n          value: prevInfo\n        }),\n        warn: assign({}, props, {\n          value: prevWarn\n        }),\n        error: assign({}, props, {\n          value: prevError\n        }),\n        group: assign({}, props, {\n          value: prevGroup\n        }),\n        groupCollapsed: assign({}, props, {\n          value: prevGroupCollapsed\n        }),\n        groupEnd: assign({}, props, {\n          value: prevGroupEnd\n        })\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    if (disabledDepth < 0) {\n      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');\n    }\n  }\n}\n\nvar ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\nvar prefix;\nfunction describeBuiltInComponentFrame(name, ownerFn) {\n  {\n    if (prefix === undefined) {\n      // Extract the VM specific prefix used by each line.\n      try {\n        throw Error();\n      } catch (x) {\n        var match = x.stack.trim().match(/\\n( *(at )?)/);\n        prefix = match && match[1] || '';\n      }\n    } // We use the prefix to ensure our stacks line up with native stack frames.\n\n\n    return '\\n' + prefix + name;\n  }\n}\nvar reentry = false;\nvar componentFrameCache;\n\n{\n  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\n  componentFrameCache = new PossiblyWeakMap();\n}\n/**\n * Leverages native browser/VM stack frames to get proper details (e.g.\n * filename, line + col number) for a single component in a component stack. We\n * do this by:\n *   (1) throwing and catching an error in the function - this will be our\n *       control error.\n *   (2) calling the component which will eventually throw an error that we'll\n *       catch - this will be our sample error.\n *   (3) diffing the control and sample error stacks to find the stack frame\n *       which represents our component.\n */\n\n\nfunction describeNativeComponentFrame(fn, construct) {\n  // If something asked for a stack inside a fake render, it should get ignored.\n  if (!fn || reentry) {\n    return '';\n  }\n\n  {\n    var frame = componentFrameCache.get(fn);\n\n    if (frame !== undefined) {\n      return frame;\n    }\n  }\n\n  reentry = true;\n  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe[incompatible-type] It does accept undefined.\n\n  Error.prepareStackTrace = undefined;\n  var previousDispatcher;\n\n  {\n    previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\n    // for warnings.\n\n    ReactCurrentDispatcher.current = null;\n    disableLogs();\n  }\n  /**\n   * Finding a common stack frame between sample and control errors can be\n   * tricky given the different types and levels of stack trace truncation from\n   * different JS VMs. So instead we'll attempt to control what that common\n   * frame should be through this object method:\n   * Having both the sample and control errors be in the function under the\n   * `DescribeNativeComponentFrameRoot` property, + setting the `name` and\n   * `displayName` properties of the function ensures that a stack\n   * frame exists that has the method name `DescribeNativeComponentFrameRoot` in\n   * it for both control and sample stacks.\n   */\n\n\n  var RunInRootFrame = {\n    DetermineComponentFrameRoot: function () {\n      var control;\n\n      try {\n        // This should throw.\n        if (construct) {\n          // Something should be setting the props in the constructor.\n          var Fake = function () {\n            throw Error();\n          }; // $FlowFixMe[prop-missing]\n\n\n          Object.defineProperty(Fake.prototype, 'props', {\n            set: function () {\n              // We use a throwing setter instead of frozen or non-writable props\n              // because that won't throw in a non-strict mode function.\n              throw Error();\n            }\n          });\n\n          if (typeof Reflect === 'object' && Reflect.construct) {\n            // We construct a different control for this case to include any extra\n            // frames added by the construct call.\n            try {\n              Reflect.construct(Fake, []);\n            } catch (x) {\n              control = x;\n            }\n\n            Reflect.construct(fn, [], Fake);\n          } else {\n            try {\n              Fake.call();\n            } catch (x) {\n              control = x;\n            } // $FlowFixMe[prop-missing] found when upgrading Flow\n\n\n            fn.call(Fake.prototype);\n          }\n        } else {\n          try {\n            throw Error();\n          } catch (x) {\n            control = x;\n          } // TODO(luna): This will currently only throw if the function component\n          // tries to access React/ReactDOM/props. We should probably make this throw\n          // in simple components too\n\n\n          var maybePromise = fn(); // If the function component returns a promise, it's likely an async\n          // component, which we don't yet support. Attach a noop catch handler to\n          // silence the error.\n          // TODO: Implement component stacks for async client components?\n\n          if (maybePromise && typeof maybePromise.catch === 'function') {\n            maybePromise.catch(function () {});\n          }\n        }\n      } catch (sample) {\n        // This is inlined manually because closure doesn't do it for us.\n        if (sample && control && typeof sample.stack === 'string') {\n          return [sample.stack, control.stack];\n        }\n      }\n\n      return [null, null];\n    }\n  }; // $FlowFixMe[prop-missing]\n\n  RunInRootFrame.DetermineComponentFrameRoot.displayName = 'DetermineComponentFrameRoot';\n  var namePropDescriptor = Object.getOwnPropertyDescriptor(RunInRootFrame.DetermineComponentFrameRoot, 'name'); // Before ES6, the `name` property was not configurable.\n\n  if (namePropDescriptor && namePropDescriptor.configurable) {\n    // V8 utilizes a function's `name` property when generating a stack trace.\n    Object.defineProperty(RunInRootFrame.DetermineComponentFrameRoot, // Configurable properties can be updated even if its writable descriptor\n    // is set to `false`.\n    // $FlowFixMe[cannot-write]\n    'name', {\n      value: 'DetermineComponentFrameRoot'\n    });\n  }\n\n  try {\n    var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(),\n        sampleStack = _RunInRootFrame$Deter[0],\n        controlStack = _RunInRootFrame$Deter[1];\n\n    if (sampleStack && controlStack) {\n      // This extracts the first frame from the sample that isn't also in the control.\n      // Skipping one frame that we assume is the frame that calls the two.\n      var sampleLines = sampleStack.split('\\n');\n      var controlLines = controlStack.split('\\n');\n      var s = 0;\n      var c = 0;\n\n      while (s < sampleLines.length && !sampleLines[s].includes('DetermineComponentFrameRoot')) {\n        s++;\n      }\n\n      while (c < controlLines.length && !controlLines[c].includes('DetermineComponentFrameRoot')) {\n        c++;\n      } // We couldn't find our intentionally injected common root frame, attempt\n      // to find another common root frame by search from the bottom of the\n      // control stack...\n\n\n      if (s === sampleLines.length || c === controlLines.length) {\n        s = sampleLines.length - 1;\n        c = controlLines.length - 1;\n\n        while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\n          // We expect at least one stack frame to be shared.\n          // Typically this will be the root most one. However, stack frames may be\n          // cut off due to maximum stack limits. In this case, one maybe cut off\n          // earlier than the other. We assume that the sample is longer or the same\n          // and there for cut off earlier. So we should find the root most frame in\n          // the sample somewhere in the control.\n          c--;\n        }\n      }\n\n      for (; s >= 1 && c >= 0; s--, c--) {\n        // Next we find the first one that isn't the same which should be the\n        // frame that called our sample function and the control.\n        if (sampleLines[s] !== controlLines[c]) {\n          // In V8, the first line is describing the message but other VMs don't.\n          // If we're about to return the first line, and the control is also on the same\n          // line, that's a pretty good indicator that our sample threw at same line as\n          // the control. I.e. before we entered the sample frame. So we ignore this result.\n          // This can happen if you passed a class to function component, or non-function.\n          if (s !== 1 || c !== 1) {\n            do {\n              s--;\n              c--; // We may still have similar intermediate frames from the construct call.\n              // The next one that isn't the same should be our match though.\n\n              if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                var _frame = '\\n' + sampleLines[s].replace(' at new ', ' at '); // If our component frame is labeled \"<anonymous>\"\n                // but we have a user-provided \"displayName\"\n                // splice it in to make the stack more readable.\n\n\n                if (fn.displayName && _frame.includes('<anonymous>')) {\n                  _frame = _frame.replace('<anonymous>', fn.displayName);\n                }\n\n                if (true) {\n                  if (typeof fn === 'function') {\n                    componentFrameCache.set(fn, _frame);\n                  }\n                } // Return the line we found.\n\n\n                return _frame;\n              }\n            } while (s >= 1 && c >= 0);\n          }\n\n          break;\n        }\n      }\n    }\n  } finally {\n    reentry = false;\n\n    {\n      ReactCurrentDispatcher.current = previousDispatcher;\n      reenableLogs();\n    }\n\n    Error.prepareStackTrace = previousPrepareStackTrace;\n  } // Fallback to just using the name if we couldn't make it throw.\n\n\n  var name = fn ? fn.displayName || fn.name : '';\n  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';\n\n  {\n    if (typeof fn === 'function') {\n      componentFrameCache.set(fn, syntheticFrame);\n    }\n  }\n\n  return syntheticFrame;\n}\nfunction describeFunctionComponentFrame(fn, ownerFn) {\n  {\n    return describeNativeComponentFrame(fn, false);\n  }\n}\n\nfunction shouldConstruct(Component) {\n  var prototype = Component.prototype;\n  return !!(prototype && prototype.isReactComponent);\n}\n\nfunction describeUnknownElementTypeFrameInDEV(type, ownerFn) {\n\n  if (type == null) {\n    return '';\n  }\n\n  if (typeof type === 'function') {\n    {\n      return describeNativeComponentFrame(type, shouldConstruct(type));\n    }\n  }\n\n  if (typeof type === 'string') {\n    return describeBuiltInComponentFrame(type);\n  }\n\n  switch (type) {\n    case REACT_SUSPENSE_TYPE:\n      return describeBuiltInComponentFrame('Suspense');\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return describeBuiltInComponentFrame('SuspenseList');\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_FORWARD_REF_TYPE:\n        return describeFunctionComponentFrame(type.render);\n\n      case REACT_MEMO_TYPE:\n        // Memo may contain any component type so we recursively resolve it.\n        return describeUnknownElementTypeFrameInDEV(type.type, ownerFn);\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            // Lazy may contain any component type so we recursively resolve it.\n            return describeUnknownElementTypeFrameInDEV(init(payload), ownerFn);\n          } catch (x) {}\n        }\n    }\n  }\n\n  return '';\n}\n\nvar ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\nvar ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\nvar REACT_CLIENT_REFERENCE = Symbol.for('react.client.reference');\nvar specialPropKeyWarningShown;\nvar specialPropRefWarningShown;\nvar didWarnAboutStringRefs;\n\n{\n  didWarnAboutStringRefs = {};\n}\n\nfunction hasValidRef(config) {\n  {\n    if (hasOwnProperty.call(config, 'ref')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.ref !== undefined;\n}\n\nfunction hasValidKey(config) {\n  {\n    if (hasOwnProperty.call(config, 'key')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.key !== undefined;\n}\n\nfunction warnIfStringRefCannotBeAutoConverted(config, self) {\n  {\n    if (typeof config.ref === 'string' && ReactCurrentOwner.current && self && ReactCurrentOwner.current.stateNode !== self) {\n      var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);\n\n      if (!didWarnAboutStringRefs[componentName]) {\n        error('Component \"%s\" contains the string ref \"%s\". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner.current.type), config.ref);\n\n        didWarnAboutStringRefs[componentName] = true;\n      }\n    }\n  }\n}\n\nfunction defineKeyPropWarningGetter(props, displayName) {\n  {\n    var warnAboutAccessingKey = function () {\n      if (!specialPropKeyWarningShown) {\n        specialPropKeyWarningShown = true;\n\n        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    };\n\n    warnAboutAccessingKey.isReactWarning = true;\n    Object.defineProperty(props, 'key', {\n      get: warnAboutAccessingKey,\n      configurable: true\n    });\n  }\n}\n\nfunction defineRefPropWarningGetter(props, displayName) {\n  {\n    {\n      var warnAboutAccessingRef = function () {\n        if (!specialPropRefWarningShown) {\n          specialPropRefWarningShown = true;\n\n          error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n        }\n      };\n\n      warnAboutAccessingRef.isReactWarning = true;\n      Object.defineProperty(props, 'ref', {\n        get: warnAboutAccessingRef,\n        configurable: true\n      });\n    }\n  }\n}\n/**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */\n\n\nfunction ReactElement(type, key, _ref, self, source, owner, props) {\n  var ref;\n\n  {\n    ref = _ref;\n  }\n\n  var element;\n\n  {\n    // In prod, `ref` is a regular property. It will be removed in a\n    // future release.\n    element = {\n      // This tag allows us to uniquely identify this as a React Element\n      $$typeof: REACT_ELEMENT_TYPE,\n      // Built-in properties that belong on the element\n      type: type,\n      key: key,\n      ref: ref,\n      props: props,\n      // Record the component responsible for creating this element.\n      _owner: owner\n    };\n  }\n\n  {\n    // The validation flag is currently mutative. We put it on\n    // an external backing store so that we can freeze the whole object.\n    // This can be replaced with a WeakMap once they are implemented in\n    // commonly used development environments.\n    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n    // the validation flag non-enumerable (where possible, which should\n    // include every environment we run tests in), so the test framework\n    // ignores it.\n\n    Object.defineProperty(element._store, 'validated', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: false\n    }); // debugInfo contains Server Component debug information.\n\n    Object.defineProperty(element, '_debugInfo', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: null\n    });\n\n    if (Object.freeze) {\n      Object.freeze(element.props);\n      Object.freeze(element);\n    }\n  }\n\n  return element;\n}\nvar didWarnAboutKeySpread = {};\n/**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */\n\nfunction jsxDEV$1(type, config, maybeKey, isStaticChildren, source, self) {\n  {\n    if (!isValidElementType(type)) {\n      // This is an invalid element type.\n      //\n      // We warn in this case but don't throw. We expect the element creation to\n      // succeed and there will likely be errors in render.\n      var info = '';\n\n      if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n        info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\n      }\n\n      var typeString;\n\n      if (type === null) {\n        typeString = 'null';\n      } else if (isArray(type)) {\n        typeString = 'array';\n      } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n        typeString = \"<\" + (getComponentNameFromType(type.type) || 'Unknown') + \" />\";\n        info = ' Did you accidentally export a JSX literal instead of a component?';\n      } else {\n        typeString = typeof type;\n      }\n\n      error('React.jsx: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);\n    } else {\n      // This is a valid element type.\n      // Skip key warning if the type isn't valid since our key validation logic\n      // doesn't expect a non-string/function type and can throw confusing\n      // errors. We don't want exception behavior to differ between dev and\n      // prod. (Rendering will throw with a helpful message and as soon as the\n      // type is fixed, the key warnings will appear.)\n      var children = config.children;\n\n      if (children !== undefined) {\n        if (isStaticChildren) {\n          if (isArray(children)) {\n            for (var i = 0; i < children.length; i++) {\n              validateChildKeys(children[i], type);\n            }\n\n            if (Object.freeze) {\n              Object.freeze(children);\n            }\n          } else {\n            error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');\n          }\n        } else {\n          validateChildKeys(children, type);\n        }\n      }\n    } // Warn about key spread regardless of whether the type is valid.\n\n\n    if (hasOwnProperty.call(config, 'key')) {\n      var componentName = getComponentNameFromType(type);\n      var keys = Object.keys(config).filter(function (k) {\n        return k !== 'key';\n      });\n      var beforeExample = keys.length > 0 ? '{key: someKey, ' + keys.join(': ..., ') + ': ...}' : '{key: someKey}';\n\n      if (!didWarnAboutKeySpread[componentName + beforeExample]) {\n        var afterExample = keys.length > 0 ? '{' + keys.join(': ..., ') + ': ...}' : '{}';\n\n        error('A props object containing a \"key\" prop is being spread into JSX:\\n' + '  let props = %s;\\n' + '  <%s {...props} />\\n' + 'React keys must be passed directly to JSX without using spread:\\n' + '  let props = %s;\\n' + '  <%s key={someKey} {...props} />', beforeExample, componentName, afterExample, componentName);\n\n        didWarnAboutKeySpread[componentName + beforeExample] = true;\n      }\n    }\n\n    var propName; // Reserved names are extracted\n\n    var props = {};\n    var key = null;\n    var ref = null; // Currently, key can be spread in as a prop. This causes a potential\n    // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n    // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n    // but as an intermediary step, we will use jsxDEV for everything except\n    // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n    // key is explicitly declared to be undefined or not.\n\n    if (maybeKey !== undefined) {\n      {\n        checkKeyStringCoercion(maybeKey);\n      }\n\n      key = '' + maybeKey;\n    }\n\n    if (hasValidKey(config)) {\n      {\n        checkKeyStringCoercion(config.key);\n      }\n\n      key = '' + config.key;\n    }\n\n    if (hasValidRef(config)) {\n      {\n        ref = config.ref;\n      }\n\n      warnIfStringRefCannotBeAutoConverted(config, self);\n    } // Remaining properties are added to a new props object\n\n\n    for (propName in config) {\n      if (hasOwnProperty.call(config, propName) && // Skip over reserved prop names\n      propName !== 'key' && (propName !== 'ref')) {\n        props[propName] = config[propName];\n      }\n    } // Resolve default props\n\n\n    if (type && type.defaultProps) {\n      var defaultProps = type.defaultProps;\n\n      for (propName in defaultProps) {\n        if (props[propName] === undefined) {\n          props[propName] = defaultProps[propName];\n        }\n      }\n    }\n\n    if (key || ref) {\n      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\n\n      if (key) {\n        defineKeyPropWarningGetter(props, displayName);\n      }\n\n      if (ref) {\n        defineRefPropWarningGetter(props, displayName);\n      }\n    }\n\n    var element = ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\n\n    if (type === REACT_FRAGMENT_TYPE) {\n      validateFragmentProps(element);\n    }\n\n    return element;\n  }\n}\n\nfunction getDeclarationErrorAddendum() {\n  {\n    if (ReactCurrentOwner.current) {\n      var name = getComponentNameFromType(ReactCurrentOwner.current.type);\n\n      if (name) {\n        return '\\n\\nCheck the render method of `' + name + '`.';\n      }\n    }\n\n    return '';\n  }\n}\n/**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */\n\n\nfunction validateChildKeys(node, parentType) {\n  {\n    if (typeof node !== 'object' || !node) {\n      return;\n    }\n\n    if (node.$$typeof === REACT_CLIENT_REFERENCE) ; else if (isArray(node)) {\n      for (var i = 0; i < node.length; i++) {\n        var child = node[i];\n\n        if (isValidElement(child)) {\n          validateExplicitKey(child, parentType);\n        }\n      }\n    } else if (isValidElement(node)) {\n      // This element was passed in a valid location.\n      if (node._store) {\n        node._store.validated = true;\n      }\n    } else {\n      var iteratorFn = getIteratorFn(node);\n\n      if (typeof iteratorFn === 'function') {\n        // Entry iterators used to provide implicit keys,\n        // but now we print a separate warning for them later.\n        if (iteratorFn !== node.entries) {\n          var iterator = iteratorFn.call(node);\n          var step;\n\n          while (!(step = iterator.next()).done) {\n            if (isValidElement(step.value)) {\n              validateExplicitKey(step.value, parentType);\n            }\n          }\n        }\n      }\n    }\n  }\n}\n/**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */\n\n\nfunction isValidElement(object) {\n  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n}\nvar ownerHasKeyUseWarning = {};\n/**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */\n\nfunction validateExplicitKey(element, parentType) {\n  {\n    if (!element._store || element._store.validated || element.key != null) {\n      return;\n    }\n\n    element._store.validated = true;\n    var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n\n    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n      return;\n    }\n\n    ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n    // property, it may be the creator of the child that's responsible for\n    // assigning it a key.\n\n    var childOwner = '';\n\n    if (element && element._owner && element._owner !== ReactCurrentOwner.current) {\n      // Give the component that originally created this child.\n      childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\n    }\n\n    setCurrentlyValidatingElement(element);\n\n    error('Each child in a list should have a unique \"key\" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);\n\n    setCurrentlyValidatingElement(null);\n  }\n}\n\nfunction setCurrentlyValidatingElement(element) {\n  {\n    if (element) {\n      var owner = element._owner;\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, owner ? owner.type : null);\n      ReactDebugCurrentFrame.setExtraStackFrame(stack);\n    } else {\n      ReactDebugCurrentFrame.setExtraStackFrame(null);\n    }\n  }\n}\n\nfunction getCurrentComponentErrorInfo(parentType) {\n  {\n    var info = getDeclarationErrorAddendum();\n\n    if (!info) {\n      var parentName = getComponentNameFromType(parentType);\n\n      if (parentName) {\n        info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n      }\n    }\n\n    return info;\n  }\n}\n/**\n * Given a fragment, validate that it can only be provided with fragment props\n * @param {ReactElement} fragment\n */\n\n\nfunction validateFragmentProps(fragment) {\n  // TODO: Move this to render phase instead of at element creation.\n  {\n    var keys = Object.keys(fragment.props);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n\n      if (key !== 'children' && key !== 'key') {\n        setCurrentlyValidatingElement(fragment);\n\n        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);\n\n        setCurrentlyValidatingElement(null);\n        break;\n      }\n    }\n\n    if (fragment.ref !== null) {\n      setCurrentlyValidatingElement(fragment);\n\n      error('Invalid attribute `ref` supplied to `React.Fragment`.');\n\n      setCurrentlyValidatingElement(null);\n    }\n  }\n}\n\nvar jsxDEV = jsxDEV$1 ;\n\nexports.Fragment = REACT_FRAGMENT_TYPE;\nexports.jsxDEV = jsxDEV;\n  })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsSUFBSSxJQUFxQztBQUN6QztBQUNBOztBQUVBLFlBQVksbUJBQU8sQ0FBQyxzR0FBMEI7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDs7QUFFeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlHQUFpRyxlQUFlO0FBQ2hIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQSxLQUFLLEdBQUc7O0FBRVIsa0RBQWtEO0FBQ2xEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLDRCQUE0QjtBQUM1QjtBQUNBLHFDQUFxQzs7QUFFckMsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBOztBQUVBLHFFQUFxRTs7QUFFckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0dBQWtHOztBQUVsRztBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQ0FBaUM7O0FBRWpDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1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O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxXQUFXLEdBQUc7QUFDZCxXQUFXLEdBQUc7QUFDZCxXQUFXLGVBQWU7QUFDMUIsV0FBVyxHQUFHO0FBQ2QsV0FBVyxHQUFHO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtB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QUFXLGNBQWM7QUFDekI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixpQkFBaUI7QUFDckM7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGdCQUFnQjtBQUNoQixjQUFjO0FBQ2QsR0FBRztBQUNIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcz9kYWZmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHJlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0ID0gcmVxdWlyZShcIm5leHQvZGlzdC9jb21waWxlZC9yZWFjdFwiKTtcblxuLy8gQVRURU5USU9OXG4vLyBXaGVuIGFkZGluZyBuZXcgc3ltYm9scyB0byB0aGlzIGZpbGUsXG4vLyBQbGVhc2UgY29uc2lkZXIgYWxzbyBhZGRpbmcgdG8gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC9SZWFjdFN5bWJvbHMnXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy5cbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50Jyk7XG52YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wb3J0YWwnKTtcbnZhciBSRUFDVF9GUkFHTUVOVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZnJhZ21lbnQnKTtcbnZhciBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3RyaWN0X21vZGUnKTtcbnZhciBSRUFDVF9QUk9GSUxFUl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucHJvZmlsZXInKTtcbnZhciBSRUFDVF9QUk9WSURFUl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucHJvdmlkZXInKTsgLy8gVE9ETzogRGVsZXRlIHdpdGggZW5hYmxlUmVuZGVyYWJsZUNvbnRleHRcblxudmFyIFJFQUNUX0NPTlNVTUVSX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5jb25zdW1lcicpO1xudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbnRleHQnKTtcbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZm9yd2FyZF9yZWYnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2UnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZV9saXN0Jyk7XG52YXIgUkVBQ1RfTUVNT19UWVBFID0gU3ltYm9sLmZvcigncmVhY3QubWVtbycpO1xudmFyIFJFQUNUX0xBWllfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmxhenknKTtcbnZhciBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm9mZnNjcmVlbicpO1xudmFyIFJFQUNUX0NBQ0hFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5jYWNoZScpO1xudmFyIE1BWUJFX0lURVJBVE9SX1NZTUJPTCA9IFN5bWJvbC5pdGVyYXRvcjtcbnZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJztcbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICBpZiAobWF5YmVJdGVyYWJsZSA9PT0gbnVsbCB8fCB0eXBlb2YgbWF5YmVJdGVyYWJsZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBtYXliZUl0ZXJhdG9yID0gTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXTtcblxuICBpZiAodHlwZW9mIG1heWJlSXRlcmF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbWF5YmVJdGVyYXRvcjtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPSBSZWFjdC5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDtcblxuZnVuY3Rpb24gZXJyb3IoZm9ybWF0KSB7XG4gIHtcbiAgICB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICBwcmludFdhcm5pbmcoJ2Vycm9yJywgZm9ybWF0LCBhcmdzKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJpbnRXYXJuaW5nKGxldmVsLCBmb3JtYXQsIGFyZ3MpIHtcbiAgLy8gV2hlbiBjaGFuZ2luZyB0aGlzIGxvZ2ljLCB5b3UgbWlnaHQgd2FudCB0byBhbHNvXG4gIC8vIHVwZGF0ZSBjb25zb2xlV2l0aFN0YWNrRGV2Lnd3dy5qcyBhcyB3ZWxsLlxuICB7XG4gICAgdmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuICAgIHZhciBzdGFjayA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpO1xuXG4gICAgaWYgKHN0YWNrICE9PSAnJykge1xuICAgICAgZm9ybWF0ICs9ICclcyc7XG4gICAgICBhcmdzID0gYXJncy5jb25jYXQoW3N0YWNrXSk7XG4gICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cblxuXG4gICAgdmFyIGFyZ3NXaXRoRm9ybWF0ID0gYXJncy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiBTdHJpbmcoaXRlbSk7XG4gICAgfSk7IC8vIENhcmVmdWw6IFJOIGN1cnJlbnRseSBkZXBlbmRzIG9uIHRoaXMgcHJlZml4XG5cbiAgICBhcmdzV2l0aEZvcm1hdC51bnNoaWZ0KCdXYXJuaW5nOiAnICsgZm9ybWF0KTsgLy8gV2UgaW50ZW50aW9uYWxseSBkb24ndCB1c2Ugc3ByZWFkIChvciAuYXBwbHkpIGRpcmVjdGx5IGJlY2F1c2UgaXRcbiAgICAvLyBicmVha3MgSUU5OiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEzNjEwXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZ1xuXG4gICAgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZVtsZXZlbF0sIGNvbnNvbGUsIGFyZ3NXaXRoRm9ybWF0KTtcbiAgfVxufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG52YXIgZW5hYmxlU2NvcGVBUEkgPSBmYWxzZTsgLy8gRXhwZXJpbWVudGFsIENyZWF0ZSBFdmVudCBIYW5kbGUgQVBJLlxudmFyIGVuYWJsZUNhY2hlRWxlbWVudCA9IGZhbHNlO1xudmFyIGVuYWJsZVRyYW5zaXRpb25UcmFjaW5nID0gZmFsc2U7IC8vIE5vIGtub3duIGJ1Z3MsIGJ1dCBuZWVkcyBwZXJmb3JtYW5jZSB0ZXN0aW5nXG5cbnZhciBlbmFibGVMZWdhY3lIaWRkZW4gPSBmYWxzZTsgLy8gRW5hYmxlcyB1bnN0YWJsZV9hdm9pZFRoaXNGYWxsYmFjayBmZWF0dXJlIGluIEZpYmVyXG52YXIgZW5hYmxlUmVuZGVyYWJsZUNvbnRleHQgPSBmYWxzZTtcbi8vIHN0dWZmLiBJbnRlbmRlZCB0byBlbmFibGUgUmVhY3QgY29yZSBtZW1iZXJzIHRvIG1vcmUgZWFzaWx5IGRlYnVnIHNjaGVkdWxpbmdcbi8vIGlzc3VlcyBpbiBERVYgYnVpbGRzLlxuXG52YXIgZW5hYmxlRGVidWdUcmFjaW5nID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGdldFdyYXBwZWROYW1lKG91dGVyVHlwZSwgaW5uZXJUeXBlLCB3cmFwcGVyTmFtZSkge1xuICB2YXIgZGlzcGxheU5hbWUgPSBvdXRlclR5cGUuZGlzcGxheU5hbWU7XG5cbiAgaWYgKGRpc3BsYXlOYW1lKSB7XG4gICAgcmV0dXJuIGRpc3BsYXlOYW1lO1xuICB9XG5cbiAgdmFyIGZ1bmN0aW9uTmFtZSA9IGlubmVyVHlwZS5kaXNwbGF5TmFtZSB8fCBpbm5lclR5cGUubmFtZSB8fCAnJztcbiAgcmV0dXJuIGZ1bmN0aW9uTmFtZSAhPT0gJycgPyB3cmFwcGVyTmFtZSArIFwiKFwiICsgZnVuY3Rpb25OYW1lICsgXCIpXCIgOiB3cmFwcGVyTmFtZTtcbn0gLy8gS2VlcCBpbiBzeW5jIHdpdGggcmVhY3QtcmVjb25jaWxlci9nZXRDb21wb25lbnROYW1lRnJvbUZpYmVyXG5cblxuZnVuY3Rpb24gZ2V0Q29udGV4dE5hbWUodHlwZSkge1xuICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCAnQ29udGV4dCc7XG59XG5cbnZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDIgPSBTeW1ib2wuZm9yKCdyZWFjdC5jbGllbnQucmVmZXJlbmNlJyk7IC8vIE5vdGUgdGhhdCB0aGUgcmVjb25jaWxlciBwYWNrYWdlIHNob3VsZCBnZW5lcmFsbHkgcHJlZmVyIHRvIHVzZSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKCkgaW5zdGVhZC5cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIC8vIEhvc3Qgcm9vdCwgdGV4dCBub2RlIG9yIGp1c3QgaW52YWxpZCB0eXBlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMikge1xuICAgICAgLy8gVE9ETzogQ3JlYXRlIGEgY29udmVudGlvbiBmb3IgbmFtaW5nIGNsaWVudCByZWZlcmVuY2VzIHdpdGggZGVidWcgaW5mby5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgcmV0dXJuICdGcmFnbWVudCc7XG5cbiAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgcmV0dXJuICdQb3J0YWwnO1xuXG4gICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgcmV0dXJuICdQcm9maWxlcic7XG5cbiAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N0cmljdE1vZGUnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2VMaXN0JztcblxuICAgIGNhc2UgUkVBQ1RfQ0FDSEVfVFlQRTpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuICdDYWNoZSc7XG4gICAgICB9XG5cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICB7XG4gICAgICBpZiAodHlwZW9mIHR5cGUudGFnID09PSAnbnVtYmVyJykge1xuICAgICAgICBlcnJvcignUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKCkuICcgKyAnVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHByb3ZpZGVyID0gdHlwZTtcbiAgICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUocHJvdmlkZXIuX2NvbnRleHQpICsgJy5Qcm92aWRlcic7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgIHZhciBjb250ZXh0ID0gdHlwZTtcblxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKGNvbnRleHQpICsgJy5Db25zdW1lcic7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9DT05TVU1FUl9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZ2V0V3JhcHBlZE5hbWUodHlwZSwgdHlwZS5yZW5kZXIsICdGb3J3YXJkUmVmJyk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICB2YXIgb3V0ZXJOYW1lID0gdHlwZS5kaXNwbGF5TmFtZSB8fCBudWxsO1xuXG4gICAgICAgIGlmIChvdXRlck5hbWUgIT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gb3V0ZXJOYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdNZW1vJztcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGluaXQocGF5bG9hZCkpO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG4vLyAkRmxvd0ZpeE1lW21ldGhvZC11bmJpbmRpbmddXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgYXNzaWduID0gT2JqZWN0LmFzc2lnbjtcblxuLypcbiAqIFRoZSBgJycgKyB2YWx1ZWAgcGF0dGVybiAodXNlZCBpbiBwZXJmLXNlbnNpdGl2ZSBjb2RlKSB0aHJvd3MgZm9yIFN5bWJvbFxuICogYW5kIFRlbXBvcmFsLiogdHlwZXMuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC8yMjA2NC5cbiAqXG4gKiBUaGUgZnVuY3Rpb25zIGluIHRoaXMgbW9kdWxlIHdpbGwgdGhyb3cgYW4gZWFzaWVyLXRvLXVuZGVyc3RhbmQsXG4gKiBlYXNpZXItdG8tZGVidWcgZXhjZXB0aW9uIHdpdGggYSBjbGVhciBlcnJvcnMgbWVzc2FnZSBtZXNzYWdlIGV4cGxhaW5pbmcgdGhlXG4gKiBwcm9ibGVtLiAoSW5zdGVhZCBvZiBhIGNvbmZ1c2luZyBleGNlcHRpb24gdGhyb3duIGluc2lkZSB0aGUgaW1wbGVtZW50YXRpb25cbiAqIG9mIHRoZSBgdmFsdWVgIG9iamVjdCkuXG4gKi9cbi8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl0gb25seSBjYWxsZWQgaW4gREVWLCBzbyB2b2lkIHJldHVybiBpcyBub3QgcG9zc2libGUuXG5mdW5jdGlvbiB0eXBlTmFtZSh2YWx1ZSkge1xuICB7XG4gICAgLy8gdG9TdHJpbmdUYWcgaXMgbmVlZGVkIGZvciBuYW1lc3BhY2VkIHR5cGVzIGxpa2UgVGVtcG9yYWwuSW5zdGFudFxuICAgIHZhciBoYXNUb1N0cmluZ1RhZyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLnRvU3RyaW5nVGFnO1xuICAgIHZhciB0eXBlID0gaGFzVG9TdHJpbmdUYWcgJiYgdmFsdWVbU3ltYm9sLnRvU3RyaW5nVGFnXSB8fCB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lIHx8ICdPYmplY3QnOyAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dXG5cbiAgICByZXR1cm4gdHlwZTtcbiAgfVxufSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dIG9ubHkgY2FsbGVkIGluIERFViwgc28gdm9pZCByZXR1cm4gaXMgbm90IHBvc3NpYmxlLlxuXG5cbmZ1bmN0aW9uIHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSB7XG4gIHtcbiAgICB0cnkge1xuICAgICAgdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gIC8vIElmIHlvdSBlbmRlZCB1cCBoZXJlIGJ5IGZvbGxvd2luZyBhbiBleGNlcHRpb24gY2FsbCBzdGFjaywgaGVyZSdzIHdoYXQnc1xuICAvLyBoYXBwZW5lZDogeW91IHN1cHBsaWVkIGFuIG9iamVjdCBvciBzeW1ib2wgdmFsdWUgdG8gUmVhY3QgKGFzIGEgcHJvcCwga2V5LFxuICAvLyBET00gYXR0cmlidXRlLCBDU1MgcHJvcGVydHksIHN0cmluZyByZWYsIGV0Yy4pIGFuZCB3aGVuIFJlYWN0IHRyaWVkIHRvXG4gIC8vIGNvZXJjZSBpdCB0byBhIHN0cmluZyB1c2luZyBgJycgKyB2YWx1ZWAsIGFuIGV4Y2VwdGlvbiB3YXMgdGhyb3duLlxuICAvL1xuICAvLyBUaGUgbW9zdCBjb21tb24gdHlwZXMgdGhhdCB3aWxsIGNhdXNlIHRoaXMgZXhjZXB0aW9uIGFyZSBgU3ltYm9sYCBpbnN0YW5jZXNcbiAgLy8gYW5kIFRlbXBvcmFsIG9iamVjdHMgbGlrZSBgVGVtcG9yYWwuSW5zdGFudGAuIEJ1dCBhbnkgb2JqZWN0IHRoYXQgaGFzIGFcbiAgLy8gYHZhbHVlT2ZgIG9yIGBbU3ltYm9sLnRvUHJpbWl0aXZlXWAgbWV0aG9kIHRoYXQgdGhyb3dzIHdpbGwgYWxzbyBjYXVzZSB0aGlzXG4gIC8vIGV4Y2VwdGlvbi4gKExpYnJhcnkgYXV0aG9ycyBkbyB0aGlzIHRvIHByZXZlbnQgdXNlcnMgZnJvbSB1c2luZyBidWlsdC1pblxuICAvLyBudW1lcmljIG9wZXJhdG9ycyBsaWtlIGArYCBvciBjb21wYXJpc29uIG9wZXJhdG9ycyBsaWtlIGA+PWAgYmVjYXVzZSBjdXN0b21cbiAgLy8gbWV0aG9kcyBhcmUgbmVlZGVkIHRvIHBlcmZvcm0gYWNjdXJhdGUgYXJpdGhtZXRpYyBvciBjb21wYXJpc29uLilcbiAgLy9cbiAgLy8gVG8gZml4IHRoZSBwcm9ibGVtLCBjb2VyY2UgdGhpcyBvYmplY3Qgb3Igc3ltYm9sIHZhbHVlIHRvIGEgc3RyaW5nIGJlZm9yZVxuICAvLyBwYXNzaW5nIGl0IHRvIFJlYWN0LiBUaGUgbW9zdCByZWxpYWJsZSB3YXkgaXMgdXN1YWxseSBgU3RyaW5nKHZhbHVlKWAuXG4gIC8vXG4gIC8vIFRvIGZpbmQgd2hpY2ggdmFsdWUgaXMgdGhyb3dpbmcsIGNoZWNrIHRoZSBicm93c2VyIG9yIGRlYnVnZ2VyIGNvbnNvbGUuXG4gIC8vIEJlZm9yZSB0aGlzIGV4Y2VwdGlvbiB3YXMgdGhyb3duLCB0aGVyZSBzaG91bGQgYmUgYGNvbnNvbGUuZXJyb3JgIG91dHB1dFxuICAvLyB0aGF0IHNob3dzIHRoZSB0eXBlIChTeW1ib2wsIFRlbXBvcmFsLlBsYWluRGF0ZSwgZXRjLikgdGhhdCBjYXVzZWQgdGhlXG4gIC8vIHByb2JsZW0gYW5kIGhvdyB0aGF0IHR5cGUgd2FzIHVzZWQ6IGtleSwgYXRycmlidXRlLCBpbnB1dCB2YWx1ZSBwcm9wLCBldGMuXG4gIC8vIEluIG1vc3QgY2FzZXMsIHRoaXMgY29uc29sZSBvdXRwdXQgYWxzbyBzaG93cyB0aGUgY29tcG9uZW50IGFuZCBpdHNcbiAgLy8gYW5jZXN0b3IgY29tcG9uZW50cyB3aGVyZSB0aGUgZXhjZXB0aW9uIGhhcHBlbmVkLlxuICAvL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cbiAgcmV0dXJuICcnICsgdmFsdWU7XG59XG5mdW5jdGlvbiBjaGVja0tleVN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gIHtcbiAgICBpZiAod2lsbENvZXJjaW9uVGhyb3codmFsdWUpKSB7XG4gICAgICBlcnJvcignVGhlIHByb3ZpZGVkIGtleSBpcyBhbiB1bnN1cHBvcnRlZCB0eXBlICVzLicgKyAnIFRoaXMgdmFsdWUgbXVzdCBiZSBjb2VyY2VkIHRvIGEgc3RyaW5nIGJlZm9yZSB1c2luZyBpdCBoZXJlLicsIHR5cGVOYW1lKHZhbHVlKSk7XG5cbiAgICAgIHJldHVybiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpOyAvLyB0aHJvdyAodG8gaGVscCBjYWxsZXJzIGZpbmQgdHJvdWJsZXNob290aW5nIGNvbW1lbnRzKVxuICAgIH1cbiAgfVxufVxuXG52YXIgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSQxID0gU3ltYm9sLmZvcigncmVhY3QuY2xpZW50LnJlZmVyZW5jZScpO1xuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIE5vdGU6IHR5cGVvZiBtaWdodCBiZSBvdGhlciB0aGFuICdzeW1ib2wnIG9yICdudW1iZXInIChlLmcuIGlmIGl0J3MgYSBwb2x5ZmlsbCkuXG5cblxuICBpZiAodHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFIHx8IGVuYWJsZURlYnVnVHJhY2luZyAgfHwgdHlwZSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSB8fCBlbmFibGVMZWdhY3lIaWRkZW4gIHx8IHR5cGUgPT09IFJFQUNUX09GRlNDUkVFTl9UWVBFIHx8IGVuYWJsZVNjb3BlQVBJICB8fCBlbmFibGVDYWNoZUVsZW1lbnQgIHx8IGVuYWJsZVRyYW5zaXRpb25UcmFjaW5nICkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsKSB7XG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1BST1ZJREVSX1RZUEUgfHwgZW5hYmxlUmVuZGVyYWJsZUNvbnRleHQgIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgLy8gVGhpcyBuZWVkcyB0byBpbmNsdWRlIGFsbCBwb3NzaWJsZSBtb2R1bGUgcmVmZXJlbmNlIG9iamVjdFxuICAgIC8vIHR5cGVzIHN1cHBvcnRlZCBieSBhbnkgRmxpZ2h0IGNvbmZpZ3VyYXRpb24gYW55d2hlcmUgc2luY2VcbiAgICAvLyB3ZSBkb24ndCBrbm93IHdoaWNoIEZsaWdodCBidWlsZCB0aGlzIHdpbGwgZW5kIHVwIGJlaW5nIHVzZWRcbiAgICAvLyB3aXRoLlxuICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMSB8fCB0eXBlLmdldE1vZHVsZUlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxudmFyIGlzQXJyYXlJbXBsID0gQXJyYXkuaXNBcnJheTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxuXG5mdW5jdGlvbiBpc0FycmF5KGEpIHtcbiAgcmV0dXJuIGlzQXJyYXlJbXBsKGEpO1xufVxuXG4vLyBIZWxwZXJzIHRvIHBhdGNoIGNvbnNvbGUubG9ncyB0byBhdm9pZCBsb2dnaW5nIGR1cmluZyBzaWRlLWVmZmVjdCBmcmVlXG4vLyByZXBsYXlpbmcgb24gcmVuZGVyIGZ1bmN0aW9uLiBUaGlzIGN1cnJlbnRseSBvbmx5IHBhdGNoZXMgdGhlIG9iamVjdFxuLy8gbGF6aWx5IHdoaWNoIHdvbid0IGNvdmVyIGlmIHRoZSBsb2cgZnVuY3Rpb24gd2FzIGV4dHJhY3RlZCBlYWdlcmx5LlxuLy8gV2UgY291bGQgYWxzbyBlYWdlcmx5IHBhdGNoIHRoZSBtZXRob2QuXG52YXIgZGlzYWJsZWREZXB0aCA9IDA7XG52YXIgcHJldkxvZztcbnZhciBwcmV2SW5mbztcbnZhciBwcmV2V2FybjtcbnZhciBwcmV2RXJyb3I7XG52YXIgcHJldkdyb3VwO1xudmFyIHByZXZHcm91cENvbGxhcHNlZDtcbnZhciBwcmV2R3JvdXBFbmQ7XG5cbmZ1bmN0aW9uIGRpc2FibGVkTG9nKCkge31cblxuZGlzYWJsZWRMb2cuX19yZWFjdERpc2FibGVkTG9nID0gdHJ1ZTtcbmZ1bmN0aW9uIGRpc2FibGVMb2dzKCkge1xuICB7XG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgcHJldkxvZyA9IGNvbnNvbGUubG9nO1xuICAgICAgcHJldkluZm8gPSBjb25zb2xlLmluZm87XG4gICAgICBwcmV2V2FybiA9IGNvbnNvbGUud2FybjtcbiAgICAgIHByZXZFcnJvciA9IGNvbnNvbGUuZXJyb3I7XG4gICAgICBwcmV2R3JvdXAgPSBjb25zb2xlLmdyb3VwO1xuICAgICAgcHJldkdyb3VwQ29sbGFwc2VkID0gY29uc29sZS5ncm91cENvbGxhcHNlZDtcbiAgICAgIHByZXZHcm91cEVuZCA9IGNvbnNvbGUuZ3JvdXBFbmQ7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTkwOTlcblxuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBkaXNhYmxlZExvZyxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBpbmZvOiBwcm9wcyxcbiAgICAgICAgbG9nOiBwcm9wcyxcbiAgICAgICAgd2FybjogcHJvcHMsXG4gICAgICAgIGVycm9yOiBwcm9wcyxcbiAgICAgICAgZ3JvdXA6IHByb3BzLFxuICAgICAgICBncm91cENvbGxhcHNlZDogcHJvcHMsXG4gICAgICAgIGdyb3VwRW5kOiBwcm9wc1xuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGRpc2FibGVkRGVwdGgrKztcbiAgfVxufVxuZnVuY3Rpb24gcmVlbmFibGVMb2dzKCkge1xuICB7XG4gICAgZGlzYWJsZWREZXB0aC0tO1xuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lW2Nhbm5vdC13cml0ZV0gRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgbG9nOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZMb2dcbiAgICAgICAgfSksXG4gICAgICAgIGluZm86IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkluZm9cbiAgICAgICAgfSksXG4gICAgICAgIHdhcm46IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldldhcm5cbiAgICAgICAgfSksXG4gICAgICAgIGVycm9yOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZFcnJvclxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXA6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cENvbGxhcHNlZDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBDb2xsYXBzZWRcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwRW5kOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cEVuZFxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGlmIChkaXNhYmxlZERlcHRoIDwgMCkge1xuICAgICAgZXJyb3IoJ2Rpc2FibGVkRGVwdGggZmVsbCBiZWxvdyB6ZXJvLiAnICsgJ1RoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudERpc3BhdGNoZXI7XG52YXIgcHJlZml4O1xuZnVuY3Rpb24gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSwgb3duZXJGbikge1xuICB7XG4gICAgaWYgKHByZWZpeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBFeHRyYWN0IHRoZSBWTSBzcGVjaWZpYyBwcmVmaXggdXNlZCBieSBlYWNoIGxpbmUuXG4gICAgICB0cnkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICB2YXIgbWF0Y2ggPSB4LnN0YWNrLnRyaW0oKS5tYXRjaCgvXFxuKCAqKGF0ICk/KS8pO1xuICAgICAgICBwcmVmaXggPSBtYXRjaCAmJiBtYXRjaFsxXSB8fCAnJztcbiAgICAgIH1cbiAgICB9IC8vIFdlIHVzZSB0aGUgcHJlZml4IHRvIGVuc3VyZSBvdXIgc3RhY2tzIGxpbmUgdXAgd2l0aCBuYXRpdmUgc3RhY2sgZnJhbWVzLlxuXG5cbiAgICByZXR1cm4gJ1xcbicgKyBwcmVmaXggKyBuYW1lO1xuICB9XG59XG52YXIgcmVlbnRyeSA9IGZhbHNlO1xudmFyIGNvbXBvbmVudEZyYW1lQ2FjaGU7XG5cbntcbiAgdmFyIFBvc3NpYmx5V2Vha01hcCA9IHR5cGVvZiBXZWFrTWFwID09PSAnZnVuY3Rpb24nID8gV2Vha01hcCA6IE1hcDtcbiAgY29tcG9uZW50RnJhbWVDYWNoZSA9IG5ldyBQb3NzaWJseVdlYWtNYXAoKTtcbn1cbi8qKlxuICogTGV2ZXJhZ2VzIG5hdGl2ZSBicm93c2VyL1ZNIHN0YWNrIGZyYW1lcyB0byBnZXQgcHJvcGVyIGRldGFpbHMgKGUuZy5cbiAqIGZpbGVuYW1lLCBsaW5lICsgY29sIG51bWJlcikgZm9yIGEgc2luZ2xlIGNvbXBvbmVudCBpbiBhIGNvbXBvbmVudCBzdGFjay4gV2VcbiAqIGRvIHRoaXMgYnk6XG4gKiAgICgxKSB0aHJvd2luZyBhbmQgY2F0Y2hpbmcgYW4gZXJyb3IgaW4gdGhlIGZ1bmN0aW9uIC0gdGhpcyB3aWxsIGJlIG91clxuICogICAgICAgY29udHJvbCBlcnJvci5cbiAqICAgKDIpIGNhbGxpbmcgdGhlIGNvbXBvbmVudCB3aGljaCB3aWxsIGV2ZW50dWFsbHkgdGhyb3cgYW4gZXJyb3IgdGhhdCB3ZSdsbFxuICogICAgICAgY2F0Y2ggLSB0aGlzIHdpbGwgYmUgb3VyIHNhbXBsZSBlcnJvci5cbiAqICAgKDMpIGRpZmZpbmcgdGhlIGNvbnRyb2wgYW5kIHNhbXBsZSBlcnJvciBzdGFja3MgdG8gZmluZCB0aGUgc3RhY2sgZnJhbWVcbiAqICAgICAgIHdoaWNoIHJlcHJlc2VudHMgb3VyIGNvbXBvbmVudC5cbiAqL1xuXG5cbmZ1bmN0aW9uIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGNvbnN0cnVjdCkge1xuICAvLyBJZiBzb21ldGhpbmcgYXNrZWQgZm9yIGEgc3RhY2sgaW5zaWRlIGEgZmFrZSByZW5kZXIsIGl0IHNob3VsZCBnZXQgaWdub3JlZC5cbiAgaWYgKCFmbiB8fCByZWVudHJ5KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAge1xuICAgIHZhciBmcmFtZSA9IGNvbXBvbmVudEZyYW1lQ2FjaGUuZ2V0KGZuKTtcblxuICAgIGlmIChmcmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZnJhbWU7XG4gICAgfVxuICB9XG5cbiAgcmVlbnRyeSA9IHRydWU7XG4gIHZhciBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlID0gRXJyb3IucHJlcGFyZVN0YWNrVHJhY2U7IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXR5cGVdIEl0IGRvZXMgYWNjZXB0IHVuZGVmaW5lZC5cblxuICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHVuZGVmaW5lZDtcbiAgdmFyIHByZXZpb3VzRGlzcGF0Y2hlcjtcblxuICB7XG4gICAgcHJldmlvdXNEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50OyAvLyBTZXQgdGhlIGRpc3BhdGNoZXIgaW4gREVWIGJlY2F1c2UgdGhpcyBtaWdodCBiZSBjYWxsIGluIHRoZSByZW5kZXIgZnVuY3Rpb25cbiAgICAvLyBmb3Igd2FybmluZ3MuXG5cbiAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBudWxsO1xuICAgIGRpc2FibGVMb2dzKCk7XG4gIH1cbiAgLyoqXG4gICAqIEZpbmRpbmcgYSBjb21tb24gc3RhY2sgZnJhbWUgYmV0d2VlbiBzYW1wbGUgYW5kIGNvbnRyb2wgZXJyb3JzIGNhbiBiZVxuICAgKiB0cmlja3kgZ2l2ZW4gdGhlIGRpZmZlcmVudCB0eXBlcyBhbmQgbGV2ZWxzIG9mIHN0YWNrIHRyYWNlIHRydW5jYXRpb24gZnJvbVxuICAgKiBkaWZmZXJlbnQgSlMgVk1zLiBTbyBpbnN0ZWFkIHdlJ2xsIGF0dGVtcHQgdG8gY29udHJvbCB3aGF0IHRoYXQgY29tbW9uXG4gICAqIGZyYW1lIHNob3VsZCBiZSB0aHJvdWdoIHRoaXMgb2JqZWN0IG1ldGhvZDpcbiAgICogSGF2aW5nIGJvdGggdGhlIHNhbXBsZSBhbmQgY29udHJvbCBlcnJvcnMgYmUgaW4gdGhlIGZ1bmN0aW9uIHVuZGVyIHRoZVxuICAgKiBgRGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZVJvb3RgIHByb3BlcnR5LCArIHNldHRpbmcgdGhlIGBuYW1lYCBhbmRcbiAgICogYGRpc3BsYXlOYW1lYCBwcm9wZXJ0aWVzIG9mIHRoZSBmdW5jdGlvbiBlbnN1cmVzIHRoYXQgYSBzdGFja1xuICAgKiBmcmFtZSBleGlzdHMgdGhhdCBoYXMgdGhlIG1ldGhvZCBuYW1lIGBEZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lUm9vdGAgaW5cbiAgICogaXQgZm9yIGJvdGggY29udHJvbCBhbmQgc2FtcGxlIHN0YWNrcy5cbiAgICovXG5cblxuICB2YXIgUnVuSW5Sb290RnJhbWUgPSB7XG4gICAgRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY29udHJvbDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gVGhpcyBzaG91bGQgdGhyb3cuXG4gICAgICAgIGlmIChjb25zdHJ1Y3QpIHtcbiAgICAgICAgICAvLyBTb21ldGhpbmcgc2hvdWxkIGJlIHNldHRpbmcgdGhlIHByb3BzIGluIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgICAgICB2YXIgRmFrZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgfTsgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG5cblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGYWtlLnByb3RvdHlwZSwgJ3Byb3BzJywge1xuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIC8vIFdlIHVzZSBhIHRocm93aW5nIHNldHRlciBpbnN0ZWFkIG9mIGZyb3plbiBvciBub24td3JpdGFibGUgcHJvcHNcbiAgICAgICAgICAgICAgLy8gYmVjYXVzZSB0aGF0IHdvbid0IHRocm93IGluIGEgbm9uLXN0cmljdCBtb2RlIGZ1bmN0aW9uLlxuICAgICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyAmJiBSZWZsZWN0LmNvbnN0cnVjdCkge1xuICAgICAgICAgICAgLy8gV2UgY29uc3RydWN0IGEgZGlmZmVyZW50IGNvbnRyb2wgZm9yIHRoaXMgY2FzZSB0byBpbmNsdWRlIGFueSBleHRyYVxuICAgICAgICAgICAgLy8gZnJhbWVzIGFkZGVkIGJ5IHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KEZha2UsIFtdKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KGZuLCBbXSwgRmFrZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIEZha2UuY2FsbCgpO1xuICAgICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgICAgIH0gLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcblxuXG4gICAgICAgICAgICBmbi5jYWxsKEZha2UucHJvdG90eXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgICAgfSAvLyBUT0RPKGx1bmEpOiBUaGlzIHdpbGwgY3VycmVudGx5IG9ubHkgdGhyb3cgaWYgdGhlIGZ1bmN0aW9uIGNvbXBvbmVudFxuICAgICAgICAgIC8vIHRyaWVzIHRvIGFjY2VzcyBSZWFjdC9SZWFjdERPTS9wcm9wcy4gV2Ugc2hvdWxkIHByb2JhYmx5IG1ha2UgdGhpcyB0aHJvd1xuICAgICAgICAgIC8vIGluIHNpbXBsZSBjb21wb25lbnRzIHRvb1xuXG5cbiAgICAgICAgICB2YXIgbWF5YmVQcm9taXNlID0gZm4oKTsgLy8gSWYgdGhlIGZ1bmN0aW9uIGNvbXBvbmVudCByZXR1cm5zIGEgcHJvbWlzZSwgaXQncyBsaWtlbHkgYW4gYXN5bmNcbiAgICAgICAgICAvLyBjb21wb25lbnQsIHdoaWNoIHdlIGRvbid0IHlldCBzdXBwb3J0LiBBdHRhY2ggYSBub29wIGNhdGNoIGhhbmRsZXIgdG9cbiAgICAgICAgICAvLyBzaWxlbmNlIHRoZSBlcnJvci5cbiAgICAgICAgICAvLyBUT0RPOiBJbXBsZW1lbnQgY29tcG9uZW50IHN0YWNrcyBmb3IgYXN5bmMgY2xpZW50IGNvbXBvbmVudHM/XG5cbiAgICAgICAgICBpZiAobWF5YmVQcm9taXNlICYmIHR5cGVvZiBtYXliZVByb21pc2UuY2F0Y2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG1heWJlUHJvbWlzZS5jYXRjaChmdW5jdGlvbiAoKSB7fSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChzYW1wbGUpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBpbmxpbmVkIG1hbnVhbGx5IGJlY2F1c2UgY2xvc3VyZSBkb2Vzbid0IGRvIGl0IGZvciB1cy5cbiAgICAgICAgaWYgKHNhbXBsZSAmJiBjb250cm9sICYmIHR5cGVvZiBzYW1wbGUuc3RhY2sgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgcmV0dXJuIFtzYW1wbGUuc3RhY2ssIGNvbnRyb2wuc3RhY2tdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbbnVsbCwgbnVsbF07XG4gICAgfVxuICB9OyAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cblxuICBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QuZGlzcGxheU5hbWUgPSAnRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290JztcbiAgdmFyIG5hbWVQcm9wRGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290LCAnbmFtZScpOyAvLyBCZWZvcmUgRVM2LCB0aGUgYG5hbWVgIHByb3BlcnR5IHdhcyBub3QgY29uZmlndXJhYmxlLlxuXG4gIGlmIChuYW1lUHJvcERlc2NyaXB0b3IgJiYgbmFtZVByb3BEZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSkge1xuICAgIC8vIFY4IHV0aWxpemVzIGEgZnVuY3Rpb24ncyBgbmFtZWAgcHJvcGVydHkgd2hlbiBnZW5lcmF0aW5nIGEgc3RhY2sgdHJhY2UuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCwgLy8gQ29uZmlndXJhYmxlIHByb3BlcnRpZXMgY2FuIGJlIHVwZGF0ZWQgZXZlbiBpZiBpdHMgd3JpdGFibGUgZGVzY3JpcHRvclxuICAgIC8vIGlzIHNldCB0byBgZmFsc2VgLlxuICAgIC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXVxuICAgICduYW1lJywge1xuICAgICAgdmFsdWU6ICdEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QnXG4gICAgfSk7XG4gIH1cblxuICB0cnkge1xuICAgIHZhciBfUnVuSW5Sb290RnJhbWUkRGV0ZXIgPSBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QoKSxcbiAgICAgICAgc2FtcGxlU3RhY2sgPSBfUnVuSW5Sb290RnJhbWUkRGV0ZXJbMF0sXG4gICAgICAgIGNvbnRyb2xTdGFjayA9IF9SdW5JblJvb3RGcmFtZSREZXRlclsxXTtcblxuICAgIGlmIChzYW1wbGVTdGFjayAmJiBjb250cm9sU3RhY2spIHtcbiAgICAgIC8vIFRoaXMgZXh0cmFjdHMgdGhlIGZpcnN0IGZyYW1lIGZyb20gdGhlIHNhbXBsZSB0aGF0IGlzbid0IGFsc28gaW4gdGhlIGNvbnRyb2wuXG4gICAgICAvLyBTa2lwcGluZyBvbmUgZnJhbWUgdGhhdCB3ZSBhc3N1bWUgaXMgdGhlIGZyYW1lIHRoYXQgY2FsbHMgdGhlIHR3by5cbiAgICAgIHZhciBzYW1wbGVMaW5lcyA9IHNhbXBsZVN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBjb250cm9sTGluZXMgPSBjb250cm9sU3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIHMgPSAwO1xuICAgICAgdmFyIGMgPSAwO1xuXG4gICAgICB3aGlsZSAocyA8IHNhbXBsZUxpbmVzLmxlbmd0aCAmJiAhc2FtcGxlTGluZXNbc10uaW5jbHVkZXMoJ0RldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCcpKSB7XG4gICAgICAgIHMrKztcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKGMgPCBjb250cm9sTGluZXMubGVuZ3RoICYmICFjb250cm9sTGluZXNbY10uaW5jbHVkZXMoJ0RldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCcpKSB7XG4gICAgICAgIGMrKztcbiAgICAgIH0gLy8gV2UgY291bGRuJ3QgZmluZCBvdXIgaW50ZW50aW9uYWxseSBpbmplY3RlZCBjb21tb24gcm9vdCBmcmFtZSwgYXR0ZW1wdFxuICAgICAgLy8gdG8gZmluZCBhbm90aGVyIGNvbW1vbiByb290IGZyYW1lIGJ5IHNlYXJjaCBmcm9tIHRoZSBib3R0b20gb2YgdGhlXG4gICAgICAvLyBjb250cm9sIHN0YWNrLi4uXG5cblxuICAgICAgaWYgKHMgPT09IHNhbXBsZUxpbmVzLmxlbmd0aCB8fCBjID09PSBjb250cm9sTGluZXMubGVuZ3RoKSB7XG4gICAgICAgIHMgPSBzYW1wbGVMaW5lcy5sZW5ndGggLSAxO1xuICAgICAgICBjID0gY29udHJvbExpbmVzLmxlbmd0aCAtIDE7XG5cbiAgICAgICAgd2hpbGUgKHMgPj0gMSAmJiBjID49IDAgJiYgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgIC8vIFdlIGV4cGVjdCBhdCBsZWFzdCBvbmUgc3RhY2sgZnJhbWUgdG8gYmUgc2hhcmVkLlxuICAgICAgICAgIC8vIFR5cGljYWxseSB0aGlzIHdpbGwgYmUgdGhlIHJvb3QgbW9zdCBvbmUuIEhvd2V2ZXIsIHN0YWNrIGZyYW1lcyBtYXkgYmVcbiAgICAgICAgICAvLyBjdXQgb2ZmIGR1ZSB0byBtYXhpbXVtIHN0YWNrIGxpbWl0cy4gSW4gdGhpcyBjYXNlLCBvbmUgbWF5YmUgY3V0IG9mZlxuICAgICAgICAgIC8vIGVhcmxpZXIgdGhhbiB0aGUgb3RoZXIuIFdlIGFzc3VtZSB0aGF0IHRoZSBzYW1wbGUgaXMgbG9uZ2VyIG9yIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYW5kIHRoZXJlIGZvciBjdXQgb2ZmIGVhcmxpZXIuIFNvIHdlIHNob3VsZCBmaW5kIHRoZSByb290IG1vc3QgZnJhbWUgaW5cbiAgICAgICAgICAvLyB0aGUgc2FtcGxlIHNvbWV3aGVyZSBpbiB0aGUgY29udHJvbC5cbiAgICAgICAgICBjLS07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICg7IHMgPj0gMSAmJiBjID49IDA7IHMtLSwgYy0tKSB7XG4gICAgICAgIC8vIE5leHQgd2UgZmluZCB0aGUgZmlyc3Qgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgd2hpY2ggc2hvdWxkIGJlIHRoZVxuICAgICAgICAvLyBmcmFtZSB0aGF0IGNhbGxlZCBvdXIgc2FtcGxlIGZ1bmN0aW9uIGFuZCB0aGUgY29udHJvbC5cbiAgICAgICAgaWYgKHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAvLyBJbiBWOCwgdGhlIGZpcnN0IGxpbmUgaXMgZGVzY3JpYmluZyB0aGUgbWVzc2FnZSBidXQgb3RoZXIgVk1zIGRvbid0LlxuICAgICAgICAgIC8vIElmIHdlJ3JlIGFib3V0IHRvIHJldHVybiB0aGUgZmlyc3QgbGluZSwgYW5kIHRoZSBjb250cm9sIGlzIGFsc28gb24gdGhlIHNhbWVcbiAgICAgICAgICAvLyBsaW5lLCB0aGF0J3MgYSBwcmV0dHkgZ29vZCBpbmRpY2F0b3IgdGhhdCBvdXIgc2FtcGxlIHRocmV3IGF0IHNhbWUgbGluZSBhc1xuICAgICAgICAgIC8vIHRoZSBjb250cm9sLiBJLmUuIGJlZm9yZSB3ZSBlbnRlcmVkIHRoZSBzYW1wbGUgZnJhbWUuIFNvIHdlIGlnbm9yZSB0aGlzIHJlc3VsdC5cbiAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaWYgeW91IHBhc3NlZCBhIGNsYXNzIHRvIGZ1bmN0aW9uIGNvbXBvbmVudCwgb3Igbm9uLWZ1bmN0aW9uLlxuICAgICAgICAgIGlmIChzICE9PSAxIHx8IGMgIT09IDEpIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgcy0tO1xuICAgICAgICAgICAgICBjLS07IC8vIFdlIG1heSBzdGlsbCBoYXZlIHNpbWlsYXIgaW50ZXJtZWRpYXRlIGZyYW1lcyBmcm9tIHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgICAgICAgLy8gVGhlIG5leHQgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgc2hvdWxkIGJlIG91ciBtYXRjaCB0aG91Z2guXG5cbiAgICAgICAgICAgICAgaWYgKGMgPCAwIHx8IHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAgICAgICAvLyBWOCBhZGRzIGEgXCJuZXdcIiBwcmVmaXggZm9yIG5hdGl2ZSBjbGFzc2VzLiBMZXQncyByZW1vdmUgaXQgdG8gbWFrZSBpdCBwcmV0dGllci5cbiAgICAgICAgICAgICAgICB2YXIgX2ZyYW1lID0gJ1xcbicgKyBzYW1wbGVMaW5lc1tzXS5yZXBsYWNlKCcgYXQgbmV3ICcsICcgYXQgJyk7IC8vIElmIG91ciBjb21wb25lbnQgZnJhbWUgaXMgbGFiZWxlZCBcIjxhbm9ueW1vdXM+XCJcbiAgICAgICAgICAgICAgICAvLyBidXQgd2UgaGF2ZSBhIHVzZXItcHJvdmlkZWQgXCJkaXNwbGF5TmFtZVwiXG4gICAgICAgICAgICAgICAgLy8gc3BsaWNlIGl0IGluIHRvIG1ha2UgdGhlIHN0YWNrIG1vcmUgcmVhZGFibGUuXG5cblxuICAgICAgICAgICAgICAgIGlmIChmbi5kaXNwbGF5TmFtZSAmJiBfZnJhbWUuaW5jbHVkZXMoJzxhbm9ueW1vdXM+JykpIHtcbiAgICAgICAgICAgICAgICAgIF9mcmFtZSA9IF9mcmFtZS5yZXBsYWNlKCc8YW5vbnltb3VzPicsIGZuLmRpc3BsYXlOYW1lKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgX2ZyYW1lKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IC8vIFJldHVybiB0aGUgbGluZSB3ZSBmb3VuZC5cblxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9mcmFtZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgcmVlbnRyeSA9IGZhbHNlO1xuXG4gICAge1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gcHJldmlvdXNEaXNwYXRjaGVyO1xuICAgICAgcmVlbmFibGVMb2dzKCk7XG4gICAgfVxuXG4gICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlO1xuICB9IC8vIEZhbGxiYWNrIHRvIGp1c3QgdXNpbmcgdGhlIG5hbWUgaWYgd2UgY291bGRuJ3QgbWFrZSBpdCB0aHJvdy5cblxuXG4gIHZhciBuYW1lID0gZm4gPyBmbi5kaXNwbGF5TmFtZSB8fCBmbi5uYW1lIDogJyc7XG4gIHZhciBzeW50aGV0aWNGcmFtZSA9IG5hbWUgPyBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lKSA6ICcnO1xuXG4gIHtcbiAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgc3ludGhldGljRnJhbWUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzeW50aGV0aWNGcmFtZTtcbn1cbmZ1bmN0aW9uIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZShmbiwgb3duZXJGbikge1xuICB7XG4gICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGZhbHNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaG91bGRDb25zdHJ1Y3QoQ29tcG9uZW50KSB7XG4gIHZhciBwcm90b3R5cGUgPSBDb21wb25lbnQucHJvdG90eXBlO1xuICByZXR1cm4gISEocHJvdG90eXBlICYmIHByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUsIG93bmVyRm4pIHtcblxuICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAge1xuICAgICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUodHlwZSwgc2hvdWxkQ29uc3RydWN0KHR5cGUpKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKHR5cGUpO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZScpO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlTGlzdCcpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKHR5cGUucmVuZGVyKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIC8vIE1lbW8gbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZS50eXBlLCBvd25lckZuKTtcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBMYXp5IG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihpbml0KHBheWxvYWQpLCBvd25lckZuKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbnZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFID0gU3ltYm9sLmZvcigncmVhY3QuY2xpZW50LnJlZmVyZW5jZScpO1xudmFyIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duO1xudmFyIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duO1xudmFyIGRpZFdhcm5BYm91dFN0cmluZ1JlZnM7XG5cbntcbiAgZGlkV2FybkFib3V0U3RyaW5nUmVmcyA9IHt9O1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZFJlZihjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ3JlZicpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdyZWYnKS5nZXQ7XG5cbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29uZmlnLnJlZiAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZEtleShjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ2tleScpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdrZXknKS5nZXQ7XG5cbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29uZmlnLmtleSAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiB3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQoY29uZmlnLCBzZWxmKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5yZWYgPT09ICdzdHJpbmcnICYmIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgJiYgc2VsZiAmJiBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnN0YXRlTm9kZSAhPT0gc2VsZikge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICAgIGVycm9yKCdDb21wb25lbnQgXCIlc1wiIGNvbnRhaW5zIHRoZSBzdHJpbmcgcmVmIFwiJXNcIi4gJyArICdTdXBwb3J0IGZvciBzdHJpbmcgcmVmcyB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gJyArICdUaGlzIGNhc2UgY2Fubm90IGJlIGF1dG9tYXRpY2FsbHkgY29udmVydGVkIHRvIGFuIGFycm93IGZ1bmN0aW9uLiAnICsgJ1dlIGFzayB5b3UgdG8gbWFudWFsbHkgZml4IHRoaXMgY2FzZSBieSB1c2luZyB1c2VSZWYoKSBvciBjcmVhdGVSZWYoKSBpbnN0ZWFkLiAnICsgJ0xlYXJuIG1vcmUgYWJvdXQgdXNpbmcgcmVmcyBzYWZlbHkgaGVyZTogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3RyaWN0LW1vZGUtc3RyaW5nLXJlZicsIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnR5cGUpLCBjb25maWcucmVmKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHtcbiAgICB2YXIgd2FybkFib3V0QWNjZXNzaW5nS2V5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93bikge1xuICAgICAgICBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biA9IHRydWU7XG5cbiAgICAgICAgZXJyb3IoJyVzOiBga2V5YCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ2tleScsIHtcbiAgICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nS2V5LFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHtcbiAgICB7XG4gICAgICB2YXIgd2FybkFib3V0QWNjZXNzaW5nUmVmID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duKSB7XG4gICAgICAgICAgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgICAgZXJyb3IoJyVzOiBgcmVmYCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAncmVmJywge1xuICAgICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ1JlZixcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogRmFjdG9yeSBtZXRob2QgdG8gY3JlYXRlIGEgbmV3IFJlYWN0IGVsZW1lbnQuIFRoaXMgbm8gbG9uZ2VyIGFkaGVyZXMgdG9cbiAqIHRoZSBjbGFzcyBwYXR0ZXJuLCBzbyBkbyBub3QgdXNlIG5ldyB0byBjYWxsIGl0LiBBbHNvLCBpbnN0YW5jZW9mIGNoZWNrXG4gKiB3aWxsIG5vdCB3b3JrLiBJbnN0ZWFkIHRlc3QgJCR0eXBlb2YgZmllbGQgYWdhaW5zdCBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykgdG8gY2hlY2tcbiAqIGlmIHNvbWV0aGluZyBpcyBhIFJlYWN0IEVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0geyp9IHByb3BzXG4gKiBAcGFyYW0geyp9IGtleVxuICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSByZWZcbiAqIEBwYXJhbSB7Kn0gb3duZXJcbiAqIEBwYXJhbSB7Kn0gc2VsZiBBICp0ZW1wb3JhcnkqIGhlbHBlciB0byBkZXRlY3QgcGxhY2VzIHdoZXJlIGB0aGlzYCBpc1xuICogZGlmZmVyZW50IGZyb20gdGhlIGBvd25lcmAgd2hlbiBSZWFjdC5jcmVhdGVFbGVtZW50IGlzIGNhbGxlZCwgc28gdGhhdCB3ZVxuICogY2FuIHdhcm4uIFdlIHdhbnQgdG8gZ2V0IHJpZCBvZiBvd25lciBhbmQgcmVwbGFjZSBzdHJpbmcgYHJlZmBzIHdpdGggYXJyb3dcbiAqIGZ1bmN0aW9ucywgYW5kIGFzIGxvbmcgYXMgYHRoaXNgIGFuZCBvd25lciBhcmUgdGhlIHNhbWUsIHRoZXJlIHdpbGwgYmUgbm9cbiAqIGNoYW5nZSBpbiBiZWhhdmlvci5cbiAqIEBwYXJhbSB7Kn0gc291cmNlIEFuIGFubm90YXRpb24gb2JqZWN0IChhZGRlZCBieSBhIHRyYW5zcGlsZXIgb3Igb3RoZXJ3aXNlKVxuICogaW5kaWNhdGluZyBmaWxlbmFtZSwgbGluZSBudW1iZXIsIGFuZC9vciBvdGhlciBpbmZvcm1hdGlvbi5cbiAqIEBpbnRlcm5hbFxuICovXG5cblxuZnVuY3Rpb24gUmVhY3RFbGVtZW50KHR5cGUsIGtleSwgX3JlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpIHtcbiAgdmFyIHJlZjtcblxuICB7XG4gICAgcmVmID0gX3JlZjtcbiAgfVxuXG4gIHZhciBlbGVtZW50O1xuXG4gIHtcbiAgICAvLyBJbiBwcm9kLCBgcmVmYCBpcyBhIHJlZ3VsYXIgcHJvcGVydHkuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiBhXG4gICAgLy8gZnV0dXJlIHJlbGVhc2UuXG4gICAgZWxlbWVudCA9IHtcbiAgICAgIC8vIFRoaXMgdGFnIGFsbG93cyB1cyB0byB1bmlxdWVseSBpZGVudGlmeSB0aGlzIGFzIGEgUmVhY3QgRWxlbWVudFxuICAgICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcbiAgICAgIC8vIEJ1aWx0LWluIHByb3BlcnRpZXMgdGhhdCBiZWxvbmcgb24gdGhlIGVsZW1lbnRcbiAgICAgIHR5cGU6IHR5cGUsXG4gICAgICBrZXk6IGtleSxcbiAgICAgIHJlZjogcmVmLFxuICAgICAgcHJvcHM6IHByb3BzLFxuICAgICAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgZWxlbWVudC5cbiAgICAgIF9vd25lcjogb3duZXJcbiAgICB9O1xuICB9XG5cbiAge1xuICAgIC8vIFRoZSB2YWxpZGF0aW9uIGZsYWcgaXMgY3VycmVudGx5IG11dGF0aXZlLiBXZSBwdXQgaXQgb25cbiAgICAvLyBhbiBleHRlcm5hbCBiYWNraW5nIHN0b3JlIHNvIHRoYXQgd2UgY2FuIGZyZWV6ZSB0aGUgd2hvbGUgb2JqZWN0LlxuICAgIC8vIFRoaXMgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBXZWFrTWFwIG9uY2UgdGhleSBhcmUgaW1wbGVtZW50ZWQgaW5cbiAgICAvLyBjb21tb25seSB1c2VkIGRldmVsb3BtZW50IGVudmlyb25tZW50cy5cbiAgICBlbGVtZW50Ll9zdG9yZSA9IHt9OyAvLyBUbyBtYWtlIGNvbXBhcmluZyBSZWFjdEVsZW1lbnRzIGVhc2llciBmb3IgdGVzdGluZyBwdXJwb3Nlcywgd2UgbWFrZVxuICAgIC8vIHRoZSB2YWxpZGF0aW9uIGZsYWcgbm9uLWVudW1lcmFibGUgKHdoZXJlIHBvc3NpYmxlLCB3aGljaCBzaG91bGRcbiAgICAvLyBpbmNsdWRlIGV2ZXJ5IGVudmlyb25tZW50IHdlIHJ1biB0ZXN0cyBpbiksIHNvIHRoZSB0ZXN0IGZyYW1ld29ya1xuICAgIC8vIGlnbm9yZXMgaXQuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudC5fc3RvcmUsICd2YWxpZGF0ZWQnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0pOyAvLyBkZWJ1Z0luZm8gY29udGFpbnMgU2VydmVyIENvbXBvbmVudCBkZWJ1ZyBpbmZvcm1hdGlvbi5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX2RlYnVnSW5mbycsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IG51bGxcbiAgICB9KTtcblxuICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQucHJvcHMpO1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn1cbnZhciBkaWRXYXJuQWJvdXRLZXlTcHJlYWQgPSB7fTtcbi8qKlxuICogaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0anMvcmZjcy9wdWxsLzEwN1xuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqL1xuXG5mdW5jdGlvbiBqc3hERVYkMSh0eXBlLCBjb25maWcsIG1heWJlS2V5LCBpc1N0YXRpY0NoaWxkcmVuLCBzb3VyY2UsIHNlbGYpIHtcbiAge1xuICAgIGlmICghaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpKSB7XG4gICAgICAvLyBUaGlzIGlzIGFuIGludmFsaWQgZWxlbWVudCB0eXBlLlxuICAgICAgLy9cbiAgICAgIC8vIFdlIHdhcm4gaW4gdGhpcyBjYXNlIGJ1dCBkb24ndCB0aHJvdy4gV2UgZXhwZWN0IHRoZSBlbGVtZW50IGNyZWF0aW9uIHRvXG4gICAgICAvLyBzdWNjZWVkIGFuZCB0aGVyZSB3aWxsIGxpa2VseSBiZSBlcnJvcnMgaW4gcmVuZGVyLlxuICAgICAgdmFyIGluZm8gPSAnJztcblxuICAgICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiBPYmplY3Qua2V5cyh0eXBlKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgaW5mbyArPSAnIFlvdSBsaWtlbHkgZm9yZ290IHRvIGV4cG9ydCB5b3VyIGNvbXBvbmVudCBmcm9tIHRoZSBmaWxlICcgKyBcIml0J3MgZGVmaW5lZCBpbiwgb3IgeW91IG1pZ2h0IGhhdmUgbWl4ZWQgdXAgZGVmYXVsdCBhbmQgbmFtZWQgaW1wb3J0cy5cIjtcbiAgICAgIH1cblxuICAgICAgdmFyIHR5cGVTdHJpbmc7XG5cbiAgICAgIGlmICh0eXBlID09PSBudWxsKSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSAnbnVsbCc7XG4gICAgICB9IGVsc2UgaWYgKGlzQXJyYXkodHlwZSkpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9ICdhcnJheSc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9IFwiPFwiICsgKGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdVbmtub3duJykgKyBcIiAvPlwiO1xuICAgICAgICBpbmZvID0gJyBEaWQgeW91IGFjY2lkZW50YWxseSBleHBvcnQgYSBKU1ggbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY29tcG9uZW50Pyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eXBlU3RyaW5nID0gdHlwZW9mIHR5cGU7XG4gICAgICB9XG5cbiAgICAgIGVycm9yKCdSZWFjdC5qc3g6IHR5cGUgaXMgaW52YWxpZCAtLSBleHBlY3RlZCBhIHN0cmluZyAoZm9yICcgKyAnYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSAnICsgJ2NvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzJywgdHlwZVN0cmluZywgaW5mbyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoaXMgaXMgYSB2YWxpZCBlbGVtZW50IHR5cGUuXG4gICAgICAvLyBTa2lwIGtleSB3YXJuaW5nIGlmIHRoZSB0eXBlIGlzbid0IHZhbGlkIHNpbmNlIG91ciBrZXkgdmFsaWRhdGlvbiBsb2dpY1xuICAgICAgLy8gZG9lc24ndCBleHBlY3QgYSBub24tc3RyaW5nL2Z1bmN0aW9uIHR5cGUgYW5kIGNhbiB0aHJvdyBjb25mdXNpbmdcbiAgICAgIC8vIGVycm9ycy4gV2UgZG9uJ3Qgd2FudCBleGNlcHRpb24gYmVoYXZpb3IgdG8gZGlmZmVyIGJldHdlZW4gZGV2IGFuZFxuICAgICAgLy8gcHJvZC4gKFJlbmRlcmluZyB3aWxsIHRocm93IHdpdGggYSBoZWxwZnVsIG1lc3NhZ2UgYW5kIGFzIHNvb24gYXMgdGhlXG4gICAgICAvLyB0eXBlIGlzIGZpeGVkLCB0aGUga2V5IHdhcm5pbmdzIHdpbGwgYXBwZWFyLilcbiAgICAgIHZhciBjaGlsZHJlbiA9IGNvbmZpZy5jaGlsZHJlbjtcblxuICAgICAgaWYgKGNoaWxkcmVuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGlzU3RhdGljQ2hpbGRyZW4pIHtcbiAgICAgICAgICBpZiAoaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW5baV0sIHR5cGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgICAgICAgICBPYmplY3QuZnJlZXplKGNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXJyb3IoJ1JlYWN0LmpzeDogU3RhdGljIGNoaWxkcmVuIHNob3VsZCBhbHdheXMgYmUgYW4gYXJyYXkuICcgKyAnWW91IGFyZSBsaWtlbHkgZXhwbGljaXRseSBjYWxsaW5nIFJlYWN0LmpzeHMgb3IgUmVhY3QuanN4REVWLiAnICsgJ1VzZSB0aGUgQmFiZWwgdHJhbnNmb3JtIGluc3RlYWQuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuLCB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gLy8gV2FybiBhYm91dCBrZXkgc3ByZWFkIHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB0aGUgdHlwZSBpcyB2YWxpZC5cblxuXG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAna2V5JykpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhjb25maWcpLmZpbHRlcihmdW5jdGlvbiAoaykge1xuICAgICAgICByZXR1cm4gayAhPT0gJ2tleSc7XG4gICAgICB9KTtcbiAgICAgIHZhciBiZWZvcmVFeGFtcGxlID0ga2V5cy5sZW5ndGggPiAwID8gJ3trZXk6IHNvbWVLZXksICcgKyBrZXlzLmpvaW4oJzogLi4uLCAnKSArICc6IC4uLn0nIDogJ3trZXk6IHNvbWVLZXl9JztcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRLZXlTcHJlYWRbY29tcG9uZW50TmFtZSArIGJlZm9yZUV4YW1wbGVdKSB7XG4gICAgICAgIHZhciBhZnRlckV4YW1wbGUgPSBrZXlzLmxlbmd0aCA+IDAgPyAneycgKyBrZXlzLmpvaW4oJzogLi4uLCAnKSArICc6IC4uLn0nIDogJ3t9JztcblxuICAgICAgICBlcnJvcignQSBwcm9wcyBvYmplY3QgY29udGFpbmluZyBhIFwia2V5XCIgcHJvcCBpcyBiZWluZyBzcHJlYWQgaW50byBKU1g6XFxuJyArICcgIGxldCBwcm9wcyA9ICVzO1xcbicgKyAnICA8JXMgey4uLnByb3BzfSAvPlxcbicgKyAnUmVhY3Qga2V5cyBtdXN0IGJlIHBhc3NlZCBkaXJlY3RseSB0byBKU1ggd2l0aG91dCB1c2luZyBzcHJlYWQ6XFxuJyArICcgIGxldCBwcm9wcyA9ICVzO1xcbicgKyAnICA8JXMga2V5PXtzb21lS2V5fSB7Li4ucHJvcHN9IC8+JywgYmVmb3JlRXhhbXBsZSwgY29tcG9uZW50TmFtZSwgYWZ0ZXJFeGFtcGxlLCBjb21wb25lbnROYW1lKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRLZXlTcHJlYWRbY29tcG9uZW50TmFtZSArIGJlZm9yZUV4YW1wbGVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcHJvcE5hbWU7IC8vIFJlc2VydmVkIG5hbWVzIGFyZSBleHRyYWN0ZWRcblxuICAgIHZhciBwcm9wcyA9IHt9O1xuICAgIHZhciBrZXkgPSBudWxsO1xuICAgIHZhciByZWYgPSBudWxsOyAvLyBDdXJyZW50bHksIGtleSBjYW4gYmUgc3ByZWFkIGluIGFzIGEgcHJvcC4gVGhpcyBjYXVzZXMgYSBwb3RlbnRpYWxcbiAgICAvLyBpc3N1ZSBpZiBrZXkgaXMgYWxzbyBleHBsaWNpdGx5IGRlY2xhcmVkIChpZS4gPGRpdiB7Li4ucHJvcHN9IGtleT1cIkhpXCIgLz5cbiAgICAvLyBvciA8ZGl2IGtleT1cIkhpXCIgey4uLnByb3BzfSAvPiApLiBXZSB3YW50IHRvIGRlcHJlY2F0ZSBrZXkgc3ByZWFkLFxuICAgIC8vIGJ1dCBhcyBhbiBpbnRlcm1lZGlhcnkgc3RlcCwgd2Ugd2lsbCB1c2UganN4REVWIGZvciBldmVyeXRoaW5nIGV4Y2VwdFxuICAgIC8vIDxkaXYgey4uLnByb3BzfSBrZXk9XCJIaVwiIC8+LCBiZWNhdXNlIHdlIGFyZW4ndCBjdXJyZW50bHkgYWJsZSB0byB0ZWxsIGlmXG4gICAgLy8ga2V5IGlzIGV4cGxpY2l0bHkgZGVjbGFyZWQgdG8gYmUgdW5kZWZpbmVkIG9yIG5vdC5cblxuICAgIGlmIChtYXliZUtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB7XG4gICAgICAgIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24obWF5YmVLZXkpO1xuICAgICAgfVxuXG4gICAgICBrZXkgPSAnJyArIG1heWJlS2V5O1xuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZEtleShjb25maWcpKSB7XG4gICAgICB7XG4gICAgICAgIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24oY29uZmlnLmtleSk7XG4gICAgICB9XG5cbiAgICAgIGtleSA9ICcnICsgY29uZmlnLmtleTtcbiAgICB9XG5cbiAgICBpZiAoaGFzVmFsaWRSZWYoY29uZmlnKSkge1xuICAgICAge1xuICAgICAgICByZWYgPSBjb25maWcucmVmO1xuICAgICAgfVxuXG4gICAgICB3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQoY29uZmlnLCBzZWxmKTtcbiAgICB9IC8vIFJlbWFpbmluZyBwcm9wZXJ0aWVzIGFyZSBhZGRlZCB0byBhIG5ldyBwcm9wcyBvYmplY3RcblxuXG4gICAgZm9yIChwcm9wTmFtZSBpbiBjb25maWcpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgcHJvcE5hbWUpICYmIC8vIFNraXAgb3ZlciByZXNlcnZlZCBwcm9wIG5hbWVzXG4gICAgICBwcm9wTmFtZSAhPT0gJ2tleScgJiYgKHByb3BOYW1lICE9PSAncmVmJykpIHtcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9IC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wc1xuXG5cbiAgICBpZiAodHlwZSAmJiB0eXBlLmRlZmF1bHRQcm9wcykge1xuICAgICAgdmFyIGRlZmF1bHRQcm9wcyA9IHR5cGUuZGVmYXVsdFByb3BzO1xuXG4gICAgICBmb3IgKHByb3BOYW1lIGluIGRlZmF1bHRQcm9wcykge1xuICAgICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGtleSB8fCByZWYpIHtcbiAgICAgIHZhciBkaXNwbGF5TmFtZSA9IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nID8gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgJ1Vua25vd24nIDogdHlwZTtcblxuICAgICAgaWYgKGtleSkge1xuICAgICAgICBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVmKSB7XG4gICAgICAgIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnQgPSBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCwgcHJvcHMpO1xuXG4gICAgaWYgKHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcbiAgICAgIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhlbGVtZW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIHtcbiAgICBpZiAoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBldmVyeSBlbGVtZW50IGVpdGhlciBpcyBwYXNzZWQgaW4gYSBzdGF0aWMgbG9jYXRpb24sIGluIGFuXG4gKiBhcnJheSB3aXRoIGFuIGV4cGxpY2l0IGtleXMgcHJvcGVydHkgZGVmaW5lZCwgb3IgaW4gYW4gb2JqZWN0IGxpdGVyYWxcbiAqIHdpdGggdmFsaWQga2V5IHByb3BlcnR5LlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdE5vZGV9IG5vZGUgU3RhdGljYWxseSBwYXNzZWQgY2hpbGQgb2YgYW55IHR5cGUuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgbm9kZSdzIHBhcmVudCdzIHR5cGUuXG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUNoaWxkS2V5cyhub2RlLCBwYXJlbnRUeXBlKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIG5vZGUgIT09ICdvYmplY3QnIHx8ICFub2RlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG5vZGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UpIDsgZWxzZSBpZiAoaXNBcnJheShub2RlKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IG5vZGVbaV07XG5cbiAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KGNoaWxkKSkge1xuICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoY2hpbGQsIHBhcmVudFR5cGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1ZhbGlkRWxlbWVudChub2RlKSkge1xuICAgICAgLy8gVGhpcyBlbGVtZW50IHdhcyBwYXNzZWQgaW4gYSB2YWxpZCBsb2NhdGlvbi5cbiAgICAgIGlmIChub2RlLl9zdG9yZSkge1xuICAgICAgICBub2RlLl9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obm9kZSk7XG5cbiAgICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBFbnRyeSBpdGVyYXRvcnMgdXNlZCB0byBwcm92aWRlIGltcGxpY2l0IGtleXMsXG4gICAgICAgIC8vIGJ1dCBub3cgd2UgcHJpbnQgYSBzZXBhcmF0ZSB3YXJuaW5nIGZvciB0aGVtIGxhdGVyLlxuICAgICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gbm9kZS5lbnRyaWVzKSB7XG4gICAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG5vZGUpO1xuICAgICAgICAgIHZhciBzdGVwO1xuXG4gICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KHN0ZXAudmFsdWUpKSB7XG4gICAgICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoc3RlcC52YWx1ZSwgcGFyZW50VHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4vKipcbiAqIFZlcmlmaWVzIHRoZSBvYmplY3QgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2lzdmFsaWRlbGVtZW50XG4gKiBAcGFyYW0gez9vYmplY3R9IG9iamVjdFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBgb2JqZWN0YCBpcyBhIFJlYWN0RWxlbWVudC5cbiAqIEBmaW5hbFxuICovXG5cblxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnQob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwgJiYgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG59XG52YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG4vKipcbiAqIFdhcm4gaWYgdGhlIGVsZW1lbnQgZG9lc24ndCBoYXZlIGFuIGV4cGxpY2l0IGtleSBhc3NpZ25lZCB0byBpdC5cbiAqIFRoaXMgZWxlbWVudCBpcyBpbiBhbiBhcnJheS4gVGhlIGFycmF5IGNvdWxkIGdyb3cgYW5kIHNocmluayBvciBiZVxuICogcmVvcmRlcmVkLiBBbGwgY2hpbGRyZW4gdGhhdCBoYXZlbid0IGFscmVhZHkgYmVlbiB2YWxpZGF0ZWQgYXJlIHJlcXVpcmVkIHRvXG4gKiBoYXZlIGEgXCJrZXlcIiBwcm9wZXJ0eSBhc3NpZ25lZCB0byBpdC4gRXJyb3Igc3RhdHVzZXMgYXJlIGNhY2hlZCBzbyBhIHdhcm5pbmdcbiAqIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0aGF0IHJlcXVpcmVzIGEga2V5LlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIGVsZW1lbnQncyBwYXJlbnQncyB0eXBlLlxuICovXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRXhwbGljaXRLZXkoZWxlbWVudCwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKCFlbGVtZW50Ll9zdG9yZSB8fCBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgfHwgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpO1xuXG4gICAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7IC8vIFVzdWFsbHkgdGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIG9mZmVuZGVyLCBidXQgaWYgaXQgYWNjZXB0cyBjaGlsZHJlbiBhcyBhXG4gICAgLy8gcHJvcGVydHksIGl0IG1heSBiZSB0aGUgY3JlYXRvciBvZiB0aGUgY2hpbGQgdGhhdCdzIHJlc3BvbnNpYmxlIGZvclxuICAgIC8vIGFzc2lnbmluZyBpdCBhIGtleS5cblxuICAgIHZhciBjaGlsZE93bmVyID0gJyc7XG5cbiAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Ll9vd25lciAmJiBlbGVtZW50Ll9vd25lciAhPT0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgLy8gR2l2ZSB0aGUgY29tcG9uZW50IHRoYXQgb3JpZ2luYWxseSBjcmVhdGVkIHRoaXMgY2hpbGQuXG4gICAgICBjaGlsZE93bmVyID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoZWxlbWVudC5fb3duZXIudHlwZSkgKyBcIi5cIjtcbiAgICB9XG5cbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgIGVycm9yKCdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJyArICclcyVzIFNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8sIGNoaWxkT3duZXIpO1xuXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgb3duZXIgPyBvd25lci50eXBlIDogbnVsbCk7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLnNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpIHtcbiAge1xuICAgIHZhciBpbmZvID0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG5cbiAgICBpZiAoIWluZm8pIHtcbiAgICAgIHZhciBwYXJlbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHBhcmVudFR5cGUpO1xuXG4gICAgICBpZiAocGFyZW50TmFtZSkge1xuICAgICAgICBpbmZvID0gXCJcXG5cXG5DaGVjayB0aGUgdG9wLWxldmVsIHJlbmRlciBjYWxsIHVzaW5nIDxcIiArIHBhcmVudE5hbWUgKyBcIj4uXCI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGluZm87XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYSBmcmFnbWVudCwgdmFsaWRhdGUgdGhhdCBpdCBjYW4gb25seSBiZSBwcm92aWRlZCB3aXRoIGZyYWdtZW50IHByb3BzXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZnJhZ21lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhmcmFnbWVudCkge1xuICAvLyBUT0RPOiBNb3ZlIHRoaXMgdG8gcmVuZGVyIHBoYXNlIGluc3RlYWQgb2YgYXQgZWxlbWVudCBjcmVhdGlvbi5cbiAge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZnJhZ21lbnQucHJvcHMpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcblxuICAgICAgaWYgKGtleSAhPT0gJ2NoaWxkcmVuJyAmJiBrZXkgIT09ICdrZXknKSB7XG4gICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGZyYWdtZW50KTtcblxuICAgICAgICBlcnJvcignSW52YWxpZCBwcm9wIGAlc2Agc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4gJyArICdSZWFjdC5GcmFnbWVudCBjYW4gb25seSBoYXZlIGBrZXlgIGFuZCBgY2hpbGRyZW5gIHByb3BzLicsIGtleSk7XG5cbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChmcmFnbWVudC5yZWYgIT09IG51bGwpIHtcbiAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGZyYWdtZW50KTtcblxuICAgICAgZXJyb3IoJ0ludmFsaWQgYXR0cmlidXRlIGByZWZgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuJyk7XG5cbiAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG52YXIganN4REVWID0ganN4REVWJDEgO1xuXG5leHBvcnRzLkZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbmV4cG9ydHMuanN4REVWID0ganN4REVWO1xuICB9KSgpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/jsx-dev-runtime.js ***!
  \******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvanN4LWRldi1ydW50aW1lLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSw4TEFBc0U7QUFDeEUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZWFjdC9qc3gtZGV2LXJ1bnRpbWUuanM/ZWE4NCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcycpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\n"));

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ __webpack_require__.O(0, ["main-app"], function() { return __webpack_exec__("(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Fmarcgusmano%2F%40%2Fwebinars%2FReExtNext%2Freextnext%2Fapp%2Freextgrid%2Fpage.js%22%2C%22ids%22%3A%5B%5D%7D&server=false!"); });
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);